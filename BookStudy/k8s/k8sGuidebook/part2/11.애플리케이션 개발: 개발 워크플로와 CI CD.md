# 목차
- 2파트 쿠버네티스 실무에 활용하기 (10장)
    - 11.1 도커 개발 워크플로
    - 11.2 쿠버네티스 개발 워크플로
    - 11.3 컨텍스트와 네임스페이스를 이용하여 워크로드 분리하기
    - 11.4 도커를 배제한 쿠버네티스의 지속적 전달
    - 11.5 쿠버네티스 환경의 개발자 워크플로 평가하기
    - 11.6 연습 문제

# 서론
쿠버네티스가 내부 주기와 외부 주기에 주는 영향
- 내부 주기: 로컬 컴퓨터에서 개발 중 일어나는 워크플로
- 외부 주기: 테스트 및 운영 환경으로 변경 사항이 푸시되는 CI/CD 워크플로
  
# 11.1 도커 개발 워크플로
도커는 개발 워크플로 일부를 심플하게 해준다.  
사용률이 높아지며 개발자 내부 주기에 영향을 주기 시작했다.  
  
- 실습
  - cd ch11
  - docker-compose -f bulletin-board/docker-compose.yml build
  - docker-compose -f bulletin-board/docker-compose.yml up -d
  - docker ps
- 실습
  - k8s에 앱 배치
  - docker-compose -f bulletin-board/docker-compose.yml down
  - kubectl apply -f bulletin-board/kubernetes/
  - kubectl get svc bulletin-board -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8011'
  
Dockerfile, docker-compose.yml, k8s 매니페스트 세 가지 컨테이너 아티팩트를 다루어야 한다.  
  
- 실습
  - rm bulletin-board/src/backend/events.js
  - cp bulletin-board/src/backend/events-update.js bulletin-board/src/backend/events.js
  - docker-compose -f bulletin-board/docker-compose.yml build
  - kubectl apply -f bulletin-board/kubernetes/
  - kubectl delete pod -l app=bulletin-board
  
컨테이너 기술은 만만하지 않다.  
따라서 CI/CD 파이프라인을 관장하는 팀에 맡기고, 개발팀은 이를 활용해 배포하는 방법이 있다.  
이런 경우 개발자는 도커와 k8s를 따로 학습하지 않아도 된다.  
  
# 11.2 쿠버네티스 개발 워크플로
- 개발자 작업 환경
  - git push
    - git server 주시, 특정 브랜치 push -> 
      - 빌드 파이프라인 실행 -> 이미지 빌드
        - 레지스트리 push
          - 클러스터 앱에 배치
  
위 방식은 도커나 도커 컴포즈를 배우지 않고 k8s로 이주 가능하다.  
소규모 컴포넌트들로 개발팀 분리, 전체 컴포넌트를 합쳐 전체 시스템 구성 별도 팀으로 구성된 조직에 적합한 방식이다.  
즉 전체 시스템 구성 팀만 컨테이너를 다룰 수 있으면 된다.  
  
- 실습
  - Gogs(곡스) 깃 서버 도커 허브에서 이미지 내려 받아 사용
  - kubectl apply -f infrastructure/gogs.yaml
  - kubectl wait --for=condition=ContainersReady pod -l app=gogs
  - git remote add gogs $(kubectl get svc gogs -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:3000/kiamol/kiamol.git')
  - git push gogs
  - kubectl get svc gogs -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:3000'
  
로컬 형상 관리로 gogs를 사용하고, 컨테이너 이미지 빌드 시스템도 있어야 한다.  
즉 컨테이너 런타임도 있어야 한다. 도커에서 만든 오픈 소스 도구 빌드킷(BuildKit)을 사용해보자.  
빌드컷은 도커 엔진의 이미지 빌드 기능 대체제로 다른 컴포넌트 연결 기능을 갖고 있다.  
- 실습
  - kubectl apply -f infrastructure/buildkitd.yaml
  - kubectl wait --for=condition=ContainersReady pod -l app=buildkitd
  - kubectl exec deploy/buildkitd -- sh -c 'git version && buildctl --version'
  - kubectl exec deploy/buildkitd -- sh -c 'docker version'
  
빌드팩은 도커 멀티스테이지 빌드와 동일 방식이다.  
- 컨테이너에서 빌드 도구를 사용
- 앱 런타임이 설치된 다른 컨테이너에서 컴파일된 앱 패키징 과정
  
- 실습
  - 수동 빌드 절차 시작, 자동화 변경 예정
  - kubectl exec -it deploy/buildkitd -- sh
  - cd ~
  - git clone https://github.com/sixeyed/kiamol.git
  - cd kiamol/ch11/bulletin-board/
  - buildctl build --frontend=gateway.v0 --opt source=kiamol/buildkit-buildpacks --local context=src --output type=image,nmae=kiamol/ch11-bulletin-board:buildkit
  - exit
  
빌드컷을 통해 빌드된 이미지를 레지스트리에 푸시한다.  
빌드컷은 안정적이지만, 도커 엔진 빌드 기능에 비교할 수준은 아니다.  
  
# 11.3 컨텍스트와 네임스페이스를 이용하여 워크로드 분리하기
네임스페이스는 리소스 그룹을 만드는 메커니즘이다.  
모든 K8s 객체는 네임스페이스에 속한다.  
여러 개의 네임스페이스 활용을 통해 실제 물리 클러스터를 여러 개의 가상 클러스터로 나눌 수 있다.  
  
네임스페이스는 매우 유연해서 활용 형태가 다양하다.  
- 프러덕트 별 구분
- 운영, 비운영 구분
- 사용자 별 네임스페이스 구분
  
- 실습
  - kubectl을 통해 네임스페이스 구분
  - kubectl create namespace kiamol-ch11-test
  - kubectl apply -f sleep.yaml --namespace kiamol-ch11-test
  - kubectl get pods -l app=sleep
  - kubectl get pods -l app=sleep -n kiamol-ch11-test
  
네임스페이스별 동일 앱을 동일 객체 이름으로 배치 할 수 있다.  
즉 네임스페이스간 격리된다.  
서비스 리소스를 통해 통신을 할 수 있지만, 컨트롤러는 해당 네임스페이스 안에서 파드를 찾는다.  
- 실습
  - 다른 네임스페이스에 동일 앱 동일 이름으로 리소스 생성
  - kubectl apply -f sleep-uat.yaml
  - kubectl get deploy -l app=sleep --all-namespaces
  - kubectl delete namespace kiamol-ch11-uat
  - kubectl get deploy -l app=sleep --all-namespaces
  
kubectl 명령 플래그를 통해 네임스페이스를 오갈 수 있지만, 시간 낭비와 실수 가능성이 있다.  
따라서 kubectl의 컨텍스트 기능을 활용한다.  
- 실습
  - 현재 설정 컨텍스트 확인
  - kubectl config get-contexts
  - kubectl config set-context --current --namespace=kiamol-ch11-test
  - kubectl get pods
  
기본 네임스페이스를 변경 할 수도 있고, kubectl use-context를 통홰 컨텍스트 전환도 가능하다.  
컨텍스트를 통해 클러스터 전환도 가능하다. (docker, minikube, rancher, k3s, ...)  
기본 네임스페이스 사용시 공란이다.  
  
- 실습
  - kubectl config set-context --current --namespace=
  - kubectl config view
  
# 11.4 도커를 배제한 쿠버네티스의 지속적 전달
빌드 절차는 이미지를 레지스트리에 push, pull 할 수 있어야 한다.  
- 실습
  - 레지스트리 인증 정보 담은 비밀 값 객체 생성
  - ./set-registry-variables.sh
  - kubectl create secret docker-registry registry-crds
  - TODO


# 11.5 쿠버네티스 환경의 개발자 워크플로 평가하기

# 11.6 연습 문제

# 해당 파트 사용 명령어 모음
- cd ch11
  - docker-compose -f bulletin-board/docker-compose.yml build
  - docker-compose -f bulletin-board/docker-compose.yml up -d
  - docker ps
- docker-compose -f bulletin-board/docker-compose.yml down
  - kubectl apply -f bulletin-board/kubernetes/
  - kubectl get svc bulletin-board -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8011'
- rm bulletin-board/src/backend/events.js
  - cp bulletin-board/src/backend/events-update.js bulletin-board/src/backend/events.js
  - docker-compose -f bulletin-board/docker-compose.yml build
  - kubectl apply -f bulletin-board/kubernetes/
  - kubectl delete pod -l app=bulletin-board

































