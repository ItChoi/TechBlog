# 목차
- 1파트 쿠버네티스 빠르게 훑어보기 (2장)
  - 2.1 쿠버네티스는 어떻게 컨테이너를 실행하고 관리하는가
  - 2.2 컨트롤러 객체와 함께 파드 실행하기
  - 2.3 애플리케이션 매니페스트에 배포 정의하기
  - 2.4 파드에서 실행 중인 애플리케이션에 접근하기
  - 2.5 쿠버네티스의 리소스 관리 이해하기

# 서론
k8s는 컨테이너를 통해 앱을 실행한다.  
다만 컨테이너를 직접 다룰 일은 없다.  
  
모든 컨테이너는 파드(pod)에 속한다.  
파드 안에는 1개 이상의 컨테이너가 존재한다.  
파드를 통해 다른 리소스를 관리하고 컨테이너 세부 사항을 추상화시킨다.  
이러한 설계(?)를 통해 자기수복형 App, 바람직한 상태 워크플로를 가능하게 한다.  

# 2.1 쿠버네티스는 어떻게 컨테이너를 실행하고 관리하는가
컨테이너는 App 구성 요소 하나를 실행하는 가상화된 환경이다.  
k8s는 파드라는 또 하나의 가상 환경에 컨테이너들을 포함시킨다.  
  
- 파드(pod) 
  - 컴퓨텅 단위
  - 클러스터를 이루는 노드 중 하나에서 실행
  - k8s로 관리되는 가상 IP를 갖는다.
    - ip 주소 기반 통신
    - 파드간 통신 가능
    - 다른 노드 안 파드 통신 가능
  - 파드 하나는 대게 컨테이너 하나 포함, 여러 개 포함도 가능
  - 파드 안 컨테이너들은 동일 가상 환경으로 파드의 가상 IP를 공유한다.
    - localhost간 통신 가능
  - k8s가 관리하는 가상 네트워크 연결
  
대게 파드 안에 컨테이너 하나만 포함한다면, 왜 파드를 거치도록 했을까?  
- 실습 (p.57)
  - 간단 파드는 yaml 정의 없이 k8s 명령행으로 직접 실행 가능
  - 명령어 문법은 도커와 비슷
  - kubectl run hello-kiamol --image=kiamol/ch02-hello-kiamol
    - 컨테이너 하나를 담은 파드 실행
  - kubectl wait --for=condition=Ready pod hello-kiamol
    - 파드가 준비 상태가 될 때 까지 대기
  - kubectl get pods
    - 클러스터 안 모든 파드 목록 출력
  - kubectl describe pod hello-kiamol
  - run 명령어 실행시 옵션을 따로 지정 안 해서 k8s 디폴트 값들이 적용됐다.
  
대부분의 파드는 고급 옵션을 건들지 않았다면 하나의 컨테이너만 실행한다.  
파드를 k8s가 컨테이너를 실행하는 수단으로 생각해도 된다.  
컨테이너 생성 책임은 해당 노드에 설치된 '컨테이너 런타임'에 맡긴다.  
  
파드는 k8s가 관리하는 리소스, 컨테이너는 k8s 외부에서 관리된다.  
- 실습 (p.59)
  - kubectl get pods를 통해 파드의 기본적인 정보 체크 가능
    - 출력 파라미터 지정시 더 자세하게 체크 가능
      - 체크 필드 지정
      - 복잡한 출력을 템플릿으로 직접 구성 가능
  - kubectl get pod hello-kiamol
    - kubelctl get pods와 출력 정보는 동일
  - kubectl get pod hello-kiamol --output custom-columns=NAME:metadata.name,NODE_IP:status.hostIP,POD_IP:status:podIP
    - 네트워크 상세 정보 중 특정 항목 지정 출력
  - kubectl get pod hello-kiamol -o jsonpath='{.status.containerStatuses[0].containerID}'
    - JSONPath로 복잡한 출력 구성
    - 파드의 첫 번 째 컨테이너 식별자만 출력
  
- kubectl
  - 매우 강력한 도구다.  
  - 다양한 용도로 kubectl을 사용 할 수 있어서 기능 파악이 도움이 될 것이다.
    - 리소스 중 원하는 정보만 접근
    - 자동화
  
컨테이너는 k8s가 실행하지 않는다. 컨테이너가 실제 실행된 곳을 참조할 뿐이다.  
파드는 생성시 한 노드에 배정된다.  
노드는 파드 관리, 컨테이너 실행 책임을 맡는다. (컨테이너 런타임 인터페이스라는 공통 API 이용)  
컨테이너 생성, 삭제, 체크 모두 표준 API로 제공된다.  
파드가 실행 중이라면, 파드에 필요한 모든 컨테이너가 갖춰져 있는지 노드가 체크해준다.  
- 실습
  - 모든 k8s 환경은 컨테이너 관리를 위해 동일 CRI 사용
  - k8s 외부에서 컨테이너 접근 허용하지 않는 컨테이너 런타임도 있다.
  - k8s 파드로 실행된 컨테이너 -> 컨테이너 런타임 어떻게 유지하는지 체크
  - 컨테이너 런타임 도커여야 실습 진행 가능
  - docker container ls -q --filter label=io.kubernetes.container.name=hello-kiamol
    - 파드에 포함된 컨테이너 찾기
    - docker container inspect 0bc31ee77fb6 | grep kuber
      - io.kubernetes.container.name=hello-kiamol 존재
  - docker container rm -f $(docker container ls -q --filter label=io.kubernetes.container.name=hello-kiamol)
    - 해당 컨테이너 삭제
  - kubectl get pod hello-kiamol
    - 파드 상태 확인
    - 자기 수복형 -> 삭제되자마자 k8s가 즉각적으로 대체 컨테이너 생성 후 파드 복원
      - 컨테이너를 파드로 추상화한 덕분에 가능한 플로우다.
  
k8s는 컨테이너 생성시 파드 이름을 컨테이너 레이블에 추가한다.  
이를 통해 파드에 포함된 컨테이너를 찾을 수 있다.  
  
파드 위에 추상화 중 하나가 디플로이먼트다.  
추상화 중 하나란 것은 상위 추상화가 여러 개 더 있다.  
  
이미지로 받은 컨테이너는 웹앱이다.  
하지만 아직 k8s에서 네트워크 트래픽을 파드로 전달하는 설정을 하지 않았다.  
따라서 아직 접근 불가능한데, kubectl의 기능을 통해 접근해보자.  
- 실습
  - kubectl은 네트워크 트래픽을 노드에서 파드로 전달하는 기능이 있다.
  - 클러스터 외부에서 파드와 통신이 간편해진다.
  - 로컬 컴퓨터(클러스터의 노드)의 특정 포트 주시, 요청 트래픽을 파드로 전달
  - kubectl port-forward pod/hello-kiamol 8080:80
    - 로컬 컴 8080 포트 주시하고 파드의 80 포트로 전달
    - 포트포워딩 설정을 통해 특정 포트 접근시 클러스터 안 파드로 전달한다.
  - 브라우저 -> http://localhost:8080 접근 시도
  - 확인 후 ctrl-c를 통해 포트 포워딩 중단
  
파드는 k8s에서 컴퓨팅 최소 단위다.  
따라서 역할과 동작을 잘 이해해야 한다.  
그러나 파드는 원시 타입 리소스로, 파드를 직접 실행할 일은 많지 않다.  
대게 파드 관리 컨트롤러 객체를 따로 만들어 사용한다.  

# 2.2 컨트롤러 객체와 함께 파드 실행하기
컨트롤러 객체란 객체를 추상화한 것이고, 다른 리소스들을 관리하는 k8s 리소스다.   
k8s는 복잡성은 강력하고 다양한 설정의 원동력이다.  
  
파드는 직접 사용하기에 너무 단순한 객체다.  
각 파드는 서로 다른 노드에 배정되고, 노드가 고장날 때 파드는 유실된다.  
고가용성 확보를 위해 파드를 여러 노드에 흩어지게 해야 하는데, 제대로 흩어진다는 보장이 없다.  
사람이 수동으로 각각 파드를 다른 노드에 직접 관리한다면 오케스트레이션 도구가 무색해진다.  
  
컨트롤러 객체는 이러한 불편함을 해결해준다.  
컨트롤러는 k8s API와 연동하며 시스템 상태를 감시하고, yaml에 정의한 바람직한 상태와 차이가 생길 때 원하는 상태로 바로잡는다.  
k8s는 여러 컨트롤러 객체가 있다.  
- 컨트롤러 객체
  - 디플로이먼트 -> 주로 파드 관리, 파드를 여러 노드에 흩어지게 돕는다. 파드 유실시 다른 노드에 파드 대체, 스케일링
  - ...
- 예시
  - 디플로이먼트 1
    - 파드 1
      - 컨테이너 1
    - 파드 2
      - 컨테이너 2
  - 디플로이먼트 2
    - 파드 3
      - 컨테이너 3
      - 컨테이너 4
  
디플로이먼트 1은 서로 다른 노드에서 동작 가능하다.  
디플로이먼트 2는 파드 하나가 두 개의 컨테이너를 포함하는데, 파드 하나가 여러 노드에 배치될 수 없다.  
디플로이먼트를 사용하면 두 경우 모두 고가용성 확보는 가능할 듯 하다.  
  
kubectl을 통해 이미지, 파드 설정 지정시 디 디플로이먼트를 생성할 수 있다.  
- 실습
  - 웹 앱을 디플로이먼트 사용하여 다시 실행해보자.
  - 필수 마라미터는 디플로이먼트 이름과 이미지이다.
  - kubectl create deployment hello-kiamol-2 --image=kiamol/ch02-hello-kiamol
    - 파드 이름 미지정시 k8s가 디플로이먼트 이름 뒤 무작위 문자열을 붙인다.
  - kubectl get pods
    - 파드 목록 출력
  
디플로이를 만들면서 파드를 지정하지 않고, 디플로이먼트 정의에 필요한 파드에 대한 기술했다.  
디플로이먼트는 k8s API를 통해 





# 2.3 애플리케이션 매니페스트에 배포 정의하기

# 2.4 파드에서 실행 중인 애플리케이션에 접근하기

# 2.5 쿠버네티스의 리소스 관리 이해하기

# 2.6 연습 문제

# 해당 파트 사용 명령어 모음
- kubectl run hello-kiamol --image=kiamol/ch02-hello-kiamol
- kubectl wait --for=condition=Ready pod hello-kiamol
- kubectl get pods
- kubectl describe pod hello-kiamol
- kubectl get pod hello-kiamol
- kubectl get pod hello-kiamol --output custom-columns=NAME:metadata.name,NODE_IP:status.hostIP,POD_IP:status:podIP
- kubectl get pod hello-kiamol -o jsonpath='{.status.containerStatuses[0].containerID}'
- docker container ls -q --filter label=io.kubernetes.container.name=hello-kiamol
- docker container rm -f $(docker container ls -q --filter label=io.kubernetes.container.name=hello-kiamol)
- kubectl get pod hello-kiamol
- kubectl port-forward pod/hello-kiamol 8080:80
- kubectl create deployment hello-kiamol-2 --image=kiamol/ch02-hello-kiamol 
- kubectl get pods