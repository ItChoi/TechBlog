오케스트레이션은 여러 대의 물리 서버에 걸쳐 컨테이너로 애플리케이션을 실행하는 것을 말한다.
직접 컨테이너를 관리하는 것과는 달리 클러스터에 컨테이너 관리를 위임한다.

# 12장 컨테이너 오케스트레이션: 도커 스웜과 쿠버네티스
대량의 트래픽 처리, 고가용성을 얻기 위해 여러 대의 도커 호스트로 구성된 운영 환경에서 앱 실행 방법을 알아보자.
여전히 컨테이너를 통해 앱을 실행하지만, 여러 대의 도커 호스트와 컨테이너를 관리해주는 레이어가 추가된다.

이 관리 레이어를 오케스트레이션이라고 한다. 
주요 도구로는 도커 스웜과 쿠버네티스가 있다.
도커 스웜은 도커에 내장된 형태로, 강력한 컨테이너 오케스트레이션 도구다.
쿠버는 나중에 알아서 알아보자.

최종 목표가 쿠버네티스를 익히는 것이라도 스웜을 먼저 익히는 것이 좋다.
쿠버는 초기 학습 과정이 어렵다. 스웜은 비교적 수월하다.

## 12.1 컨테이너 오케스트레이션 도구란?
도커 컴포즈는 단일 도커 호스트에서 컨테이너 실행을 위한 도구다.
단일 호스트로만 구성되지 않는 경우가 많은데,
단일 호스트의 고장은 전체 애플리케이션 중단을 일으킨다.
서비스의 고가용성을 위해 오케스트레이션이 필요하다.

오케스트레이션 도구란 클러스터를 구성하는 여러 대의 호스트 컴퓨터를 의미한다.
컨테이너들을 관리하고, 작업을 여러 컴퓨터에 분배하고 네트워크 트래픽 부하를 고르게 분산시키고, 상태 불량 컨테이너를 재시작하거나 새 컨테이너로 교체한다.

각 호스트에 도커 설치 후 클러스터를 만들고 오케스트레이션 플랫폼(스웜, 쿠버네티스, ...)에 등록 후 관리한다.

컨테이너 플랫폼은 여러 대의 서버를 묶어 관리한다.
클러스터 API를 통해 yaml을 전달하면, 앱이 배포 되고 오케스트레이션 도구가 어떤 서버에서 어떤 컨테이너를 동작할지 결정한다.

컨테이너는 오케스트레이션 도구에 의해 관리되고, 컨테이너의 건강상태를 보고 한다.
클러스터는 내부에 배포된 앱들에 대한 모든 정보가 담긴 데이터와, 스케줄러, 호스트간 통신 시스템 등이 있다.
일부 컨테이너가 동자하지 않는다면 상태 이상을 체크하여 재실행하거나 새 컨테이너로 대체한다.

## 12.2 도커 스웜으로 클러스터 만들기
도커 스웜은 도커 엔진에 포함돼 있다.
도커 엔진을 스웜 모드로 전환해 클러스트를 초기화하면 된다.

실습) p.345 참고
- docker swarm init
  - 도커 스웜 초기화
  - 클러스터 매니저 - 해당 컴퓨터는 스웜 매니저가 된다.
    - 매니저, 워커 두 가지 역할 중 하나를 맡고, 다른 컴퓨터를 워커로 참여시키는 명령어도 있다.
      - docker swarm join --token SWMTKN-1-3-21kdfsdkfjsdfslvlnfvld-fdvdfvv 192.168.65.3:2377

매니저는 클러스터 관리 작업 직접 수행한다.
클러스터 데이터베이스, API, 컨테이너 모니터링, 스케줄링 모두 매니저 노드에 저장되고 동작한다.
워커는 매니저의 스케줄링에 따라 컨테이너 실행, 상태를 주기적으로 매니저에 보고한다.
물론 매니저도 워커 역할 수행 가능하다.

스웜에 추가된 컴퓨터를 노드라고 부른다.
스웜에 노드로 추가 하려면, 스웜과 같은 네트워크에 있어야 하고, PW 역할을 하는 참가 토큰을 매니저로부터 발급 받아야 한다.
- 같은 네트워크
- 매니저에게 참가 토큰 발급 받기

실습) p.346 참고
- docker swarm join-token worker
  - 워커 참가 토큰
- docker swarm join-token manager
  - 매니저 참가 토큰
- docker node ls

단일 노드나 여러 노드나 동작 방식은 같지만, 
단일 노드는 여러 노드에 비해 높은 고가용성을 가질 순 없고 컨테이너 수를 증가시키는 스케일링이 불가능하다.

개발, 테스트 환경은 단일 노드 스웜으로 충분하다.
동작 방식은 노드가 여러 개 스웜과 동일하다.

운영용 스웜은 세 개의 매니저 노드가 있다.
클러스터 데이터베이스, 스케줄러, 모니터링 등 가용성이 향상된다.
세 개의 매니저 노드로 수백 대의 워커 노드 관리 가능하고,
애플리케이션을 대규모로 스케일링 가능하다.

쿠버네티스보다 도커 스웜은 클러스터 구성, 관리 작업이 단순하다.
- docker swarm init
- docker swarm join

## 12.3 도커 스웜 서비스로 애플리케이션 실행하기
컨테이너 플랫폼은 컨테이너를 직접 실행할 필요 없이 대신 실행해준다.
서비스는 컨테이너를 추상화한 개념이다.
하나의 서비스가 여러 컨테이너로 배포 될 수 있다는 점에서 도커 컴포즈의 서비스와 의미가 같다.

서비스는 컨테이너와 동일한 정보로 정의되고, 서비스 이름이 도커 네트워크상 도메인이 된다는 점도 컨테이너와 같다.
차이점이라면, 여러 개의 레플리카를 가질 수 있다는 점이다.

실습) p.419 참고
- docker service create -name timecheck --replicas 1 diamol/ch12-timecheck:1.0
- docker service ls
  - 레플리카 수 등 정보 출력

서비스는 도커 스웜의 일급 객체다.
서비스를 다루려면 도커 엔진이 스웜 모드이거나, 스웜 매니저에 연결된 상태여야 한다.
실습에서 실행한 서비슨느 하나의 레플리카를 실행중이다.

레플리카는 평범한 도커 컨테이너다.
노드가 하나 뿐인 스웜에서 모든 레플리카가 같은 서버에서 실행된다.

컨테이너 관리를 스웜이 대신하여 컨테이너를 직접 다룰 일이 적어진다. 물론 직접 다룰 수도 있다.
실습) p.420 참고
- docker service ps timecheck
- docker container rm -f $(docker container ls --last 1 -q)
- docker service ps timecheck 
  - 컨테이너 삭제했지만, 여전히 스웜이 실행중이다. 
  - 수동 컨테이너 삭제 -> 스웜은 컨테이너 부족으로 판단, 대체 컨테이너 실행(새 레플리카)
    - 즉 컨테이너들을 서비스로 보고 스웜에 관리를 맡긴다. 수동 삭제해도, 스웜 판단에 의해 새 컨테이너가 생성된다.

실습) p.423 참고
- docker service logs --since 10s timecheck
  - 최근 10초간 로그 출력
- docker service inspect timecheck -f '{{.Spec.TaskTemplate.ContainerSpec.Image}}'
  - 서비스 정보 중 이미지 정보 출력

도커 컴포즈와 스웜의 가장 큰 차이는 앱 정의 저장 공간의 존재 유무다.
앱 정의는 컴포즈 파일에만 들어있다.
스웜 모드는 앱 정의가 클러스터에 정의되므로, yaml 파일이 존재하지 않아도 원격에서 앱 관리 가능하다.

실습) p.503 참고
- docker service update --image diamol/ch12-timecheck:2.0 timecheck
  - 서비스에 사용된 이미지 버전 수정
- docker service ps timecheck
  - 서비스의 레플리카 목록 확인
- docker service logs --since 20s timecheck
  - 레플리카 로그 확인

모든 컨테이너 오케스트레이션 도구는 앱 중단을 하지 않고 점진적으로 컨테이너를 교체해 나가는 롤링 업데이트 방식을 사용한다.
애플리케이션을 여러 개의 레플리카로 실행했다면 중단없이 업데이트 가능하다.
롤링 업데이트는 세밀한 설정이 가능하다. 
롤링 업데이트는 구버전, 신버전 모두 실행되고 있으므로, 직접 관리가 필요하게 된다.

자동화된 롤링 업데이트는 수동 배포에 비하여 크게 발전한 방식이다.
업데이트 과정에서 신규 투입 컨테이너 상태를 확인하는데, 상태 이상시 자동 업데이트를 중단하여 앱의 문제가 발생하지 않도록 한다.
스웜은 이전 버전 서비스 정의 내용이 남아 있으므로, 명령 한 번으로 이전 버전으로 롤백 할 수 있다.

실습) p.508 참고
- docker service update --rollback timecheck
- docker service ps timecheck
- docker service logs --since 25s timecheck

롤백 과정도 롤링을 거친다.
되돌아가는 것이기 떄문에 이미지 태그를 지정할 필요 없다.
이전 상태의 정의를 기억하지 않아도 되는 것이 장점이다.

스웜 모드에서는 컨테이너보단 서비스를 주로 다룬다.
스웜 모드에서 컨테이너간 도커 네트워크를 통해 통신되고, 외부 트래픽은 공개된 포트로만 컨테이너로 전달된다.

## 12.4 클러스터 환경에서 네트워크 트래픽 관리하기
스웜 모드의 네트워크는 표준 TCP/IP 방식이다.
1. 컴포넌트는 도메인 네임으로 서로를 식별한다.
2. 도커 DNS 서버는 도메인 네임을 조회해 IP 주소를 알아낸다.
3. IP 주소로 트래픽을 전달한다.
4. 트래픽은 컨테이너로 전달되고, 컨테이너가 응답을 보낸다.

스웜 모드에서는 오버레이 네트워크라는 새로운 형태의 도커 네트워크를 사용 할 수 있다.
오버레이 네트워크: 클러스터에 속한 모든 노트를 연결하는 가상 네트워크
서비스의 이름을 도메인 네임삼아 다른 서비스와 통신 가능하다.

서로 다른 오버레이 네트워크에 속한 서비스간 통신은 불가능하다.

오버레이 네트워크와 도커 네트워크의 차이점 중 하나는,
도커 컴포즈를 통해 하나의 서비스를 여러 개의 컨테이너로 스케일링 했을 때, 서비스 질의는 전적으로 서비스를 사용하는(컨슈머) 쪽이었다.
즉 서비스 질의시 포함된 모든 컨테이너의 IP 주소가 응답에 포함되고, 사용자 쪽에서 셀렉해서 질의한다.
반면 스웜에서 서비스는 수백 개의 레플리카를 가질 수 있으므로, 오버레이 네트워크에서는 서비스를 가르키는 가상 IP 주소 하나만 반환한다.

실습) p. 515
- docker service rm timecheck
- docker network create --driver overlay iotd-net
- docker service create --detach --replicas 3 --network iotd-net --name iotd diamol/ch09-image-of-the-day
  - --detach 옵션을 통해 CLI 도구가 레플리카가 모두 실행될 때 까지 기다리지 않는다.
- docker service create --detach --replicas 2 --network iotd-net --name accesslog diamol/ch09-access-log
- docker service ls

두 서비스를 오버레이 네트워크에 연결했다.
도커 네트워크에도 종류가 있다.
스웜 모드에서는 overlay가 기본 타입으로 사용된다.
명시적으로 타입 지정을 습관화하는 것이 좋다.

가상 IP 주소 확인하려면 레플리카 컨테이너에서 터미널로 접속하는 방법이 가장 간단하다.
터미널을 통해 서비스 이름으로 DNS 조회해 응답에서 IP 주소를 확인한다.
실습) p.517 참고
- docker container exec -it $(docker container ls --last 1 -q) sh
  - 가장 최근 실행 컨테이너의 터미널을 연다.
    - 어느 서비스에 속한 레플리카라도 무방
- nslookup iotd
- nslookup accesslog

서비스에 여러 개의 컨테이너를 실행함에도 서비스마다 하나의 IP 가상 주소가 조회된다.
서비스마다 모든 레플리카를 공유하는 주소다.

오버레이 네트워크는 앱 관점에서 전혀 겉으로 드러나지 않는다.

인그레스 네트워크는 스웜을 구성하는 모든 노드가 서비스가 공개한 포트를 감시하는 방식으로 동작한다.
따라서 모든 노드에 요청이 도달 될 수 있다.

실행중이지 않은 컨테이너에 도달된 경우, 다른 노드로 요청을 포워딩한다.
노드 안에 컨테이너가 여러 개라면, 도커 엔진이 고르게 요청을 분배한다.

서비스 포트 공개시 인그레스 네트워크가 기본적으로 사용된다.

실습) p.522 참고
- docker service create --detach --name image-gallery --network iotd-net --publish 8010:80 --replicas 2 diamol/ch09-image-gallery
- docker service ls

윈도 호스트 컴은 localhost를 통해 스웜 서비스에 접근 할 수 없다.
윈도 네트워크 스택이 지닌 한계 탓이다.

앱 배포와 관리에 클러스터 크기는 영향이 크지 않다.

## 12.5 도커 스웜과 쿠버네티스 중 무엇을 사용할까?
도커 스웜은 상대적으로 기능이 간단한 컨테이너 오케스트레이션 도구로 설계됐다.

네트워크, 서비스 개념을 도커 컴포즈에서 차용해, 오케스트레이션 도구로서 도커 엔진에 잘 녹였다.
오케스트레이션 도구는 여럿 있지만, 대부분 도커 스웜 또는 쿠버네티스를 사용한다.

쿠버네티스는 확장성이 뛰어나 로드밸런서, 스토리지 등 앱 배포를 지원하는 자사 프러덕트와 통합하기 유리하다.
현재 도커 스웜을 매니지드 서비스 형태로 제공하는 클라우드 사업자는 없다.
쿠버와 달리 확장성이 부족해 자사  프러덕트와 통합하기 곤란한 것도 하나의 이유가 된다.

쿠버네티스용 yaml 파일은 쿠버에서만 사용 가능한 리소스가 기술되고, 스웜에 비해 훨씬 어렵고 복잡하다.
yaml 정의도 스웜에 비해 쿠버는 5~10배 더 길어진다.

따라서 도커 스웜을 먼저 도입 한 후 없는 기능이 필요해질 때, 쿠버네티스로 이전 방식을 추천한다.
이전시 낭비 비용이 없다.
쿠버네티스 이전 결정 기준 사항
1. 인프라스트럭처 
앱을 클라우드 환경에 배포시 쿠버가 더 적합하다.
온프레미스 환경이라면 관리 면에서 스웜이 훨씬 간편하다.

2. 학습 곡선
스웜은 도커와 도커 컴포즈의 연장선상에 있어 다소 부담이 덜 하다.
쿠버를 위해 새로운 도구를 학습해야 한다.

3. 기능
쿠버는 복잡하다. 세세한 설정 기능이 많기 때문이다.
예를 들어 블루 그린 배포, 자동 스케일링, 역할 기반 접근 제어 등 쉽게 적용 가능하다.
반면 스웜에서는 까다롭다.

4. 미래를 위한 투자
오픈 소스 커뮤니티는 매우 활동적이다.
스웜은 쿠버와 달리 신규 기능이 추가된지 꽤 됐다.  

결국 기술 로드맵의 종착점은 쿠버네티스가 될 것이다.
하지만 서두룰 필요는 없다.


## 12.6 연습 문제
- 실습) p.532 참고
- docker network --driver overlay test-12
- docker service create --detach --replicas 3 --network test-12 --name num-api diamol/numbers-api:v3
- docker service create --detach --replicas 3 --network test-12 --publish 8020:80 --name num-web diamol/numbers-web:v3
---

# 13장 도커 스웜 스택으로 분산 애플리케이션 배포하기
12장까지 해오면서 CLI를 통해 꽤 많은 시간을 할애했다.
그러나 실무에서는 명령행 도구를 사용할 일이 없을 것이다.
실무에서는 앱을 yaml 파일로 정의해 매니저 노드에 이 파일을 전달하는 방법을 쓴다.
이를 통해 오케스트레이션 도구가 실행 방법을 결정한다.

## 13.1 도커 컴포즈를 사용한 운영 환경
도커 스웜은 컴포즈를 만날 때 위력을 발휘한다.
개발 환경을 동일한 파일 포맷을 사용할 수 있는 덕분이다.

```yaml
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports: 
      - 8080:80
```
스웜에도 동일한 파일을 사용해 앱 배포 가능하다.
마찬가지로 배포 후 레플리카 하나를 실행 중인 서비스가 생성되고, 이 서비스는 인그레스 네트워크를 통해 포트를 공개하고 있을 것이다.
스웜 모드에서는 앱 배포시 스택을 만든다.
스택은 서비스, 네트워크, 볼륨 등 여러 개의 도커 리소스를 묶어 만든다.

실습) p.536 
- 

## 13.2 컨피그 객체를 이용한 설정값 관리

## 13.3 비밀 값을 이용한 대외비 설정 정보 관리하기

## 13.4 스웜에서 볼륨 사용하기

## 13.5 클러스터는 스택을 어떻게 관리하는가?

## 13.6 연습 문제

---

# 14장 업그레이드와 롤백을 이용한 업데이트 자동화

---

# 15장 보안 원격 접근 및 CI/CD를 위한 도커 설정

---

# 16장 어디서든 실행할 수 있는 도커 이미지 만들기: 리눅스, 윈도, 인텔, ARM

---