컨테이너화된 앱을 실제 운영에 투입 전에 중요한 것들을 배운다.
도커 이미지 최적화, 앱을 도커 플랫폼에 통합하는 내용이다.
여기서 말하는 통합은 앱 설정 파일을 도커에서 읽고 앱의 로그를 도커에 출력하는 것이다.

또한 리버스 프록시와 메시지 큐를 도커와 결합해 강력하고 직관적인 설계를 만들 수 있다.

# 17장 도커 이미지 최적화하기: 보안, 용량, 속도
컨테이너화된 도커 앱을 운영 환경에 투입 전 최적화를 해야 한다.
가장 중요한 것이 바로 이미지 최적화다.
최적화를 통해 이미지 빌드와 배포가 빠르게 되고, 앱의 보안이 지켜질 수 있다.

Dockerfile 문법이 간단하고 직관적이긴하다.
하지만 최선의 성능을 위해 복잡한 내막을 이해해야 한다.

## 17.1 도커 이미지를 최적화하는 방법
도커 이미지는 이미 최적화가 상당히 잘 된 포맷이다.
이미지끼리 레이어를 최대한 공유해서 이미지 빌드, 네트워크 트래픽, 디스크 사용량을 효율적으로 사용할 수 있다.
하지만 도커는 데이터를 명시적으로 삭제하지 않는 한 자동 삭제는 안 된다.
즉 앱의 업데이트를 통해 새로운 이미지를 내려 받아도, 기존 이미지가 삭제되지 않는다.
이러한 이유로 주기적 업데이트가 오히려 디스크 용량 잠식을 부르는 경우가 많다.

실습) 17.1 (1)
- docker system df
  - 내려 받은 이미지, 컨테이너과 볼륨, 빌드 캐시 등 점유 중인 실제 디스크 용량 체크 가능

도커 엔진에서 오래된 이미지를 제거한 적이 없다면, 디스크 용량을 보고 깜짝 놀랄 수 있다.
기간이 길수록 관리되지 않는다면 환장하게 된다.
따라서 주기적으로 사용하지 않는 이미지 레이어, 빌드 캐시를 비워주는 것이 좋다.
- docker system prune

실제 수동 삭제를 통해 관리하는 방법도 있지만, 이미지를 잘 최적화한다면 이 문제는 크게 줄어든다.
기술 스택 최적화 작업은 작은 개선을 지속적 반복하는 형태가 많다.
하지만 도커는 베스트 프랙티스 준수만으로 큰 폭의 개선이 가능하다.
1. 꼭 필요한 파일만 이미지에 포함시켜야 한다.
   - 실제 Dockerfile 스크립트 작성시 사용되지 않을 이미지, 문서 파일까지 한 꺼번에 디렉터리 채로 포함시키는 경우가 많다.
   - COPY 인스트럭션은 꼭 필요한 파일만 골라 복사하는 편이 낫다. 전체 복사 후 선별 삭제는 이미 전체가 특정 이미지 레이어에 포함되게 된다.
   - 도커 파일 리팩토링 서적 참고
     - 간단하게 불필요한 파일, 폴더 직접 삭제 명령어 추가로 이미지 크기가 줄어들거라 생각하면 오산이다.
     - 아래 실습을 통해 특정 파일 수동 삭제 명령어 입력, 미입력 두 개로 이미지를 빌드해도 크기는 동일한 것을 알 수 있다.

실습) 17.1 (2) 리팩토링 비교
- cd ch17/exercises/build-context
- docker image build -t diamol/ch17-build-context:v1 .
- docker image build -t diamol/ch17-build-context:v2 -f ./Dockerfile.v2 .
- docker image ls -f reference='diamol/ch17*'

Dockerfile 스크립트의 인스트럭션 하나마다 이미지 레이어가 하나씩 생긴다.
이미지 레이어가 모두 합쳐져 전체 이미지가 된다.
한 번 이미지에 복사된 파일은 이미지에서 뺼 수 없다.
복사 후 파일 또는 폴더가 삭제되더라도 파일 시스템에 숨겨질 뿐 물리 삭제가 되지 않는다.
이미지 최적화시 가장 먼저 고려해야 되는 점이다.

실습) 17.1 (3) 
- docker container run diamol/ch17-build-context:v2
 - 전체 이미지로 컨테이너 실행
- docker history diamol/ch17-build-context:v2
 - 이미지 히스토리를 통해 삭제 이전 레이어 식별자 확인
- docker container run <이전_레이어_식별자)

이미지 구조 중간에 오는 레이어로도 컨테이너 실행 가능하다.
다만 파일 시스템의 내용이 해당 레이어까지만 병합된 상태다.
    
COPY 인스트럭션을 통해 이미지 최적화를 해도 아직 최적화의 여지는 남았다.
도커 빌드 과정은 엔진에 빌드 컨텍스트 압축을 하고 도커 스크립트를 함께 보내면서 시작된다.
이 빌드 컨텍스트에 불필요한 파일이 포함된 경우가 많다.
2. .docerignore 파일을 통해 불필요 디렉터리, 파일 목록을 기재해 빌드 컨텍스트에서 제외할 수 있다.
   - .gitignore에 있는 목록들을 같이 포함시켜도 된다.

실습) 17.1 (4) .dockeringore 파일 작성, 최적화 
- docker image build -t diamol/ch17-build-context:v3 -f ./Dockerfile.v3 .
  - 컨텍스트에 불필요 파일들 존재
- mv rename.dockerignore .dockerignore
- docker image build -t diamol/ch17-build-context:v3 -f ./Dockerfile.v3 .

## 17.2 좋은 기반 이미지를 고르는 법
기반 이미지의 크기는 디스크 용량, 네트워크 전송 시간 뿐 아니라, 애플리케이션 보안과도 관계가 깊다.
크기가 크면 다양한 도구가 포함되어 있는데, 유용한지와는 별개로  컨테이너의 보안상 허점이 될 수 있다.
예를 들어 OS 기반 이미지에 curl가 설치 돼 있다면, 침입한 공격자가 이를 악용해 악성 프로그램을 컨테이너로 내려받거나, 데이터를 가로챌 수 있다.

자바 앱은 OpenJDK 공식 이미지를 기반으로 많이 사용한다.
도커 허브에서 변종 이미지 목록만 확인해도, 기반 이미지 크기가 천차만별인 것을 확인할 수 있다.

따라서 크기가 작은 기반 이미지, 변종 이미지부터 검토해야 한다.
FROM 인스트럭션에서 기반 이미지를 쉽게 바꿀 수 있으므로 여러 번 테스트하여 적합한 이미지를 찾으면 된다.

이미지에 많은 것이 포함된다면, 침입자가 다음 공격으로 이어 나갈 좋은 수단이 되기도 한다.

실습) 17.2 (1)
- cd ch17/exercises/truth-app
- docker image build -t diamol/ch17-truth-app .
- docker container run -d -p 8010:80 --name truth diamol/ch17-truth-app
- curl http://localhost:8010/truth


실습) 17.2 (2), 셸로 접속해 공격자 빙의
- docker container exec -it truth sh
- javac FileUpdateTest.java
  - 컨테이너 내부 자바 테스트 코드 컴파일, 실행
- java FileUpdateTest
- exit

특정 api의 결과 값이 바뀌었다.
심한 경우 컨테이너를 망가뜨릴 수 있다.

이미지에 방치한 불필요한 파일이 공격수단이 될 수 있다.
즉 기반 이미지는 앱 실행에 필요한 모든 것을 갖춰야 하지만, 빌드에 필요한 도구는 포함시키면 안 된다.
인터프리터 언어는 빌드 도구가 앱 실행에 사용되므로 해당되지 않는다.

골든 이미지는 이러한 문제를 피할 수 있는 한 가지 방법이다.

실습) 17.2 (3) 앤코어는 오픈 소스 도커 이미지 분석 도구다. pwd 사용해 저장소 복제 후 실습 진행
- cd ch17/exercises/anchore
- docker-compose up -d
- docker exec anchore_engine-api-1 anchore-cli system wait
- docker container cp "$(pwd)/../../../image/openjdk/Dockerfile" anchore_engine-api-1:/Dockerfile
- docker container exec anchore_engine-api-1 anchore-cli image add diamol/openjdk --dockerfile /Dockerfile
- docker container exec anchore_engine-api-1 anchore-cli image wait diamol/openjdk

wait 명령을 통해 앤코어의 사용 준비가 끝날 때 까지 터미널 세션을 막아 놓았다.
앤코어 분석이 끝나면 이미지에 포함된 다양한 문제점을 지적한다.

실습) 17.2 (4) anchore-cli wait 명령 끝난 후 체크
- docker container exec anchore_engine-api-1 anchore-cli image content diamol/openjdk java
  - 이미지에 사용된 자바 컴포넌트 확인
- docker container exec anchore_engine-api-1 anchore-cli image vuln diamol/openjdk all
  - 이미지에 발견된 취약점 체크

예제에 컴포즈 파일에 사용된 이미지들은 위협이 되지 않는다는 안내가 나와서 사용해도 무방하다.
openjdk:11-jdk 이미지 분석 결과 많은 취약점이 나오게 된다.
그 중 코어 SSL 보안 라이브러리의 '낮음' 등급 하나를 제외하면 대부분 심각도가 '불명'이다.
OpenJDK가 공식 배포한 이미지라도 만족하지 못 하는 경우 사용하지 않을 근거가 된다.

앤코어는 취약점 분석 일개 도구다.
어떤 도구를 사용하더라도 이미지의 보안상 문제점을 이해하고 신뢰성을 향상시킬 수 있다.

## 17.3 이미지 레이어 수와 이미지 크기는 최소한으로
앱 이미지 최적화 전제 조건은 최소한의 크기, 보안성을 갖추는 것이다.
그 후 꼭 필요한 것만 포함하여 이미지를 만든다.
심플하지만 쉽지 않다.
대부분 불필요 요소나 설치 후 잔재가 발생한다.
따라서 이런 요소도 확실히 통제, 제어 해야 한다.

실습) 17.3 (1) 패키지 목록 제거를 통해 정리하면 이미지 크기를 얼마나 줄일 수 있는지 체크해본다
- cd ch17/exercises/socat
- docker image build -t diamol/ch17-socat:v1 .
- docker image build -t diamol/ch17-socat:v2 -f Dockerfile.v2 .

두 이미지는 기능적으로 동일하다
그러나 한 이미지가 20MB 가량 더 적다.
패키지 설치 명령에 몇 가지 조정
1. apt 추천 패키지 설치하지 않는 옵션 사용
2. 설치 후 패키지 목록의 캐시 삭제를 하나의 RUN 인스트럭션으로 합쳤다.

여러 개의 RUN 인스트럭션을 하나로 합치는데는 또 다른 장점도 있다.
- 이미지 레이어 수를 줄이는 것은 최적화가 아니지만, 최대 레이어 수가 제한 돼 있다. (보통 127개)
  - 여분 레이어 남기는 것이 유의미
  - 레이어가 적으면 컨테이너 파일 시스템 내용 추적이 수월

실습) 17.3 (2)
- cd ch17/exercises/ml-dataset
- docker image build -t diamol/ch17-ml-dataset:v1 .
- docker image build -t diamol/ch17-ml-dataset:v2 -f Dockerfile.v2 .
- docker image ls -f reference=diamol/ch17-ml-dataset

디스크 용량이 가장 절약되는 부분 중 하나는 필요한 파일만 압축 해제하는 것이다.
위에 실습에서 v1, v2의 크기 차이는 엄청나다.

개발 업무 편의를 유지하면서 이미지 최적화 방법이 또 있다.
파일을 다루는 단계를 모두 스테이지로 분리해 디스크 용량 절약하는 멀티 스테이지 빌드다.

## 17.4 멀티 스테이지 빌드를 한 단계 업그레이드하기
멀티 스테이지는 최종 결과 이미지를 최적화하기 유리하다.

```yaml
# 스크립트 가독성과 이미지 치적화를 모두 고려한 멀티 스테이지 스크립트
FROM diamol/base AS download
ARG DATASET_URL=https://archive.ics.uci.edu/.../url_svmlight.tar.gz
RUN wget -0 dataset.tar.gz ${DATASET_URL}

FROM diamol/base AS expand
COPY --from=download dataset.tar.gz .
RUN tar xvzf dataset.tar.gz

FROM diamol/base
WORKDIR /dataset/url_svmlight
COPY --from=expand url_svmlight/Day1.svm .
```

실습) 17.4 (1) target 값 지정을 통한 멀티 스테이지 빌드 중단
- cd ch17/exercises/ml-dataset
- docker image build -t diamol/ch17-ml-dataset:v3 -f Dockerfile.v3 .
  - 버전 이미지 끝까지 빌드
- docker image build -t diamol/ch17-ml-dataset:v3-download -f Dockerfile.v3 --target download .
  - download 스테이지까지만 빌드한다 - Dockerfile은 같고 태그가 달라진다.
- docker image build -t diamol/ch17-ml-dataset:v3-expand -f Dockerfile.v3 --target expand .
  - expand 스테이지까지만 빌드
- docker image ls -f reference='diamol/ch17-ml-dataset:v3*'
  - 이미지 크기 확인

중간 단계에서 끊긴 이미지는 오히려 이미지 크기가 상당히 크다.
최종 단계 이미지 빌드는 오히려 작은 이미지 크기로 보아, 최적화된 이미지라 볼 수 있다.

실습) 17.4 (2) 최소 요소로 젠킨스 이미지 설치
- cd ch17/exercises/jenkins
- docker image build -t diamol/ch17-jenkins:v1 .
- docker image build -t diamol/ch17-jenkins:v2 -f Dockerfile.v2 .
- echo 2.0 > jenkins.install.UpgradeWizard.state
- docker image build -t diamol/ch17-jenkins:v1 .
- docker image build -t diamol/ch17-jenkins:v2 -f Dockerfile.v2 .

도커파일 내 스크립트의 캐시를 잘 활용하면 소스 코드 수정으로 CI/CD 파이프라인에서 시간 낭비하지 않고도 이미지를 빌드, 푸시 할 수 있다.
그러나 RUN 인스트럭션을 사용해 내려받거나 설치한 다른 SW처럼 불필요 요소까지 캐싱하지 않도록 주의해야 한다.

## 17.5 최적화가 중요한 이유
Dockerfile 스크립트를 위한 베스트 프랙티스 정리
1. 기반 이미지 잘 고르기, 자신만의 골든 이미지 갖출 수 있다면 이상적이다.
2. 아주 간단한 앱이 아니라면 멀티 스테이지 빌드 적용
3. 불필요 패키지, 파일 포함하지 말고, 레이어 크기를 최소한으로 유지
4. Dockerfile 스크립트의 인스트럭션은 자주 수정되는 것을 뒤에 오도록 배치해 캐시를 최대한 활용

## 17.6 연습 문제
- 서적 참고

- docker image build -t diamol/ch17-test-linux ./linux
- docker image build -t diamol/ch17-test-window ./windows


---

# 18장 컨테이너의 애플리케이션 설정 관리
애플리케이션은 환경에 따른 설정을 외부로부터 주입받아야 한다.
설정은 주로 환경 변수 또는 파일 형태를 갖는다.
도커는 컨테이너에서 실행되는 앱 환경을 만들어 주고, 환경 변수를 설정하고 파일 시스템을 구성한다.
여러 곳에 분리된 설정 값을 잘 활용해 병합함으로써 환경 설정을 구성하면 된다.

## 18.1 다단 애플리케이션 설정
설정 모델은 설정에 담긴 데이터의 구조를 반영해야 한다.
설정 데이터 종류 세 가지
1. 버전에 따라 달라지는 설정
2. 환경에 따라 달라지는 설정
3. 기능 설정: 버전 별로 앱 동작을 달리하기 위한 설정

config: 기본 설정으로 도커 이미지에 포함되는 설정
config-override: 이미지에 미포함이지만 볼륨, 컨피그 객체, 비밀 값 등을 통해 컨테이너 파일 시스템에 주입되는 과정

실습) 18.1 (1) 앱 기본 설정으로 실행, 오버라이드 후 실행
- cd ch18/exercises/access-log
- docker container run -d -p 8080:80 diamol/ch18-access-log
- docker container run -d -p 8081:80 -v "$(pwd)/config/dev:/app/config-override" diamol/ch18-access-log
- curl http://localhost:8080/config
- curl http://localhost:8081/config

실습) 18.1 (2) 
- cd ch18/exercises/access-log
- docker container run -d -p 8082:80 -v "$(pwd)/config/dev:/app/config-override" -e NODE_CONFIG='{\"metrics\": {\"enabled\":\"true\"}}' diamol/ch18-access-log
- curl http://localhost:8082/config

프로메테우스 정보 수집 비활성화를 통해 CPU와 메모리 자원 절약 가능하다.
따라서 비활성화로 했다가, 환경 변수 값 수정을 통해 활성화하여 정보 수집을 할 수 있다.

이런 방식이 모든 앱에 기본적으로 적용되는 핵심 패턴이다.
하지만 이 패턴은 실수 발생 여지가 있다.
따라서 유연성을 조금 희생하고 위험을 해결할 방법이 있다.

## 18.2 환경별 설정 패키징하기
환경 변수, 설정 파일을 배포에 포함시킬 수 있는 다양한 방법을 제공한다.

닷넷 코어는 두 파일로부터 기본 설정 값을 읽어들인다.
1. appsettings.json:
2. appsettings.{환경_이름}.json:
3. 환경 변수: 환경 이름 정의 및 오버라이드 설정

실습) 18.2 (1) 기본 설정 앱 실행, 테스트 환경 설정 재실행
- docker container run -d -p 8083:80 diamol/ch18-todo-list
- docker container run -d -p 8084:80 -e DOTNET_ENVIRONMENT=Test diamol/ch18-todo-list

동일한 이미지를 사용해 앱을 실행했지만, 서로 다른 설정 파일이 적용됐다.
설정 파일과 소스 코드 별도 시스템으로 관리시 이런 방법도 유용하다.
레지스트리는 항상 외보 노출 위험이 있다고 가정하고 보안에 만전을 가해야 한다.
그렇지 않으면 패스워드, API 키 등 이미지를 통해 평문으로 유출 될 수도 있다.

실습) 18.2 (2) 오버라이드 설정 파일 활용
- cd ch18/exercises/todo-list
- docker container run -d -p 8085:80 -e DOTNET_ENVIRONMENT=Production -v "$(pwd)/config/prod-local:app/config-override" diamol/ch18-todolist

실습) 18.2 (3) 환경 변수 이용해 릴리스 주기 정보 오버라이드
- docker container run -d -p 8086:80 -e DOTNET_ENVIRONTMENT=Production -e release=CUSTOM -v "$(pwd)/config/prod-local:/app/config-override" diamol/ch18-todo-list

이미지에 설정 파일을 모두 포함시키는 방법이 널리 쓰이긴 하지만, 저자는 이 방식을 선호하지 않는다.
스스로 판단하기를 민감하지 않은 정보를 포함하겠지만, 보안 부서의 판단 기준은 다를 수 있기 때문이다.
서버 이름, URL, 파일 경로, 로그 수준, 캐시 크기 등 생각치도 못한 유용한 공격 정보가 될 수 있다.

저자는 설정 정보를 소스 코드 형상 관리와 설정 관리로 이원화하는 것을 선호하지 않는다.

## 18.3 런타임에서 설정 읽어 들이기
Go 언어에서 바이퍼(Viper)라는 설정 모듈이 널리 쓰인다.
패키지 목록에 해당 설정 파일을 추가하고, 오버라이드 읽어올 설정 디렉터리 지정만 하면 된다.
1. 이미지에 포함된 config 디렉터리
2. 환경 별 설정 파일은 config-override 디렉터리에서 읽어 들이고, 이미지에서 비어 있따가 파일 시스템 마운트로 외부에서 주입된다.
3. 환경 변수는 설정 파일의 설정 값을 오버라이드 할 수 있다.

go 언어는 TOML, JSON, YAML 등 활용 가능하지만 TOML이 널리 쓰인다.
```toml
release = "19.12"
environment = "UNKNOWN"

[metrics]
enabled = true

[apis]
    [apis.image]
    url = "http://iotd/image"

    [apis.access]
    url = "http://accesslog/access-log"
```

TOML은 특히 클라우드 기반 프로젝트에서 장점이 더 크기에 널리 사용된다.
가독성과 디버깅이 수월하고 병합 도구를 통해 버전별 설정 차이 체크가 쉽다.

확장자만 제외하면 앱의 설정 관리는 Node.js와 동일하다.

실습) 18.3 (1)
- docker container run -d -p 8086:80 diamol/ch18-image-gallery
- curl http://localhost:8086/config

민감한 데이터를 API를 통해 노출되면 안 되기 때문에, API 유의 사항은 다음과 같다.
1. 전체 설정을 공개하지 않는다. 민감 정보는 절대 포함시키지 마라.
2. 허가받은 사용자만 접근 가능하도록 엔드포인트에 보안 설정
3. 설정 API의 사용 여부를 설정 할 수 있도록 한다.

실습) 18.3 (2) 오버라이드 파일로 환경별 설정 구성 후 실행
- cd ch18/exercises/image-gallery
- docker container run -d -p 8087:80 -v "$(pwd)/config/dev:/app/config-override" diamol/ch18-image-gallery
- curl http://localhost:8087/config

조직에서 도커 첫 도입시 사용 범위가 급속하게 확산되는 경향이 있다.
도커를 통한 다양한 앱 실행과 설정도 다양하다.
오버라이드 설정 파일, 환경 변수 형식은 표준화하기 어렵다.

실습) 18.3 (3) 설정 오버라이드
- cd ch18/exercises/image-gallery
- docker container run -d -p 8088:80 -v "$(pwd)/config/dev:/app/config-override" -e IG_METRICS.ENABLED=TRUE diamol/ch18-image-gallery
- curl http://localhost:8088/config

## 18.4 레거시 애플리케이션에 설정 전략 적용하기
레거시 앱도 나름 기존의 설정 전략이 있다.
그러나 보통 환경 변수, 설정 파일을 통한 병합하는 것은 지원하지 않는다.

그러나 Dockerfile 스크립트를 잘 활용하면 설정 전략을 적용할 수 있다.
컨테이너에 주입된 설정 파일을 앱 설정 전략에 맞춰 변환하는 유틸리티 또는 스크립트를 이미지에 포함시키는 방법이다.
1. 컨테이너에 지정된 오버라이드 설정 파일 읽기
2. 환경 변수에서 오버라이드 설정 읽기
3. 오버라이드 설정 파일과 환경 변수 설정 병합, 환경 변수 값이 우선이다.
4. 병합된 오버라이드 설정을 컨테이너 내 대상 설정 파일에 추가

실습) 18.4 (1) 레거시 앱 기본 설정, 오버라이드 설정 각각 적용 후 실행
- cd ch18/exercises/image-of-the-day
- docker container run -d -p 8089:80 diamol/ch18-image-of-the-day
- docker container run -d -p 8090:80 -v "$(pwd)/config/dev:/config-override" -e CONFIG_SOURCE_PATH="/config-override/application.properties" diamol/ch18-image-of-the-day
- curl http://localhost:8089/config
- curl http://localhost:8090/config

도커 이미지 확장을 통해 레거시 앱을 현대적 설정 모델을 도입 할 수 있다.
어쩔 수 없이 시간 간격이 생기고, 컨테이너 실패 여지가 생긴다.
따라서 대처 가능하도록 항시 헬스 체크를 적용해야 한다.

실습) 18.4 (2)
- docker run -d -p 8091:80 -v "$(pwd)/config/dev:/config-override" -e CONFIG_SOURCE_PATH="/config-override/application.properties" -e IOTD_ENVIRONMENT="custom" diamol/ch18-image-of-the-day
- curl http://localhost:8091/config

실습) 18.4 (3)
- docker container rm -f $(docker container ls -aq)
- cd ch18/exercises
- docker-compose up -d
- curl http://localhost:8030/config
- curl http://localhost:8020/config
- curl http://localhost:8010/config

## 18.5 유연한 설정 모델의 이점
실무에서 버전에 따라 다른 설정은 이미지에 포함시키고, 
환경 별로 다른 설정은 컨테이너 플랫폼에서 제공하는 오버라이드 파일을 통해 적용하고,
환경 변수를 통해 통제하는 기능별 설정을 덧붙일 수 있다.

이러한 설정 모델을 통해 운영 환경 이슈에 기민하게 대응 가능하다.
설정 모델에 대한 시간 투자는 동일 이미지로 모든 환경의 앱을 동작시키는 결과로 보답 받는다.

유연한 설정을 위해서는 책에 나온 내용 외에도 많다.
모든 컨테이너 런타임은 컨피그 객체, 비밀 값, 환경 변수 설정 기능을 갖추고 있다.

## 18.6 연습 문제

---

# 19장 도커를 이용한 로그 생성 및 관리

---

# 20장 리버스 프록시를 이용해 컨테이너 HTTP 트래픽 제어하기

---

# 21장 메시지 큐를 이용한 비동기 통신

---

# 22장 끝없는 정진

---
