컨테이너화된 앱을 실제 운영에 투입 전에 중요한 것들을 배운다.
도커 이미지 최적화, 앱을 도커 플랫폼에 통합하는 내용이다.
여기서 말하는 통합은 앱 설정 파일을 도커에서 읽고 앱의 로그를 도커에 출력하는 것이다.

또한 리버스 프록시와 메시지 큐를 도커와 결합해 강력하고 직관적인 설계를 만들 수 있다.

# 17장 도커 이미지 최적화하기: 보안, 용량, 속도
컨테이너화된 도커 앱을 운영 환경에 투입 전 최적화를 해야 한다.
가장 중요한 것이 바로 이미지 최적화다.
최적화를 통해 이미지 빌드와 배포가 빠르게 되고, 앱의 보안이 지켜질 수 있다.

Dockerfile 문법이 간단하고 직관적이긴하다.
하지만 최선의 성능을 위해 복잡한 내막을 이해해야 한다.

## 17.1 도커 이미지를 최적화하는 방법
도커 이미지는 이미 최적화가 상당히 잘 된 포맷이다.
이미지끼리 레이어를 최대한 공유해서 이미지 빌드, 네트워크 트래픽, 디스크 사용량을 효율적으로 사용할 수 있다.
하지만 도커는 데이터를 명시적으로 삭제하지 않는 한 자동 삭제는 안 된다.
즉 앱의 업데이트를 통해 새로운 이미지를 내려 받아도, 기존 이미지가 삭제되지 않는다.
이러한 이유로 주기적 업데이트가 오히려 디스크 용량 잠식을 부르는 경우가 많다.

실습) 17.1 (1)
- docker system df
  - 내려 받은 이미지, 컨테이너과 볼륨, 빌드 캐시 등 점유 중인 실제 디스크 용량 체크 가능

도커 엔진에서 오래된 이미지를 제거한 적이 없다면, 디스크 용량을 보고 깜짝 놀랄 수 있다.
기간이 길수록 관리되지 않는다면 환장하게 된다.
따라서 주기적으로 사용하지 않는 이미지 레이어, 빌드 캐시를 비워주는 것이 좋다.
- docker system prune

실제 수동 삭제를 통해 관리하는 방법도 있지만, 이미지를 잘 최적화한다면 이 문제는 크게 줄어든다.
기술 스택 최적화 작업은 작은 개선을 지속적 반복하는 형태가 많다.
하지만 도커는 베스트 프랙티스 준수만으로 큰 폭의 개선이 가능하다.
1. 꼭 필요한 파일만 이미지에 포함시켜야 한다.
   - 실제 Dockerfile 스크립트 작성시 사용되지 않을 이미지, 문서 파일까지 한 꺼번에 디렉터리 채로 포함시키는 경우가 많다.
   - COPY 인스트럭션은 꼭 필요한 파일만 골라 복사하는 편이 낫다. 전체 복사 후 선별 삭제는 이미 전체가 특정 이미지 레이어에 포함되게 된다.
   - 도커 파일 리팩토링 서적 참고
     - 간단하게 불필요한 파일, 폴더 직접 삭제 명령어 추가로 이미지 크기가 줄어들거라 생각하면 오산이다.
     - 아래 실습을 통해 특정 파일 수동 삭제 명령어 입력, 미입력 두 개로 이미지를 빌드해도 크기는 동일한 것을 알 수 있다.

실습) 17.1 (2) 리팩토링 비교
- cd ch17/exercises/build-context
- docker image build -t diamol/ch17-build-context:v1 .
- docker image build -t diamol/ch17-build-context:v2 -f ./Dockerfile.v2 .
- docker image ls -f reference='diamol/ch17*'

Dockerfile 스크립트의 인스트럭션 하나마다 이미지 레이어가 하나씩 생긴다.
이미지 레이어가 모두 합쳐져 전체 이미지가 된다.
한 번 이미지에 복사된 파일은 이미지에서 뺼 수 없다.
복사 후 파일 또는 폴더가 삭제되더라도 파일 시스템에 숨겨질 뿐 물리 삭제가 되지 않는다.
이미지 최적화시 가장 먼저 고려해야 되는 점이다.

실습) 17.1 (3) 
- docker container run diamol/ch17-build-context:v2
 - 전체 이미지로 컨테이너 실행
- docker history diamol/ch17-build-context:v2
 - 이미지 히스토리를 통해 삭제 이전 레이어 식별자 확인
- docker container run <이전_레이어_식별자)

이미지 구조 중간에 오는 레이어로도 컨테이너 실행 가능하다.
다만 파일 시스템의 내용이 해당 레이어까지만 병합된 상태다.
    
COPY 인스트럭션을 통해 이미지 최적화를 해도 아직 최적화의 여지는 남았다.
도커 빌드 과정은 엔진에 빌드 컨텍스트 압축을 하고 도커 스크립트를 함께 보내면서 시작된다.
이 빌드 컨텍스트에 불필요한 파일이 포함된 경우가 많다.
2. .docerignore 파일을 통해 불필요 디렉터리, 파일 목록을 기재해 빌드 컨텍스트에서 제외할 수 있다.
   - .gitignore에 있는 목록들을 같이 포함시켜도 된다.

실습) 17.1 (4) .dockeringore 파일 작성, 최적화 
- docker image build -t diamol/ch17-build-context:v3 -f ./Dockerfile.v3 .
  - 컨텍스트에 불필요 파일들 존재
- mv rename.dockerignore .dockerignore
- docker image build -t diamol/ch17-build-context:v3 -f ./Dockerfile.v3 .

## 17.2 좋은 기반 이미지를 고르는 법
기반 이미지의 크기는 디스크 용량, 네트워크 전송 시간 뿐 아니라, 애플리케이션 보안과도 관계가 깊다.
크기가 크면 다양한 도구가 포함되어 있는데, 유용한지와는 별개로  컨테이너의 보안상 허점이 될 수 있다.
예를 들어 OS 기반 이미지에 curl가 설치 돼 있다면, 침입한 공격자가 이를 악용해 악성 프로그램을 컨테이너로 내려받거나, 데이터를 가로챌 수 있다.

자바 앱은 OpenJDK 공식 이미지를 기반으로 많이 사용한다.
도커 허브에서 변종 이미지 목록만 확인해도, 기반 이미지 크기가 천차만별인 것을 확인할 수 있다.

따라서 크기가 작은 기반 이미지, 변종 이미지부터 검토해야 한다.
FROM 인스트럭션에서 기반 이미지를 쉽게 바꿀 수 있으므로 여러 번 테스트하여 적합한 이미지를 찾으면 된다.

이미지에 많은 것이 포함된다면, 침입자가 다음 공격으로 이어 나갈 좋은 수단이 되기도 한다.

실습) 17.2 (1)
- cd ch17/exercises/truth-app
- docker image build -t diamol/ch17-truth-app .
- docker container run -d -p 8010:80 --name truth diamol/ch17-truth-app
- curl http://localhost:8010/truth


실습) 17.2 (2), 셸로 접속해 공격자 빙의
- docker container exec -it truth sh
- javac FileUpdateTest.java
  - 컨테이너 내부 자바 테스트 코드 컴파일, 실행
- java FileUpdateTest
- exit

특정 api의 결과 값이 바뀌었다.
심한 경우 컨테이너를 망가뜨릴 수 있다.

이미지에 방치한 불필요한 파일이 공격수단이 될 수 있다.
즉 기반 이미지는 앱 실행에 필요한 모든 것을 갖춰야 하지만, 빌드에 필요한 도구는 포함시키면 안 된다.
인터프리터 언어는 빌드 도구가 앱 실행에 사용되므로 해당되지 않는다.

골든 이미지는 이러한 문제를 피할 수 있는 한 가지 방법이다.

실습) 17.2 (3) 앤코어는 오픈 소스 도커 이미지 분석 도구다. pwd 사용해 저장소 복제 후 실습 진행
- cd ch17/exercises/anchore
- docker-compose up -d
- docker exec anchore_engine-api-1 anchore-cli system wait
- docker container cp "$(pwd)/../../../image/openjdk/Dockerfile" anchore_engine-api-1:/Dockerfile
- docker container exec anchore_engine-api-1 anchore-cli image add diamol/openjdk --dockerfile /Dockerfile
- docker container exec anchore_engine-api-1 anchore-cli image wait diamol/openjdk

wait 명령을 통해 앤코어의 사용 준비가 끝날 때 까지 터미널 세션을 막아 놓았다.
앤코어 분석이 끝나면 이미지에 포함된 다양한 문제점을 지적한다.

실습) 17.2 (4) anchore-cli wait 명령 끝난 후 체크
- docker container exec anchore_engine-api-1 anchore-cli image content diamol/openjdk java
  - 이미지에 사용된 자바 컴포넌트 확인
- docker container exec anchore_engine-api-1 anchore-cli image vuln diamol/openjdk all
  - 이미지에 발견된 취약점 체크

예제에 컴포즈 파일에 사용된 이미지들은 위협이 되지 않는다는 안내가 나와서 사용해도 무방하다.
openjdk:11-jdk 이미지 분석 결과 많은 취약점이 나오게 된다.
그 중 코어 SSL 보안 라이브러리의 '낮음' 등급 하나를 제외하면 대부분 심각도가 '불명'이다.
OpenJDK가 공식 배포한 이미지라도 만족하지 못 하는 경우 사용하지 않을 근거가 된다.

앤코어는 취약점 분석 일개 도구다.
어떤 도구를 사용하더라도 이미지의 보안상 문제점을 이해하고 신뢰성을 향상시킬 수 있다.

## 17.3 이미지 레이어 수와 이미지 크기는 최소한으로
앱 이미지 최적화 전제 조건은 최소한의 크기, 보안성을 갖추는 것이다.
그 후 꼭 필요한 것만 포함하여 이미지를 만든다.
심플하지만 쉽지 않다.
대부분 불필요 요소나 설치 후 잔재가 발생한다.
따라서 이런 요소도 확실히 통제, 제어 해야 한다.

실습) 17.3 (1) 패키지 목록 제거를 통해 정리하면 이미지 크기를 얼마나 줄일 수 있는지 체크해본다
- cd ch17/exercises/socat
- docker image build -t diamol/ch17-socat:v1 .
- docker image build -t diamol/ch17-socat:v2 -f Dockerfile.v2 .

두 이미지는 기능적으로 동일하다
그러나 한 이미지가 20MB 가량 더 적다.
패키지 설치 명령에 몇 가지 조정
1. apt 추천 패키지 설치하지 않는 옵션 사용
2. 설치 후 패키지 목록의 캐시 삭제를 하나의 RUN 인스트럭션으로 합쳤다.

여러 개의 RUN 인스트럭션을 하나로 합치는데는 또 다른 장점도 있다.
- 이미지 레이어 수를 줄이는 것은 최적화가 아니지만, 최대 레이어 수가 제한 돼 있다. (보통 127개)
  - 여분 레이어 남기는 것이 유의미
  - 레이어가 적으면 컨테이너 파일 시스템 내용 추적이 수월

실습) 17.3 (2)
- cd ch17/exercises/ml-dataset
- docker image build -t diamol/ch17-ml-dataset:v1 .
- docker image build -t diamol/ch17-ml-dataset:v2 -f Dockerfile.v2 .
- docker image ls -f reference=diamol/ch17-ml-dataset

디스크 용량이 가장 절약되는 부분 중 하나는 필요한 파일만 압축 해제하는 것이다.
위에 실습에서 v1, v2의 크기 차이는 엄청나다.

개발 업무 편의를 유지하면서 이미지 최적화 방법이 또 있다.
파일을 다루는 단계를 모두 스테이지로 분리해 디스크 용량 절약하는 멀티 스테이지 빌드다.

## 17.4 멀티 스테이지 빌드를 한 단계 업그레이드하기
멀티 스테이지는 최종 결과 이미지를 최적화하기 유리하다.



## 17.5 최적화가 중요한 이유

## 17.6 연습 문제
---

# 18장 컨테이너의 애플리케이션 설정 관리

---

# 19장 도커를 이용한 로그 생성 및 관리

---

# 20장 리버스 프록시를 이용해 컨테이너 HTTP 트래픽 제어하기

---

# 21장 메시지 큐를 이용한 비동기 통신

---

# 22장 끝없는 정진

---
