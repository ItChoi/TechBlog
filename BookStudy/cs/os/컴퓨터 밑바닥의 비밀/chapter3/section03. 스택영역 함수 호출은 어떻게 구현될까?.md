# 저수준 계층? 메모리라는 사물함에서부터 시작해 보자

## 스택영역: 함수 호출은 어떻게 구현될까?

### 3.3.1 프로그래머를 위한 도우미: 함수

### 3.3.2 함수 호출 활동 추적하기: 스택
- 후입선출 (LIFO)
  - Stack 데이터 구조 처리에 적합하다.

### 3.3.3 스택 프레임 및 스택 영역: 거시적 관점
- 모든 함수는 실행 시 자신만의 작은 상자가 필요하다.
  - 작은 상자: 스택 프레임(stack frame) 또는 호출 스택(call stack)
- 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가
  - A -> B -> C

### 3.3.4 함수 점프와 반환은 어떻게 구현될까?
- A() -> B() 호출
  - 제어권이 A에서 B함수로 옮겨진다.
  - 제어권: 실제 CPU가 실행하는 기계 명령어
  - CPU -> A 실행 -> B로 점프: 제어권이 A에서 B로 이전
- 제어권 이전시 두 가지 정보 필요
  1. 반환: 어디서 왔는지 정보
  2. 점프: 어디로 가는지 정보
  - 정보 획득 및 유지를 위해 스택 프레임이 필요하다!

### 3.3.5 매개변수 전달과 반환값은 어떻게 구현될까?
- 대부분의 경우 매개변수, 반환 값을 가져오는 작업을 레지스터로 한다.
- CPU 내부 레지스터 수는 제한 돼 있다.
  - 매개 변수 수 > 사용 가능 레지스터 수
    - 함수 스택 프레임 활용!

### 3.3.6 지역 변수는 어디에 있을까?
- 전역 변수는 실행 파일의 데이터 영역에 저장되어 있다가 프로그램 실행 시 프로세스 주소 공간의 데이터 영역에 적재된다.
- 지역 변수는 레지스터에 저장 할 수 있다.
  - 지역 변수 수 > 레지스터 수
    - 매개 변수와 마찬가지로 스택 프레임에 저장

### 3.3.7 레지스터의 저장과 복원
- 레지스터 공유로 문제가 될 수도 있다.

### 3.3.8 큰 그림을 그려보자, 우리는 지금 어디에 있을까?
- 스택 영역 안에 스택 프레임이 위치한다.
- 함수 호출 단계 증가 -> 메모리 차지 -> 스택 영역 크기 제한 -> 초과시 스택 오버 플로우
  - 너무 큰 지역 변수를 만들면 안 된다.
  - 함수 호출 단계가 너무 많으면 안 된다.
- 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있나?
  - 스택 영역 추가, 감소 -> 누가 책임? -> 생각해보기 (아마 프로세스인듯)