# 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

## 2.6 동기와 비동기를 철저하게 이해한다.

### 2.6.1 고된 프로그래머

### 2.6.2 전화 통화와 이메일 보내기
- 통화 -> 동기
- 이메일 -> 수신, 발신 -> 답장을 기다리며 다른 일을 한다.

### 2.6.3 동기 호출
- 일반적으로 동기 호출 -> 동일 스레드에서 실행
- 동기 호출 특수한 상황
  - 입출력 작업 -> read 함수를 호출해 파일 읽는다고 가정
    - 사용자 -> 커널 -> 시스템 콜 -> OS 파일 I/O -> 호출 스레드가 일시 중지된다.
      - 일시 중지된 스레드는 커널이 디스크 내용을 읽어오면 깨어난다. -> 블로킹 입출력

### 2.6.4 비동기 호출
- 일반적으로 함수의 비동기 호출은 두 개의 스레드가 사용된다.
- 일반적으로 백그라운드 형태로 실행한다. (시간이 많이 걸리는 I/O)
  - 디스크의 파일 I/O
  - 네트워크 데이터 송수신,
  - 데이터베이스 작업
- 파일을 비동기로 읽는다면?
  - 주 스레드 -> 새 스레드 (파일 읽기) -> 각자 작업 실행 -> 새 스레드는 read 완료시 주 스레드에 완료 통지
- 비동기 호출의 작업 완료 시점을 어떻게 파악할 수 있나?
  1. 호출자가 실행 결과를 전혀 신경 스지 않는 상황
     - 콜백 함수 사용 (전달된 함수를 통해 파일 알아서 처리)
  2. 호출자가 실행 결과를 반드시 알아야 하는 상황
     - 알림 작동 방식 -> 작업 실행 완료시 호출자에게 완료 신호 또는 메시지 전송

### 2.6.5 웹 서버에서 동기와 비동기 작업
- 이용자 요청 -> (A B C) (DB 작업) (D E F)
  - DB 작업만 I/O 요청이라고 가정 (일반적인 OLTP 흐름)
  - DB 작업 요청 후 주 스레드가 블로킹되어 일시 중지
  - DB 작업 완료 후 -> D E F 작업 이어서 진행
  - DB 작업이 처리 될 때 주 스레드는 유휴 시간(idle time)이 생긴다.
  - 스레드 -> 주 스레드, 데이터베이스 스레드 두 개
- 위 상황에 비동기 처리!
  1. 주 스레드가 데이터베이스 처리 결과 -> 영향 X
     - A B C -> 주 스레드에서 완료
     - DB 작업, D E F -> 데이터베이스 스레드에서 완료
       - D E F 작업 -> 콜백 함수 활용 -> wrapper() { D(), E(), F() } -> wrapper()를 콜백 함수로 전달
       - D E F 작업은 데이터베이스 역할이 아니라 콜백 함수 호출로 대신한다.
  2. 두 스레드가 데이터베이스 처리 결과 -> 영향 O
     - 알림 활용, 데이터베이스 스레드 -> 주 스레드 작업 결과 전송!
- 동기보다 비동기 스레드가 효율적인 이유
  - 주 스레드의 유후 시간(idle time) 없이 끊임없이 작업 가능
  - 시스템 리소스 최대한 활용 가능 -> 유저 입장에서 시스템 응답 속도가 빠르다.