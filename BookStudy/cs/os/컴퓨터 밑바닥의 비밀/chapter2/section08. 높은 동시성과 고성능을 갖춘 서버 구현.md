# 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

## 2.8 높은 동시성과 고성능을 갖춘 서버 구현
- 핸드폰, PC에서 수천 수만 개 요청을 동시에 처리해주는 서버의 비밀에 대해 생각해보자.
  - 어떻게 모두 처리하고, 어떤 기술이 관련되어 있을까?

### 2.9.1 다중 프로세스
- 가장 간단한 형태의 병행 처리 방식인 다중 프로세스 사용!
- 리눅스 -> fork 방식을 통해 자식 프로세스 생성
  - 부모 프로세스가 요청을 받는다.
  - 자식 프로세스를 생성해 사용자 요청 처리
  - 장점
    - 프로그래밍이 간단하고 매우 이해하기 십다.
    - 개별 프로세스 주소 공간 서로 격리! -> 서로 영향 X
    - 다중 코어 리소스 최대 활용 가능
  - 단점
    - 개별 프로세스 주소 공간 서로 격리! -> IPC 필요 할 땐 난이도가 더 올라간다.
    - 프로세스 생성 및 종료는 시스템 부담을 증가시킨다.

### 2.8.2 다중 스레드
- 프로세스 생성 및 종료, IPC 통신 부담이 없다.
- 프로세스 주소 공간 공유
- 스레드 블로킹 -> 다른 스레드 영향 X
- 통신의 편리함은 제공 받지만, 많은 문제가 있기도 하다.
  - 스레드 안전 문제 -> 동기화시 상호 배제 작동 방식 사용 필요
  - 교착 상태 문제 가능성
- 사용자 요청이 매우 많은 경우 -> C10K 문제 -> 다중 스레드만으로 감당이 어렵다.
  - 프로세스 생성 종료에 비해 부담이 적지만, 부담이 없는 것이 아니다.
  - 매우 많은 사용자 요청 -> 스레드 생성 및 종료 -> 과도한 메모리 소비, 성능 손실

### 2.8.3 이벤트 순환과 이벤트 구동
- 병행 프로그래밍 -> 프로세스, 스레드에만 의존? -> 아니다. 
- 이벤트 기반의 동시성을 이용한 -> 이벤트 기반 프로그래밍
  - GUI 프로그래밍, 서버 프로그래밍에서 널리 사용
  - 원리는 매우 간단하다.
- 이벤트 원리
  - 이벤트 프로그래밍 기술 두 가지 요소 필요
    1. 이벤트(event)
       - 이벤트는 대부분 입출력 
         - 네트워크 데이터의 수신 여부
         - 파일 읽기/쓰기 가능 여부
    2. 이벤트를 처리하는 함수
       - 일반적으로 이벤트 핸들러(event handler)라고 한다.
  - 이벤트 도착 -> 이벤트 유형 확인 -> 유형에 대응하는 이벤트 핸들러 찾기 -> 직접 이벤트 핸들러 호출
- 서버에서 이벤트는 사용자 요청
  - 이벤트를 계속 수신, 처리 -> 반복 처리 필요(while, for, ...) -> 이벤트 순환(event loop)
  - 이벤트 순환 수행 매우 간단 -> 이벤트 도착시 대응하는 이벤트 핸들러 호출
- 이벤트 사용시 해결해야 할 두 가지 문제
  1. 이벤트 소스 -> getEvent 함수 하나로 어떻게 여러 이벤트를 가져올 수 있나?
     - 입출력 다중화 기술로 해결
     - 이벤트 순환을 위한 감시자 역할이 있고, ...
  2. 이벤트 핸들러가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 할까?
     - 상황마다 다르다.
     - 단일 스레드 -> 순차 처리(단일 CPU)
     - 다중 스레드 -> 병행 실행 -> 시스템 다중 코어 활용(다중 CPU)

### 2.8.4 첫 번째 문제: 이벤트 소스와 입출력 다중화
- 리눅스, 유닉스 세계는 모든 것이 파일로 취급된다.
  - 프로그램, 소켓 -> 파일 서술자를 사용해 입출력 작업 실행

### 2.8.5 두 번째 문제: 이벤트 순환과 다중 스레드

### 2.8.6 카페는 어떻게 운영되는가: 반응자 패턴
- 가정
  - 손님이 많아지고 있는 상황
  - 간단 메뉴(커피, 우유) -> 빠르게 준비해 처리 가능
  - 복잡 메뉴(파스타, ...) -> 주방에 있는 동안 고객 응대 불가
    - 다행히 주방에 요리사가 있고, 파스타 만들라는 명령만 전달! -> 완료시 알림!
  - 이로써 모든 메뉴를 빠르게 요청을 받고 응대 할 수 있다.
    - 고객 -> 이벤트 순환에 해당
    - 주방 요리사 -> 작업자 스레드 해당
    - 카페 운영 전체 방식 -> 반응자 패턴

### 2.8.7 이벤트 순환과 입출력
- 요청 처리 과정 (입출력 작업 포함)
  1. 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우
     - 논블로킹 인터페이스 호출시 스레드 일시중지가 없다.
     - 인터페이스가 즉시 반환 -> 이벤트 순환에서 직접 호출 가능
  2. 입출력 작업에 블로킹 인터페이스만 있는 경우
     - 이벤트 순환 내 어떠한 블로킹 인터페이스던 호출 절대 X
       - 이벤트 순환 스레드 일시 중지 -> 전체 시스템이 정상 동작 X
     - 블로킹 입출력 호출 포함 작업 -> 작업자 스레드에 전달!

### 2.8.8 비동기와 콜백 함수
- 가정
  - 전자상 거래 앱 -> 상품 검색 -> 네 개의 백엔더 서비스 관여
    - 검색 서비스
      - 사용자 정보
      - 상품 정보
      - 재고 정보
    - 서버는 일반적으로 원격 프로시저 호출(remote procedure call), 즉 RPC를 통해 통신
    - RPC 호출들은 모두 블로킹 호출! -> 사용자가 응답하기 전 함수 반환 X

### 2.8.9 코루틴: 동기 방식의 비동기 프로그래밍

### 2.8.10 CPU, 스레드, 코루틴
- CPU는 기계 명령어를 실힝해 컴퓨터를 움직이게 한다.
- 스레드는 일반적으로 커널 상태 스레드라고 하며, 커널로 생성되고 스케줄링을 한다.
  - 커널은 스레드 우선순위에 따라 CPU 연산 리소스를 할당
- 코루틴에서 커널은 스레드에 따라 CPU 시간 할당
  - CPU 할당 시간 내 실행 코루틴 결정 가능!