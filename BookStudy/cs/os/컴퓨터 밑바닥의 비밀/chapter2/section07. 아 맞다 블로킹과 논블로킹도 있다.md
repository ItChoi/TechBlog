# 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

## 2.7 아 맞다! 블로킹과 논블로킹도 있다
- 동기는 A, B 두 대상이 강하게 결합됐다.
  - A -> 의존 -> B
  - 결합 및 제약이 없다면 비동기!
- 동기와 비동기는 프로그래밍 영역에만 국한되지 않는다.

### 2.7.1 블로킹과 논블로킹
- 블로킹, 논블로킹 -> 주로 함수 호출 시 사용된다.
  - 함수 A, B가 있다고 가정
    - A() { B() }
      - B()를 호출함과 동시에 OS가 함수 A가 실행 중인 스레드나 프로세스 일시 중지 O -> B 호출 방식은 블로킹 방식
      - B()를 호출함과 동시에 OS가 함수 A가 실행 중인 스레드나 프로세스 일시 중지 X -> B 호출 방식은 논블로킹 방식
- 블로킹 호출 핵심
  - 스레드 또는 프로세스가 일시 중지된다.
  - 모든 함수 호출이 호출자의 스레드를 일시 중지시키는 것은 아니다.

### 2.7.2 블로킹의 핵심 문제: 입출력
- 일반적으로 대부분 입출력과 관련 있다.
- 디스크 -> 하나의 트랙 탐색 입출력 요청 완료 소요시간 -> ms 단위 수준
- CPU 클럭 주파수 -> GHz 단위 수준 도달, 즉 디스크 작업을 CPU에 하면 대량 기계 명령어 실행 가능
- CPU 제어권 상실 및 되찾는 시간 동안 스레드나 프로세스는 블로킹(일시 중지)
- 스레드는 입출력 작업 실행시 블로킹되어 일시 중지, 다른 스레드에 CPU가 할당된다.
  - 입출력 작업 완료가 확인되면 다시 중지된 스레드에 CPU를 할당한다.
- OS는 CPU 리소스를 최대한 잘 활용해야 한다.
  - 스레드 간 CPU 사용 시간 효율적인 할당 -> 블로킹 입출력 방식이 필요한 핵심적인 이유
- I/O 작업은 느리다 -> 관련 함소 호출시 스레드 또는 프로세스는 블로킹 된다. -> CPU 효율적인 사용!

### 2.7.3 논블로킹과 비동기 입출력
- 네트워크 데이터 수신 예제로 알아보자.
  - 데이터 수신 함수 recv() -> 논블로킹 함수
  - recv() 호출시
    - 스레드 일시 중지 없다.
    - 즉시 반환
    - 호출 스레드는 자신의 작업 계속 진행
    - 데이터 수신 작업 -> 커널이 처리
- 비동기 요청 전달, 데이터 수신 체크 세 가지 방법
  1. 논블로킹 방식 결과 확인 함수 함께 제공 -> 함수 호출을 통해 수신 데이터 체크
  2. 데이터 수신시 알림 작동 방식 사용
  3. 논블로킹 함수 호출시 데이터 수신 처리 콜백 함수를 매개 변수로 전달

### 2.7.4 피자 주문에 비유하기
- 블로킹 호출
  - 피자 가게 방문 후 주문 -> 피자 완성까지 대기 -> 피자 받고 다른 업무
- 논블로킹 호출
  - 앱으로 주문 -> 피자 배달 전 까지 다른 업무
  - 피자 완성을 어떻게 알 수 있을까?
    1. 배달에 관심이 없는 방법
    2. 매장에 주기적으로 전화를 거는 방법

### 2.7.5 동기와 블로킹
- 동기와 블로킹은 유사하다. 즉 동일하진 않단 말이다.
- 블로킹 호출은 모두 동기 호출이다.
- 동기 호출은 반드시 블로킹 호출은 아니다.
- sum() 함수 호출 -> 블로킹 또는 스레드 일시중지가 되진 않는다.
  - I/O 입출력이 아니라서.

### 2.7.6 비동기와 논블로킹
- 네트워크 데이터 수신 예제로 알아보자.
  - 데이터 수신 recv() -> 논블로킹 호출, 네티워크 데이터 처리 콜백 함수 매개변수로 전달
    - 비동기이자 논블로킹
  - 시스템이 네트워크 데이터 도착 감지 함수 제공하면 -> 논블로킹이자 동기 코드가 될 수도 있다.
- 논블로킹이더라도 전체적으로 반드시 비동기는 아니다.
- 프로세스, 스레드, 코루틴 + 동기, 비동기, 블로킹, 논블로킹 = 고성능 서버!!
- 
