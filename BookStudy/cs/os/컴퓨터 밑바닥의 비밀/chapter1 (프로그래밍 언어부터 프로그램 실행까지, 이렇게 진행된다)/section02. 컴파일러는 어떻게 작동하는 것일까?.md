# 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

## 1.2 컴파일러는 어떻게 작동하는 것일까?
- 자세히 알지 못해도 이미 접해봤다. IDE -> run 버튼 클릭

### 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다
- 컴파일러란?
  - 고수준 언어를 저수준 언어로 번역하는 프로그램
  - 평범한 프로그램에 불과
  - 코드 작성 -> 코드는 일반적인 텍스트 파일 형태로 저장된다 - 소스 파일
  - 소스 파일을 컴파일러를 통해 실행 파일 형태로 만든다.
  - 실행 파일은 CPU가 직접 실행할 수 있는 기계 명령어
- 인간의 추상적인 표현은 CPU가 이해할 수 없다. 컴파일러의 도움을 받아야 한다
  - 인간은 추상적인 표현으로 코드 작성 -> 컴파일러 번역 -> CPU 실행

### 1.2.2 각각의 토큰 추출하기
- 그래서 컴파일러가 어떻게 하는건데?
  - 먼저 각 항목을 잘게 쪼갠다 (소스 코드)
    - 키워드 -> int 키워드(Type)
    - 항목, 키워드 모두 토큰이다.
  - 항목의 추가 정보를 함께 묶어 관리
    - 변수명, 대입연산자, 값, ...
  - 소스 코드 내 모든 토큰을 찾아내는 작업 선행
    - 어휘 분석: 소스 코드 내 토큰 추출 과정

### 1.2.3 토큰이 표현하고자 하는 의미
- 컴파일러를 통해 소스 코드가 하나의 토큰으로 바뀐다.
- 토큰 의도 파악 필요!
- 컴파일러는 구문에 따라 토큰 처리 필요
  - while문 -> while 키워드에 필요한 토큰을 만날 때 까지 기다리고 처리하는 과정 반복
    - 이 과정을 해석(parsing)이라 한다.
- 컴파일러가 구문에 따라 해석해낸 구조 표현
  - 트리 방식, 트리로 생성하는 전체 과정 -> '구문 분석'이라 한다.

### 1.2.4 생성된 구문 트리에 이상은 없을까?
- 구문 트리 생성 후 이상 체크 필요
  - 숫자와 문자 연산 X
- 구문 분석 - 구문 이상 체크 -> 컴파일 오류 없음 증명 -> '의미 분석'이라 한다.

### 1.2.5 구문 트리를 기반으로 중간 코드 생성하기
- 컴파일러는 '의미 분석' 후 다듬어진 '중간 코드' 생성
  - 추가적인 최적화 과정이 있을 수도 있다.
    - 순환 구문 내 -> 관계 없이 계산 가능한 값을 순환 구문 외부에서 먼저 진행 될 수도 있다.

### 1.2.6 코드 생성
- 중간 코드를 어셈블리어 코드로 변환
- 어셈블리어 코드를 기계 명령어로 변환
- 이 단계가 끝난다고 소스 코드가 실행 파일이 되는 것은 아니다.
  - 컴파일된 여러 파일(대상 파일)들을 하나의 실행 파일로 합치는 것이 중요하다.
  - 대상 파일 병합 작업 -> 링크(link)
    - 링크 담당 프로그램 -> 링커(linker)
- 실제로 컴파일러는 매우 복잡하고 지능적이다. 간단하게 알아봤지만 간단하지 않다는 걸 인지해야 한다.

### 느낀점 및 정리
- 컴파일러는 직접적으로 사용하지 않더라도 개발 환경에서 계속 사용해왔다.
- 컴파일러는 큰 흐름에서 간단하다. 소스 코드 분석 -> 소스 코드 최적화 -> 중간 파일 생성 -> 대상 파일 병합 -> 하나의 실행 파일 생성
  - 디테일하게는 매우 복잡하고 지능적인 작업이 뒤에서 돌고 있다.
- 컴파일러가 복잡하다는 것을 인지해야하고, 그 과정에 링크(대상 파일 병합) 작업이 있다.
- 링크를 이해하는 것은 전반적인 SW를 탐색하는데 큰 기여를 한다.