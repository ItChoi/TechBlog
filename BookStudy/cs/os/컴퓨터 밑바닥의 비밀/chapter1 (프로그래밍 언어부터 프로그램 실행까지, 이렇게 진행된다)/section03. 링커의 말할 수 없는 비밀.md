# 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

## 1.3 링커의 말할 수 없는 비밀
- 바퀴를 다시 발명하지 마라(Don't reinvent the wheel)
  - 다른 훌륭한 프로그램이 있다면 가져와서 사용하면 된다.
    - 어떻게 가져와서 사용할지에 대한 고민은 필요하다.
      - 자신의 프로젝트에 코드를 가져와 사용하는 방법
- 링커를 이해하면 복잡한 SW 탐색 능력이 크게 향상된다.

### 1.3.1 링커는 이렇게 일한다
- 링커도 일반적은 프로그램에 불과하다 (컴파일러와 동일)
- 압축의 형태처럼 컴파일러가 생성한 여러 대상 파일들을 하나의 실행 파일로 합쳐주는 역할을 한다.
- 링크의 전체 과정은 하나의 기술 서적에서 여러 저자가 챕터 별로 따로 집필하고, 하나로 묶어 학 권으로 출판하는 것과 비슷하다.
  - A 저자의 특정 챕터에서 B 저자의 챕터 일부를 참고 해야 할 때가 있다.
    - 참조하는 외부 심볼(external symbol)은 단 하나만 있어야 한다.
      - 링커는 이를 찾아 연결하는 작업 수행 -> 심벌 해석(symbol resolution)
  - 완성된 책 한권 == 최종적으로 생성된 실행파일
  - 다른 저자의 챕터를 참조 할 때, 내용이 없다면 임시로 표시해야 한다. 이후 재배치 한다.
    - 즉 컴파일 시점에 메모리 주소 위치를 정확히 알 수 없다. 실행 파일을 생성 하는 과정에서 임시 주소를 실제 메모리 주소로 대체한다.

### 1.3.2 심벌 해석: 수요와 공급
- 심벌은 무엇일까?
  - 모든 변수의 이름을 의미한다.
    - 전역 변수, 함수, ...
- 링커를 통해 대상파일(기계어)에서 참조하는 외부 심벌이 단 하나만 존재하는지 확인한다.
- 지역 변수는 참조할 방법이 없기 때문에 링커가 관심을 두지 않는다.
- 컴파일러가 정보를 링커에게 전달한다.
  - 컴파일러는 기계어 생성 뿐만 아니라 기계어 명령어를 실행시키는 데이터도 생성한다.
    - 데이터는 대상 파일에 반드시 포함
    - 참조된 변수 정의를 찾는 일은 링커의 역할이다.
      - 컴파일러는 소스파일마다 외부 참조 가능 심벌과 외부 참조 심벌 정보를 심벌 테이블에 기록한다.
      - 심벌 테이블은 대상 파일에 저장 -> 코드, 데이터, 심벌 테이블 함꼐 저장

### 1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일
- 정적 라이브러리 기능 사용 -> 소스 파일을 미리 개별적으로 컴파일하고 링크해 정적 라이브러리 생성 가능
  - 소스 파일마다 단독 컴파일, 이후 실행시 재컴파일 없이 링크 과정에서 실행 파일 복제 (정적 링크)
  - 정적 링크로 실행 파일 생성시 코드, 데이터 영역의 본사본을 갖는다 -> 디스크, 메모리 낭비
  - 디스크 메모리 낭비를 동적 라이브러리, 공유 라이브러리 사용으로 해결 필요
- 동적 라이브러리 기능 사용 -> 참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함!
  - 실행 파일 크기를 줄이는데 유의미한 효과를 준다.
  - 동적 라이브러리 필수 정보는 실행 파일 내 저장된다.
  - 동적 링크 두 가지 방식
    1. 프로그램이 메모리에 적재 될 때 동적 링크 진행
    2. 프로그램 실행 후 실행 시간 동안 코드가 직접 동적 링크 실행

### 1.3.4 동적 라이브러리의 단점
- OS는 용도에 맞게 수 많은 프로그램들이 설치되어 있다.
  - 리눅스에 설치된 대부분 프로그램들은 대부분 C 표준 라이브러리 의존
    - 전부 정적 라이브러리 사용시 디스크 공간 낭비!!
      - 동적 라이브러리 사용은 좋은 해결책!
- 동적 라이브러리 장점
  - 동적 라이브러리 사용시 프로그램 개수와 별개로 동적 라이브러리 복사반 하나만 디스크에 저장된다.
  - 동적 라이브러리는 코드 수정이 발생해도 동적 라이브러리만 재컴파일 하면 된다!
  - 동적 링크 특성을 사용해 프로그램 기능 쉽게 확장 가능!
    - 플러그인
      - 동적 라이브러리 방식에 따라 플러그인 적재하여 프로그램이 사용 가능하도록 한다.
  - 여러 언어 혼합 개발시 매우 유용
    - 파이썬은 개발 속도를 빠르게 해주지만 성능은 C/C++에 미치지 못한다.
      - 높은 성능 요하는 부분만 C/C++로 개발 가능! -> 컴파일 후 동적 라이브러리 생성
- 동적 라이브러리 단점
  - 프로그램 적재 시간과 실행 시간에 링크 된다. -> 정적 링크보다 성능이 떨어진다.
  - 특정 메모리 주소와 독립적으로 동작 -> 위치 독립 코드
- 리눅스 ldd 명령어를 통해 실행 파일이 어떤 동적 라이브러리에 의존하는지 확인 가능

### 1.3.5 재배치: 심벌의 실행 시 주소 결정하기
- 컴파일러가 메모리 주소 확정 할 수 없는 변수는?
  - .relo.text에 해당 명령어 저장!
  - .relo.data에 명령어 관련 데이터 저장!
- 심벌의 메모리 주소를 수정하는 과정 -> 재배치
- 링커는 프로그램 실행 후 변수, 기계 명령어 등의 메모리 주소를 어떻게 알 수 있을까?
  - 프로그램은 실행마다 메모리 주소가 변경된다.
    - 가상 메모리 활용

### 1.3.6 가상 메모리와 프로그램 메모리 구조
- 영역이 실제로 의미하는 바가 무엇일까?
  - 스택 영역: 메모리의 상위 주소에 존재한다.
  - 힙 영역: malloc 함수를 통해 힙 영역에서 메모리를 할당 받는다.
  - 데이터 & 코드 영역: 실행 파일의 내용이 메모리에 적재되는 곳
- 흥미로운 영역은 코드 영역이 시작되는 위치다.
  - 모든 프로그램은 실행 후 코드 영역이 예외 없이 메모리 주소 0x400000에서 시작한다.
    - 프로그램간 데이터가 서로 동일하지 않다.
      - OS의 가상 메모리 기술을 통해 가능하다.
- 가상 메모리
  - 논리적인 메모리 공간
  - 데이터와 명령어는 결국 물리 메모리에 저장돼야 한다.
    - CPU -> 프로그램 A 접근 -> 메모리 주소 0x400000 접근시 실제 명령어 꺼내는 메모리 주소는?
      - 매핑 관계를 표현한 페이지 테이블 참조 -> 가상메모리(0x400000) - 물리메모리(0x80ef0000)
- 모든 프로세스는 페이지 테이블을 갖고 있다.
  - 가상 메모리의 기본 원리

### 느낀점 및 정리
- 컴파일러를 통해 소스 코드를 기계어로 만든다.
- 링커를 통해 여러 기계어 파일들을 병합한다.
- 컴파일러가 남기는 임시 메모리 주소를 링커를 통해 실제 메모리 주소로 변환한다.
- 컴파일러는 실제 메모리 주소를 알 수 없는 경우 특정 파일에 해당 명령어와 정보를 기록한다.
- 링커는 가상메모리를 활용해 실제 메모리 주소를 알 수 있다.
- 프로세스는 독립적인 페이지 테이블을 갖고 있고, 가상 메모리 주소와 실제 메모리 주소를 매핑하는 테이블이다.