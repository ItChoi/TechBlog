[도커 교과서 - 실습 코드](https://github.com/gilbutITbook/080258)

# 1장 시작하기 전에
도커는 컨테이너라는 경량 단위로 서비스 실행 기능을 제공한다.
컨테이너를 생성하기 위해서는 도커 이미지를 가지고 있어야 한다.

컨테이너는 도커 뿐만 아니라 거의 모든 분야에 자리 잡고 있다.
따라서 반드시 익혀야할 핵심 기술이다.

컨테이너가 실무에서 어떻게 활용되고 문제 활용에 도움이 되는지 이해하는 것이 중요하다.

## 1.1 컨테이너가 IT 세상을 점령한 이유

### 1.1.1 클라우드 환경으로 이주하기
서버, 스토리지, 네트워크, 전원 등을 GCP, 애져, AWS에 맡길 수 있다.
전 세계에 존재하는 IDC에 우리 서비스를 실행하게 할 수 있고, 빠르고 쉽게 앱을 배포하고 확장성과 사용한 만큼 금액을 지불할 수 있다.

기존에 클라우드 환경 이주를 위해선 IaaS(서비스로서의 인터넷) 또는 PasS(서비스로서의 플랫폼) 두 가지 선택지가 있었다.
PaaS는 애플리케이션이 특정 클라우드에 종속되지만 운영비를 절약한다.
IaaS는 클라우드에 종속되진 않지만, 운영비가 상승한다.

도커는 단점이 없는 하나의 선택지가 됐다.
애플리케이션의 각 컴포넌트를 컨테이너로 이주 시키고, IDC 서비스 또는 직접 구축한 도커 클러스터에서 전체 앱을 실행할 수 있다.

도커화된 애플리케이션은 이식성이 뛰어나다.
IDC 서비스(AWS, GCP, ...)로도 별도 수정 없이 이주할 수 있다.

애플리케이션을 컨테이너로 이주시킬 때 비용이 소모된다.
기존 설치 절차를 Dockerfile을 이용해 스크립트로 작성
배포 관련 사항 역시 도커 컴포즈 또는 쿠버네티스를 사용해 애플리케이션 매니페스트로 재작성해야 한다.

### 1.1.2 레거시 애플리케이션 현대화하기
컨테이너 활용한 모든 앱은 클라우드에서 실행할 수 있다.
그러나 모놀리틱 설계로 방치시 클라우드의 진가를 발휘할 수 없다.

따라서 도커로 이주하는 과정은 앱의 낡은 설계 방식을 바꿀 수 있는 첫 걸음이다.

### 1.1.3 클라우드 환경에 적합한 새로운 애플리케이션 개발하기
도커를 통해 애플리케이션을 이주하는 것은 아주 유용하다.
도커 컴포넌트는 공통적으로 Dockerfile을 통해 패키징, 도커 컴포즈 파일 형태로 전체 애플리케이션 정의
분산 애플리케이션의 빌드, 실행할 때 별도의 개발 도구없이 도커 설치, 소스코드 저장소 복제 후 한 번의 명령으로 코드 빌디 후 전체 앱 사용 가능
서드파티 소프트웨어 도입시에도 도커 사용이 유용하다.

### 1.1.4 기술 혁신:서버리스와 그 너머
모든 프로젝트를 일관된 도구, 프로세스, 런타임을 사용하기를 원한다. -> 도커 이용하면 가능 -> 도커 클러스터 구축
도커 클러스터는 클라우드와 데이터센터 어디든 원하는 곳에서 운영 가능

서버리스 기술은 곧 컨테이너 기술이다.
개발자 코드 작성 -> 서비스에 푸시 -> 서비스 내에서 코드 빌드, 패키징, ...
모든 일은 플랫폼이 처리한다.

### 1.1.5 데브옵스 도입하기

## 1.2 대상 독자

## 1.3 실습 환경 구축하기

### 1.3.4 실습 환경 초기화 명령
도커에는 컨테이너, 애플리케이션 자동 정리 기능은 없다.
도커 데스크탑 종료시 모든 컨테이너가 종료된다.

실습 환경 초기화 명령어 
- docker container rm -f $(docker container ls -aq)
- docker image rm -f $(docker image ls -f reference='diamol/*' -q)
  - 내려받은 이미지가 차지한 디스크 용량 모두 회수 명령어

## 1.4 바로 활용하기

# 2장 도커의 기본적인 사용법
도커를 실제 사용해보자.

## 2.1 컨테이너로 Hello World 실행하기
도커에서 컨테이너로 'Hello World' 메시지 출력 애플리케이션 실행해보기.

실습) 다음 명령을 실행하면 Hello World 컨테이너가 실행된다.
- docker container run diamol/ch02-hello-diamol
  - 이미지를 내려 받는다 -> 이미지를 통해 컨테이너 생성 -> 컨테이너 실행 
  - 패키지를 통해 컨테이너 실행 후 애플리케이션이 출력한 내용
  - diamol/ch02-hello-diamol -> 미리 도커로 누군가가 실행 가능하도록 패키징(이미지)
    - 예를 들어 diamol/ch02-hello-diamol12312312112로 변경한다면, 도커 레지스트리에 등록된 이미지가 존재하지 않아 에러 발생

간단하지만, 애플리케이션을 컨테이너에서 실행 가능하도록 패키징, 패키지 공유, 패키지를 내려 받고 컨테이너를 생성해 애플리케이션 실행해봤다.
도커에서는 이 과정을 빌드, 공유, 실행이라 한다.
아무리 복잡한 앱도 모두 이 과정을 거친다.

- docker container run diamol/ch02-hello-diamol
  - 두 번 명령어를 실행시, 이미지를 내려 받진 않는다. 
  - 그러나 새로운 컨테이너가 생성되어 출력된다.

## 2.2 컨테이너란 무엇인가?
도커 컨테이너 안에는 앱, 앱을 실행할 컴퓨터 정보(IP, 호스트명, 디스크 드라이브, ...) 등이 들어있다.
IP, 호스트명, 디스크 드라이브는 모두 도커가 만들어낸 가상 리소스다.
가상 리소스들이 묶여 앱 동작 환경이 만들어진다.

컨테이너 안에서 바깥 환경을 볼 순 없지만, 다른 컨테이너 여러 개 실행 가능하다.
서로 독립적인 컨테이너지만, 컨테이너들은 호스트의 컴퓨터의 CPU, 운영체제, 메모리를 공유한다.
이런 구도가 중요한 이유는 격리와 밀집 두 조건을 동시에 만족할 수 있다. (그림 참고) -> 가상 머신은 두 조건을 충족 못한다. 
밀집: 컴퓨터 CPU, 메모리가 허용하는 범위에서 많은 애플리케이션 실행 가능한 것

## 2.3 컨테이너를 원격 컴퓨터처럼 사용하기
도커를 사용해 스크립트를 동작하고, 스크립트 동작에 필요한 빌드나 도구 등이 필요하면 그것도 도커로 패키징해서 활용해 사용하면 된다.

실습)
- docker container run --interactive --tty diamol/base
  - --interactive: 컨테이너 접속 상태 유지
  - --tty: 터미널 세션을 통해 컨테이너 조작
  - hostname
  - date

원격 컴퓨터로 접속한것 마냥 로컬 터미널이 열려있고 명령어를 입력 가능하다.

도커 자체는 호스트 컴퓨터의 아키텍처, 운영체제와 상관없이 동작하지만,
컨테이너 안 애플리케이션이 상관 있을 수 있다.

실습)
- docker container ls
  - 현재 실행중 모든 컨테이너 리스트 출력
  - 컨테이너 아이디와 컨테이너 내부 호스트명과 동일
    - 무작위로 컨테이너 아이디가 생성되고, 그 중 앞에 일부가 호스트명이 된다.
    - 컨테이너 지정시에도 앞에 몇글자만 입력해도 된다.
- docker container top f1
  - 대상 컨테이너에서 실행 중인 프로세스 목록
  - f1 -> 컨테이너 Id 일부
- docker container logs f1
  - 대상 컨테이너에서 수집된 모든 로그 출
  - f1 -> 컨테이너 Id 일부
- docker container inspect f1
  - 대상 컨테이너의 상세 정보
  - f1 -> 컨테이너 Id 일부
  - 컨테이너를 다루거나 앱에서 일어난 문제 해결을 위해서 일상적으로 사용된다. 

## 2.4 컨테이너를 사용해 웹 사이트 호스팅하기
실습)
- docker container ls --all
  - 모든 컨테이너 목록 조회

컨테이너 상태 Existed!
- 컨테이너 내부 애플리케이션이 실행중이어야 컨테이너의 상태도 실행중이 된다.
- 애플리케이션 프로세스 종료 -> 컨테이너 상태 Existed
- 종료된 컨테이너는 CPU, 메모리 사용하지 않는다.

컨테이너는 종료돼도 사라지지 않는다.
- 컨테이너 파일 시스템이 그대로 남아, 호스트 컴퓨터의 디스크 공간 계속 점유

실습)
- docker container run --detach --publish 8080:80 diamol/ch02-hello-diamol-web
  - 컨테이너가 백그라운드 동작하면서, 네트워크 주시
  - --detach: 컨테이너 백그라운드 실행, 컨테이너 ID 출력
  - --public: 컨테이너 포트를 호스트 컴퓨터에 공개
- docker container ls
  - 방금 실행한 컨테이너가 up 상태임을 확인 가능
  
컨테이너 포트를 호스트 컴퓨터에 공개하는 원리는 복잡한데, 
도커 이용시 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 된다.
따라서 네트워크 트래픽을 모두 도커가 가로채서 필요한 컨테이너에 전달 가능하다.

컨테이너는 기본적으로 외부 환경에 노출되지 않는다. 
각 컨테이너는 고유 IP 주소를 갖는다. -> 물리 네트워크에 연결된 것은 아니고, 가상 네트워크 주소
컨테이너 포트 공개 -> 도커가 호스트 컴퓨터의 포트 주시, 해당 포트를 컨테이너에 전달해준다.

예를 들어 내 컴퓨터가 도커 실행 호스트 컴퓨터가 되고, 물리 IP가 있다.
내 컴퓨터에서 한 개의 컨테이너가 실행중이라고 가정했을 때, 
이 컨테이너도 가상의 고유 논리 IP가 있다. (도커가 부여한 가상 네트워크 주소)

호스트에서 컨테이너 IP로 접근할 수 없다. 
왜냐하면 도커 내부에만 존재하는 가상 고유 논리 IP다.
그러나 --publish로 컨테이너 포트가 공개됐으므로 호스트 컴퓨터로 오는 트래픽을 컨테이너로 전달 가능하다.

도커의 이식성과 효율성을 누릴 수 있다.
컴퓨터로 도커 컨테이너 하나만 실행하면, 너무나 간단하고 빠르게 애플리케이션을 실행된다.

실습)
- docker container stats
  - 실시간으로 컨테이너 상태 확인 가능
    - CPU, 메모리, 네트워크, 디스크

실습)
- docker container rm --force $(docker container ls --all --quiet)
  - --force를 통해 실행중인 컨테이너도 삭제
  - 모든 컨테이너가 삭제된다.
  - $() 문법은 괄호 안 명령의 출력을 다른 명령으로 전달

## 2.5 도커가 컨테이너를 실행하는 원리
빌드 -> 공유 -> 실행은 도커의 핵심 워크플로우다.
도커 설치와 컨테이너 실행은 매우 간단하다.
- 도커 엔진 기능 접근하려면 도커 API를 통해야 한다.
- 도커 엔진은 백그라운드로 동작하면서 컨테이너와 이미지를 관리한다.
- 도커 이미지는 로컬에 보관된다.

도커엔진
- 도커의 관리 기능을 맡는 컴포넌트
- 로컬 이미지 캐시 담당 - 이미지가 이미 있으면 사용, 새로운 이미지가 필요할 경우 내려받는다.
- 도커 리소스 생성 담당 (호스트 운영체제와 함께 가상 네트워크 등)
- 백그라운드 프로세스다.
- 도커 API를 통해 맡은 기능 수행
  - 도커 API는 표준 HTTP 기반 REST API
- containerd라는 컴포넌트를 통해 컨테이너를 실제 관리 

도커 명령행 인터페이스 (Docker command-line interface)
- 도커 API 클라이언트
  - 실제 api를 호출한다.

/usr/local/apache2/htdocs

## 2.6 연습 문제: 컨테이너 파일 시스템 다루기



# 3장 도커 이미지 만들기

# 4장 애플리케이션 소스 코드에서 도커 이미지까지

# 5장 도커 허브 등 레지스트리에 이미지 공유하기

# 6장 도커 볼륨을 이용한 퍼시스턴트 스토리지
