[도커 교과서 - 실습 코드](https://github.com/gilbutITbook/080258)

# 1장 시작하기 전에
도커는 컨테이너라는 경량 단위로 서비스 실행 기능을 제공한다.
컨테이너를 생성하기 위해서는 도커 이미지를 가지고 있어야 한다.

컨테이너는 도커 뿐만 아니라 거의 모든 분야에 자리 잡고 있다.
따라서 반드시 익혀야할 핵심 기술이다.

컨테이너가 실무에서 어떻게 활용되고 문제 활용에 도움이 되는지 이해하는 것이 중요하다.

## 1.1 컨테이너가 IT 세상을 점령한 이유

### 1.1.1 클라우드 환경으로 이주하기
서버, 스토리지, 네트워크, 전원 등을 GCP, 애져, AWS에 맡길 수 있다.
전 세계에 존재하는 IDC에 우리 서비스를 실행하게 할 수 있고, 빠르고 쉽게 앱을 배포하고 확장성과 사용한 만큼 금액을 지불할 수 있다.

기존에 클라우드 환경 이주를 위해선 IaaS(서비스로서의 인터넷) 또는 PasS(서비스로서의 플랫폼) 두 가지 선택지가 있었다.
PaaS는 애플리케이션이 특정 클라우드에 종속되지만 운영비를 절약한다.
IaaS는 클라우드에 종속되진 않지만, 운영비가 상승한다.

도커는 단점이 없는 하나의 선택지가 됐다.
애플리케이션의 각 컴포넌트를 컨테이너로 이주 시키고, IDC 서비스 또는 직접 구축한 도커 클러스터에서 전체 앱을 실행할 수 있다.

도커화된 애플리케이션은 이식성이 뛰어나다.
IDC 서비스(AWS, GCP, ...)로도 별도 수정 없이 이주할 수 있다.

애플리케이션을 컨테이너로 이주시킬 때 비용이 소모된다.
기존 설치 절차를 Dockerfile을 이용해 스크립트로 작성
배포 관련 사항 역시 도커 컴포즈 또는 쿠버네티스를 사용해 애플리케이션 매니페스트로 재작성해야 한다.

### 1.1.2 레거시 애플리케이션 현대화하기
컨테이너 활용한 모든 앱은 클라우드에서 실행할 수 있다.
그러나 모놀리틱 설계로 방치시 클라우드의 진가를 발휘할 수 없다.

따라서 도커로 이주하는 과정은 앱의 낡은 설계 방식을 바꿀 수 있는 첫 걸음이다.

### 1.1.3 클라우드 환경에 적합한 새로운 애플리케이션 개발하기
도커를 통해 애플리케이션을 이주하는 것은 아주 유용하다.
도커 컴포넌트는 공통적으로 Dockerfile을 통해 패키징, 도커 컴포즈 파일 형태로 전체 애플리케이션 정의
분산 애플리케이션의 빌드, 실행할 때 별도의 개발 도구없이 도커 설치, 소스코드 저장소 복제 후 한 번의 명령으로 코드 빌디 후 전체 앱 사용 가능
서드파티 소프트웨어 도입시에도 도커 사용이 유용하다.

### 1.1.4 기술 혁신:서버리스와 그 너머
모든 프로젝트를 일관된 도구, 프로세스, 런타임을 사용하기를 원한다. -> 도커 이용하면 가능 -> 도커 클러스터 구축
도커 클러스터는 클라우드와 데이터센터 어디든 원하는 곳에서 운영 가능

서버리스 기술은 곧 컨테이너 기술이다.
개발자 코드 작성 -> 서비스에 푸시 -> 서비스 내에서 코드 빌드, 패키징, ...
모든 일은 플랫폼이 처리한다.

### 1.1.5 데브옵스 도입하기

## 1.2 대상 독자

## 1.3 실습 환경 구축하기

### 1.3.4 실습 환경 초기화 명령
도커에는 컨테이너, 애플리케이션 자동 정리 기능은 없다.
도커 데스크탑 종료시 모든 컨테이너가 종료된다.

실습 환경 초기화 명령어 
- docker container rm -f $(docker container ls -aq)
- docker image rm -f $(docker image ls -f reference='diamol/*' -q)
  - 내려받은 이미지가 차지한 디스크 용량 모두 회수 명령어

## 1.4 바로 활용하기

# 2장 도커의 기본적인 사용법
도커를 실제 사용해보자.

## 2.1 컨테이너로 Hello World 실행하기
도커에서 컨테이너로 'Hello World' 메시지 출력 애플리케이션 실행해보기.

실습) 다음 명령을 실행하면 Hello World 컨테이너가 실행된다.
- docker container run diamol/ch02-hello-diamol
  - 이미지를 내려 받는다 -> 이미지를 통해 컨테이너 생성 -> 컨테이너 실행 
  - 패키지를 통해 컨테이너 실행 후 애플리케이션이 출력한 내용
  - diamol/ch02-hello-diamol -> 미리 도커로 누군가가 실행 가능하도록 패키징(이미지)
    - 예를 들어 diamol/ch02-hello-diamol12312312112로 변경한다면, 도커 레지스트리에 등록된 이미지가 존재하지 않아 에러 발생

간단하지만, 애플리케이션을 컨테이너에서 실행 가능하도록 패키징, 패키지 공유, 패키지를 내려 받고 컨테이너를 생성해 애플리케이션 실행해봤다.
도커에서는 이 과정을 빌드, 공유, 실행이라 한다.
아무리 복잡한 앱도 모두 이 과정을 거친다.

- docker container run diamol/ch02-hello-diamol
  - 두 번 명령어를 실행시, 이미지를 내려 받진 않는다. 
  - 그러나 새로운 컨테이너가 생성되어 출력된다.

## 2.2 컨테이너란 무엇인가?
도커 컨테이너 안에는 앱, 앱을 실행할 컴퓨터 정보(IP, 호스트명, 디스크 드라이브, ...) 등이 들어있다.
IP, 호스트명, 디스크 드라이브는 모두 도커가 만들어낸 가상 리소스다.
가상 리소스들이 묶여 앱 동작 환경이 만들어진다.

컨테이너 안에서 바깥 환경을 볼 순 없지만, 다른 컨테이너 여러 개 실행 가능하다.
서로 독립적인 컨테이너지만, 컨테이너들은 호스트의 컴퓨터의 CPU, 운영체제, 메모리를 공유한다.
이런 구도가 중요한 이유는 격리와 밀집 두 조건을 동시에 만족할 수 있다. (그림 참고) -> 가상 머신은 두 조건을 충족 못한다. 
밀집: 컴퓨터 CPU, 메모리가 허용하는 범위에서 많은 애플리케이션 실행 가능한 것

## 2.3 컨테이너를 원격 컴퓨터처럼 사용하기
도커를 사용해 스크립트를 동작하고, 스크립트 동작에 필요한 빌드나 도구 등이 필요하면 그것도 도커로 패키징해서 활용해 사용하면 된다.

실습)
- docker container run --interactive --tty diamol/base
  - --interactive: 컨테이너 접속 상태 유지
  - --tty: 터미널 세션을 통해 컨테이너 조작
  - hostname
  - date

원격 컴퓨터로 접속한것 마냥 로컬 터미널이 열려있고 명령어를 입력 가능하다.

도커 자체는 호스트 컴퓨터의 아키텍처, 운영체제와 상관없이 동작하지만,
컨테이너 안 애플리케이션이 상관 있을 수 있다.

실습)
- docker container ls
  - 현재 실행중 모든 컨테이너 리스트 출력
  - 컨테이너 아이디와 컨테이너 내부 호스트명과 동일
    - 무작위로 컨테이너 아이디가 생성되고, 그 중 앞에 일부가 호스트명이 된다.
    - 컨테이너 지정시에도 앞에 몇글자만 입력해도 된다.
- docker container top f1
  - 대상 컨테이너에서 실행 중인 프로세스 목록
  - f1 -> 컨테이너 Id 일부
- docker container logs f1
  - 대상 컨테이너에서 수집된 모든 로그 출
  - f1 -> 컨테이너 Id 일부
- docker container inspect f1
  - 대상 컨테이너의 상세 정보
  - f1 -> 컨테이너 Id 일부
  - 컨테이너를 다루거나 앱에서 일어난 문제 해결을 위해서 일상적으로 사용된다. 

## 2.4 컨테이너를 사용해 웹 사이트 호스팅하기
실습)
- docker container ls --all
  - 모든 컨테이너 목록 조회

컨테이너 상태 Existed!
- 컨테이너 내부 애플리케이션이 실행중이어야 컨테이너의 상태도 실행중이 된다.
- 애플리케이션 프로세스 종료 -> 컨테이너 상태 Existed
- 종료된 컨테이너는 CPU, 메모리 사용하지 않는다.

컨테이너는 종료돼도 사라지지 않는다.
- 컨테이너 파일 시스템이 그대로 남아, 호스트 컴퓨터의 디스크 공간 계속 점유

실습)
- docker container run --detach --publish 8080:80 diamol/ch02-hello-diamol-web
  - 컨테이너가 백그라운드 동작하면서, 네트워크 주시
  - --detach: 컨테이너 백그라운드 실행, 컨테이너 ID 출력
  - --public: 컨테이너 포트를 호스트 컴퓨터에 공개
- docker container ls
  - 방금 실행한 컨테이너가 up 상태임을 확인 가능
  
컨테이너 포트를 호스트 컴퓨터에 공개하는 원리는 복잡한데, 
도커 이용시 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 된다.
따라서 네트워크 트래픽을 모두 도커가 가로채서 필요한 컨테이너에 전달 가능하다.

컨테이너는 기본적으로 외부 환경에 노출되지 않는다. 
각 컨테이너는 고유 IP 주소를 갖는다. -> 물리 네트워크에 연결된 것은 아니고, 가상 네트워크 주소
컨테이너 포트 공개 -> 도커가 호스트 컴퓨터의 포트 주시, 해당 포트를 컨테이너에 전달해준다.

예를 들어 내 컴퓨터가 도커 실행 호스트 컴퓨터가 되고, 물리 IP가 있다.
내 컴퓨터에서 한 개의 컨테이너가 실행중이라고 가정했을 때, 
이 컨테이너도 가상의 고유 논리 IP가 있다. (도커가 부여한 가상 네트워크 주소)

호스트에서 컨테이너 IP로 접근할 수 없다. 
왜냐하면 도커 내부에만 존재하는 가상 고유 논리 IP다.
그러나 --publish로 컨테이너 포트가 공개됐으므로 호스트 컴퓨터로 오는 트래픽을 컨테이너로 전달 가능하다.

도커의 이식성과 효율성을 누릴 수 있다.
컴퓨터로 도커 컨테이너 하나만 실행하면, 너무나 간단하고 빠르게 애플리케이션을 실행된다.

실습)
- docker container stats
  - 실시간으로 컨테이너 상태 확인 가능
    - CPU, 메모리, 네트워크, 디스크

실습)
- docker container rm --force $(docker container ls --all --quiet)
  - --force를 통해 실행중인 컨테이너도 삭제
  - 모든 컨테이너가 삭제된다.
  - $() 문법은 괄호 안 명령의 출력을 다른 명령으로 전달

## 2.5 도커가 컨테이너를 실행하는 원리
빌드 -> 공유 -> 실행은 도커의 핵심 워크플로우다.
도커 설치와 컨테이너 실행은 매우 간단하다.
- 도커 엔진 기능 접근하려면 도커 API를 통해야 한다.
- 도커 엔진은 백그라운드로 동작하면서 컨테이너와 이미지를 관리한다.
- 도커 이미지는 로컬에 보관된다.

도커엔진
- 도커의 관리 기능을 맡는 컴포넌트
- 로컬 이미지 캐시 담당 - 이미지가 이미 있으면 사용, 새로운 이미지가 필요할 경우 내려받는다.
- 도커 리소스 생성 담당 (호스트 운영체제와 함께 가상 네트워크 등)
- 백그라운드 프로세스다.
- 도커 API를 통해 맡은 기능 수행
  - 도커 API는 표준 HTTP 기반 REST API
- containerd라는 컴포넌트를 통해 컨테이너를 실제 관리 

도커 명령행 인터페이스 (Docker command-line interface)
- 도커 API 클라이언트
  - 실제 api를 호출한다.

/usr/local/apache2/htdocs

## 2.6 연습 문제: 컨테이너 파일 시스템 다루기
- docker container run -d -p 8080:80 diamol/ch02-hello-diamol-web
- docker container exec 컨테이너ID ls /usr/local/apache2/htdocs
- docker container cp ./index.html 컨테이너ID:/usr/local/apache2/htdocs/index.html

# 3장 도커 이미지 만들기

## 3.1 도커 허브에 공유된 이미지 사용하기
- 실습 예제를 우선 완성본 살펴본다. 
  - web-ping
    - 지정 웹 사이트 노출 확인 기능
    - 컨테이너에서 실행, 지정된 URL에 HTTP 요청 3초마다 보낸다.
    - 네트워크를 통한 요청 없음, 포트를 외부에 공개 할 필요 없다.

- docker container run 명령을 통해 로컬에 이미지가 없으면 내려받는다.
  - 소프트웨어 배포 기능이 도커 플랫폼에 완전히 내장됐기 때문에 가능

- docker image pull disamol/ch03-web-ping
  - 하나의 이미지를 pull 받는데, 여러 이미지를 같이 pull 받아진다.
    - 단일 파일을 받는 것이 아니라, 여러 파일을 내려받는다.
  - 로컬에 diamol/ch03-web-ping 이미지가 없다면, 도커 허브에 저장된 이미지를 받는다.

도커 이미지는 물리적으로 여러 개의 작은 파일로 구성돼 있다.
도커를 통해 파일이 조립되고 컨테이너의 내부 파일 시스템을 만든다.

- docker container run -d --name web-ping diamol/ch03-web-ping
  - 다운 받은 이미지로 도커 컨테이너 실행 (run을 사용하기에 이미지가 없어도 도커 허브에서 다운 받아서 실행된다.)
  - --name을 통해 컨테이너에 원하는 이름 지정 가능

- docker container logs web-ping
  - ping을 지속적으로 보내고 있는걸 확인할 수 있다.
  - 내부 세팅은 blog.sixeyed.com 

환경 변수는 운영체제에서 제공하는 키-값 쌍이다.
도커 컨테이너는 별도의 환경 변수를 가질 수 있다.
환경 변수는 호스트 운영체제의 것을 가져오는 것이 아니라 도커가 부여하는 것이다.

환경 변수 값 변경시 애플리케이션 동작 내용도 바뀐다.
- docker rm -f web-ping
- docker container run --env TARGET=google.com dialog/ch03-web-ping

도커 이미지는 설정 값의 기본 값을 포함해 패키징하지만, 컨테이너 실행시 이 값을 바꿀 수 있어야 한다.

호스트 컴퓨터에 고유의 환경 변수가 있고, 이는 컨테이너와는 별개다.
컨테이너는 도커가 부여한 환경 변수만 갖는다.

같은 이미지를 사용하면서도 환경 변수 설정 값에 의해 동작이 달라지는 것을 살펴봤다.
- ping 대상 URL을 변경, TAGET=google.com

즉 도커 실행시 환경변수로 받은 값을 통해, 도커 이미지의 환경 변수 기본 값을 변겅해서 사용했다.
- 환경 변수 기본값도 커스텀하게 설정 가능하다.

## 3.2 Dockerfile 작성하기
- 애플리케이션 패키징을 위한 간단한 스크립트
- 일련의 인스트럭션으로 구성, 인스트럭션 실행 결과 -> 도커 이미지 생성
- 문법은 익히기 쉽고 매우 유연하다.
- 직접 작성하거나, 표준 쉘 문법 사용 가능(bash shell, ...)

3.1의 web-ping에 해당하는 Dockerfile
```dockerfile
FROM diamol/node

ENV TARGET="blog.sixeyed.com"
ENV METHOD="HEAD"
ENV INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .

CMD ["node", "/web-ping/app.js"]
```

FROM, EVN, WORKDIR, COPY, CMD, ... 등등 소문자로 써도 무방하다.

FROM: 모든 이미지는 다른 이미지로부터 출발한다. 해당 이미지에 Node가 설치돼 있다.
ENV: 환경 변수 값 지정, [KEY]=[VALUE] 형식
WORKDIR: 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉토리를 작업 디렉토리로 지정 
COPY: 로컬 파일 또는 디렉토리를 이미지로 복사한다. [원본경로] [복사경로] 형식
CMD: 도커 이미지로 컨테이너 실행 시점에 실행 명령어 지정 

## 3.3 컨테이너 이미지 빌드하기
도커 이미지 빌드 할 때 필요한 것
1. Dockerfile 스크립트
2. 이미지 이름
3. 패키징에 필요한 파일 경로
- docker image build --tag -web-ping ./
  - --tag: 인자값 -> 이미지 이름, 새로 빌드되는 이미지 이름
  - ./: 이미지에 포함시킬 파일 위치 경로 (Dockerfile 등이 들어있다.)
  
도커 build시 오류 발생시
1. 도커 엔진 정상 동작 확인, 도커 데스크탑의 상태 체크
2. 현재 작업 디렉토리 경로 체크
3. 빌드 명령어 정확 입력 체크
   - 도커 빌드 컨텍스트 정보 필요, 경로 필수 입력

빌드 성공 이미지 -> 로컬 이미지 캐시 저장
- docker image ls 'w*'
  - w로 시작하는 태그명 가진 이미지 목록 확인

- docker container run -e TARGET=docker.com -e INTERVAL=5000 web-ping

## 3.4 도커 이미지와 이미지 레이어 이해하기
도커 이미지 안에 패키징에 포함시킨 모든 파일과 여러 메타데이터 정보가 들어있다.
포함된 파일들을 통해 컨테이너의 파일 시스템을 형성하고, 메타데이터 안에는 이미지가 어떻게 빌드됐는지에 대한 간단 이력도 포함된다.

- docker image history web-ping
  - 이미지 히스토리 확인하기

Dockerfile 인스트럭션과 이미지 레이어는 1:1 관게다.
도커 이미지는 이미지 레이어가 모인 논리적 대상이다.
레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일이다.

이미지 레이어는 여러 이미지와 컨테이너에서 공유된다는 점에서 중요하다.
Node.js 앱이 실행되는 여러 컨테이너는 Node.js 런타임이 들어 있는 이미지 레이어를 공유한다.

docker image ls 명령어를 통해 나온 SIZE는 디스크 용량을 모두 점유하는 것 같지만,
이미지의 논리적 용량으로 공유된 레이어의 용량이 반영되지 않았다. 
즉 물리적 용량이 아니고, 실제 용량은 훨씬 덜 차지한다.
이미지 목록에서는 물리적 용량을 확인할 수 없다.
docker system df를 통해 이미지 레이어를 저장하는데 실제 사용된 디스크 용량 확인 가능

중요한 것은 이미지 레이어를 여러 이미지가 공유한다면, 수정할 수 없어야 한다.
도커는 이미지 레이어를 읽기 전용으로 만들어 수정을 방지한다.
즉 이미지 빌드시 이미지 레이어가 생성되면 재사용은 되지만 수정은 불가능

## 3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화
이미지 안에 자바스크립트 파일이 있다고 헀을 대, 이 파일을 수정하고 이미지를 다시 빌드하면,
새로운 이미지 레이어가 생긴다.

Dockerfile 스크립트의 인스트럭션은 각각 하나의 이미지 레이어와 1:1로 연결된다.
인스트럭션 결과가 같다면 이전 캐시된 레이어 재사용하고, 변경된 시점 이후부터 재실행된다.

도커는 캐시된 레이어 체크를 위해 해시 값을 이용한다.
해시 값은 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 계산된다.
내용으로부터 계산된 값이 캐시미스라면, 이후에는 변경이 없어도 모두 실행된다.

이런 이유로 Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 와야 한다.
수정 빈도가 높을수록 뒤에 두자.
캐싱된 이미지 레이어를 사용할수록 시간, 디스크 용량, 네트워크 대역폭 모두 절약할 수 있다.

참고로 CMD 인스트럭션은 FROM 뒤라면 어디든 배치 가능하다. 특히 수정 할 일이 없기에 초반부에 배치하자.
ENV 인스트럭션도 세 번을 사용할 수 있지만, 개행(\)을 기준으로 하나로 같이 사용해도 된다.

Dockerfile 최적화, 이식성 있는 이미지 생성하자.

## 3.6 연습 문제
- Dockerfile 없이 이미지 생성
- 이미지: diamol/ch03-lab
- 명령어 이용: export, (update?, restart?), attach?

- docker container run -it --name ch03-lab diamol/ch03-lab
- docker container commit ch03-lab new-image
- docker container run new-image cat ch03.txt

# 4장 애플리케이션 소스 코드에서 도커 이미지까지

# 5장 도커 허브 등 레지스트리에 이미지 공유하기

# 6장 도커 볼륨을 이용한 퍼시스턴트 스토리지
