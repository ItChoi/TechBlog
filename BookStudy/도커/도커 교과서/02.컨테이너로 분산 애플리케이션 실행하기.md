앱은 대게 여러 요소로 분할 돼 구성된다.

# 7장 도커 컴포즈로 분산 애플리케이션 실행하기
도커는 n-티어 모놀리식 설계부터 MSA 설계까지 분산 컴포넌트 관리에 이상적이다.

## 7.1 도커 컴포즈 파일의 구조
Dockerfile 스크립트는 애플리케이션을 패키징을 위한 스크립트다.
Dockerfile 스크립트 = App Packaging 스크립트

분산 앱은 단지 한 부분을 패키징하는 수단으로 보면 된다.
백 / 프론트로 나뉜 경우 두 개의 도커 파일이 필요하다.
백엔드가 MSA로 여러 도메인으로 분할 관리하는 경우, 다시 n개만큼 도커 파일이 필요하다.

직접 순서대로 여러 도커파일을 수동으로 옵션을 지정해 실행 할 수 있지만,
실수 가능성이 높아진다. 심지어 앱 동작의 문제가 생길 수 있다.
이런 경우 도커 컴포즈 파일에 앱 구조를 정의하면 된다.

컨테이너 실행시 지정할 모든 옵션과 도커 네트워크, 볼륨 등 도커 API에 명령을 내린다.

ex)
```dockerfile
verison: '3.7'

services:
    todo-web:
        image: diamol/ch06-todo-list
        ports:
            - "8020:80"
        networks:
            - apt-net
networks:
    app-net:
        external:
            name: nat
```
- 도커 컴포즈는 문법이 이해하기 쉽고, json 변환에 용이한 YAML 문법으로 기술된다.
- 예제상 세 개의 최상위 문으로 구성된다.
  1. version
     - 도커 컴포즈 파일 형식 버전
  2. services
     - 앱 구성 모든 컴포넌트 열거
     - 실제 컨테이너 대신 서비스 개념을 단위로 삼는다.
  3. networks
     - 서비스 컨테이너가 연결될 모든 도커 네트워크 열거
- diamol/ch06-todo-list 이미지를 통해 단일 컨테이너로 실행된다.
- 컨테이너의 80번 포트를 호스트 컴퓨터 8020번 포트를 통해 공개한다.
- app-net 정의된 app-net 도커 네트워크에 접속
- 서비스 이름은 컨테이너 이름이자 도커 네트워크상 다른 컨테이너가 식별할 수 있게 한다.
- 서비스 구성 네트워크는 app-net
- app-net 네트워크는 net이라는 외부 네트워크로 연결된다.
- external 의미는 nat 네트워크는 이미 존재하므로, 새로 생성하지말라는 것이다.
  - 여기에 설정된 네트워크가 존재하지 않는 경우 도커 네트워크를 생성한다.


도커 컴포즈는 도커 명령과는 다르게, 앱 실행을 위해 up 명령을 실행해야 한다.
up을 통해 컴포즈 파일 체크, 정의된 상태로 실행하기 위해 필요 요소 준비를 시작

실습) 도커 네트워크 생성, 예제를 받은 후 도커 컴포즈 실행해보기
- docker network create nat
- cd ./ch07/exercises/todo-list
- docker-compose up

docker-compose up 실행시 현재 작업 디렉토리에서 docker-compose.yml 파일을 찾는다.
그리고 서비스들을 읽어들이고, 설정한 이미지를 내려 받고, 컨테이너를 실행하고, 컨테이너는 정의된대로 동작한다.
또한 간접적으로 문서화 효과를 얻을 수 있다.
단일 서비스라면 몰라도 여러 서비스로 구성된 도커 컨테이너는 도커 컴포즈 파일이 꼭 필요하다.

## 7.2 도커 컴포즈를 사용해 여러 컨테이너로 구성된 애플리케이션 실행하기
도커 컴포즈를 통해 여러 서비스의 환경 변수, 명령 등을 정의하고, 서비스 간 통신을 자유롭게 할 수 있다.

```yaml
accesslog:
  image: diamol/ch04-access-log

iotd:
  image: diamol/ch04-image-of-the-day
  ports:
    - "80"
      
image-gallery:
  image: diamol/ch04-image-gallery
  ports:
    - "8010:80"
  depends on:
    - accesslog
    - iotd

# 네트워크 부분 생략
```
- accesslog는 공개 ports도 없이 이미지만 입력됐다.
- iotd는 rest api로, 80번 포트를 외부 무작위 포트를 통해 공개
- image-gallery도 외부 포트 공개, 다른 두 서비스에 의존한다는 것을 입력
  - 의존성 코드를 통해 나열된 두 서비스를 먼저 실행하려고 한다.

도커 컴포즈를 통해 분리 모드로 앱 실행해보자.
도커 컴포즈는 컨테이너 로그를 수집하지만, 컨테이너는 백그라운드로 동작한다. 
따라서 컴포즈의 기능을 사용해볼 수 있다.
실습) 예제 앱 실행해보기
- cd ./ch07/exercises/image-of-the-day
- docker-compose up --detach
    - --detach 명령을 통해 컨테이너가 백그라운드로 실행되어, 명령 실행창에 로그 출력이 없다.
실습) 도커 컴포즈를 사용해 iotd 서비스 컨테이너 수 늘리고, iotd 컨테이너 로그 살펴보기
- docker-compose up -d --scale iotd=3
- docker-compose logs --tail=1 iotd
  - --tail1=1 파라미터는 iotd 컨테이너의 마지막 로그를 출력하라는 의미다.

iotd 서비스 컨테이너를 총 세개로 관리하고, 해당 서비스에 api 요청시 세 개의 컨테이너에 고르게 분배해준다.
logs를 활용해 스케일링된 세 개의 컨테이너에 요청이 왔는지 체크 할 수 있다.

이처럼 도커 컴포즈가 대신 컨테이너들을 관리해준다.
하지만 도커 컴포즈를 통해 전체 앱을 관리할 수 있지만,
컴퓨팅 자원 절약을 위해 컨테이너 중지, 재시작, 재가동 등의 작업은 도커 명령행을 통해 할 수 있는 작업이다.
도커 컴포즈를 통해 컨테이너 관리를 돕지만, 내부적으로는 마찬가지로 도커 API를 사용한다.
따라서 도커 컴포즈를 통해 실행한 컨테이너도 도커 명령으로 관리 가능하다.
실습) 앱 중지, 재시작 후 실행 중인 컨테이너 목록 출력
- docker-compose stop
  - 중지된 모든 컨테이너는 CPU, 메모리를 점유하지 않지만, 컨테이너의 파일 시스템은 유지한다.
- docker-compose start
  - up과 start의 차이점 알기
  - 다시 앱 시작시 기존에 생성되었던 컨테이너가 재시작
- docker container ls

- docker-compose 
  - docker-compose --help와 마찬가지로, 전체 부명령 목록 체크 가능

도커 컴포즈는 클라이언트 측에서 동작하는 도구다.
도커 컴포즈 명령에 따라 도커 API로 지시를 보낸다.

도커 엔진 자체는 컨테이너를 실행할 뿐, 여러 컨테이너가 어떤 앱에서 동작하는지 여부는 알 수 없다.
따라서 도커 컴포즈를 통해 파일 작성 후 도커 엔진이 이 파일을 읽을 수 있게 해야 한다.

컴포즈 파일 수정 또는 도커 명령을 통해 앱 수정시 앱과 불일치 할 수 있다.
불일치 상태에서 비정상적인 동작을 보일 수 있다.
실습) 도커 컴포즈를 통해 앱 재시작하고 스케일링 상태 확인해봐라, 3개인지 체크
- docker-compose down
  - 앱 제거 명령, 앱 중지되고, 컨테이너 모두 제거된다. external 플래그가 없다면 볼륨과 네트워크도 제거 대상
- docker-compose up -d
- docker container ls

도커 컴포즈는 사용하기 쉽고, 강력한 기능을 갖췄다.
하지만 yaml의 컴포즈 파일 정의에 의존하는 클라이언트 측 도구임을 잊지말자.

도커 컴포즈로 앱 배포시 다양한 리소스가 생성되지만, 도커 엔진은 단순히 컨테이너를 실행할 뿐이다.
리소스 관리는 컴포트 파일을 통해 관리하자.

## 7.3 도커 컨테이너 간의 통신
분산 앱의 모든 구성 요소는 컴포즈를 통해 관리되고 컨테이너로 실행된다.

그렇다면 컨테이너간 통신은 어떻게 할까?
컨테이너는 별도 네트웤 공간을 가진 가상 환경이다.
도커 엔진으로부터 부여받은 가상 IP 주소를 가지며, 도커 네트워크로 연결하여 가상 IP를 통해 통신할 수 있다.
그러나 컨테이너 교체시 가상 IP 주소도 변경된다.
변경돼도 통신을 유지할 수 있도록 도커에 내장된 DNS 서비스를 이용해 서비스 디스커버리 기능을 제공한다.

DNS는 인터넷과 사설 네트워크 모두 동작한다.
컴퓨터는 IP를 알아내 실질적으로 통신을 수행하지만, 사람에게 친숙한 것은 도메인이다.
IP는 주소가 변경될 수 있고, 외우기 쉽지 않기 때문이다.

도커 내장 DNS 서비스를 통해 컨테이너의 가상 IP를 찾아준다.
이를 통해 같은 도커 네트워크에 있는 다른 컨테이너 정보를 사용 가능하다.
도메인의 대상이 IP가 아니라면, 호스트 컴퓨터의 네트워크나 인터넷 IP 주소를 조회한다. (?)
실습) 도커 컴포즈를 통해 iotd 컨테이너를 스케일업해서 실행 후 컨테이너에서 DNS 조회 명령 실행
- docker-compose up -d scale --iotd=3 (?)
  - docker-compose up -d --scale iotd=3
- docker container exec -it image-of-the-day_image-gallery_1 sh
  - nslookup accesslog
    - 웹 앱 컨테이너 기반 이미지의 유틸리티, 명령 인자로 도메인 지정시 해당 도메인 DNS 서비스 조회, 결과 출력 
  - exit

도커 네트워크에 연결된 모든 컨테이너는 이 네트워크 범위에 포함되는 가상 IP 주소를 부여받는다.
해당 네트워크를 통해 컨테이너간 통신이 가능하다.
DNS 조회를 사용하면, 컨테이너 교체로 IP 주소가 변경돼도 컨테이너에 접근 가능하다.
실습) 도커 명령으로 accesslog 컨테이너 삭제, 도커 컴포즈 재 실행, 웹 컨테이너 셸 실행 후 DNS 재 조회
- docker container rm -f image-of-the-day_accesslog_1
- docker-compose up -d --sacle iotd=3
- docker container exec -it image-of-the-day_image-gallery_1 sh
  - nslookup accesslog
  - nslookup iotd
  - exit

삭제되고 새로 생성된 컨테이너는 도커 엔진으로부터 가상 IP를 새로 부여받는다.
또한 iotd와 같이 하나의 도메인에 dns 조회시 각 컨테이너를 가리키는 세 개의 가상 ip주소가 출력된다.
도커 컴포즈는 이 점을 활용해 간단 로드 밸런싱 구현 가능하다.
여러 개 IP 주소를 어떻게 활용할지는 전적으로 애플리케이션이 결정한다.
간단한 조회는 첫 번 째 IP만 사용하게 할 수 있고, 모든 컨테이너에 고르게 분배할 수도 있다.
도커 DNS 시스템은 조회 결과의 순서를 매번 변화시킨다.
nslookup을 활용해 컨테이너간 트래픽 고르게 분산 가능하다.

도커 컴포즈는 컨테이너 실행시 지정된 모든 옵션 값을 기억하고, 옵션 값을 통해 컨테이너간 통신을 처리한다.
네트워크에 포함된 가상 IP 범위가 있고, 
컨테이너 삭제시 해당 가상 IP는 재사용 가능 상태가 된다.
따라서 컨테이너 삭제 후 생성해도, 같은 IP를 우연하게 사용 가능하다.

## 7.4 도커 컴포즈로 애플리케이션 설정값 지정하기
앱 컨테이너를 단일로 실행하고, 데이터는 SQLite 데이터베이스에 저장한다면?
이 경우 컨테이너 안 파일 하나만 있으면 된다.

그러나 소규모 프로젝트가 아닌 경우는 SQLite는 애매하다.
PostgreSQL을 사용해보도록 하자.
앱 컨테이너와 데이터베이스 컨테이너를 따로 실행해 분산 앱으로 구동 할 수 있다.
도커 컴포즈를 사용해 설정 값 적용해보자.

```yaml
services:
  todo-db:
    image: diamol/postgres:11.5
    ports:
      - "5433:5432"
    networks:
      - app-net
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - "8020:80"
    environment:
      - Database: Provider=Postgres
    depends_on:
      - todo-db
    networks:
      - app-net
    secrets:
      - source: postgres-connection
        target: /app/config/secrets.json
```
- environment: 컨테이너 안 사용될 환경 변수 값 정의
- secrets: 실행시 컨테이너 내부 파일에 기록될 비밀 값 정의, target에 정의된 파일이 생기고, source 값이 비밀 값의 값이 기록된다.

비밀 값은 주로 클러스터 환경에서 컨테이너 플랫폼을 통해 제공된다 (쿠버, 도커 스웜, ...)
평소에는 클러스터 데이터베이스에 암호화되어 있고 패스워드, 인증서, API 키 등 민감한 정보로 구성된 설정 값 전달에 적합하다.

```yaml
secrets:
  postgres-connection:
    file: ./config/secrets.json
```
- 비밀 값 postgres-connection의 값을 ./config/secrets.json 파일에서 읽어오라는 의미다.
- 호스트 컴의 파일이 컨테이너에 영향을 미친다는 점에서 바인드 마운트와 비슷하다.
  - 추후 클러스트 환경에서 암호화된 진짜 비밀 값으로 이전 여지를 남겨둔 것

앱의 설정 값을 컴포즈 파일에 정의시 이미지를 다양하게 활용 할 수 있다.
실습) 예제 도커 컴포즈 업 하기
- cd ./ch07/exercises/todo-list-postgres
- docker-compose up -d
- docker-compose ps
  - 컴포즈 파일에 정의된 모든 컨테이너 목록을 보여준다.

패키징된 앱과 설정 값을 분리할 수 있는 것이 도커의 핵심 장점 중 하나다.
앱 이미지는 빌드 파이프 라인을 통해 만들어지고 테스트 환경을 거쳐 운영 환경 적합한지 검증된다.

## 7.5 도커 컴포즈도 만능은 아니다.
도커 컨테이너의 본격적 사용을 위해 도커 컴포즈는 매우 중요한 도구다.
도커 컴포즈는 도커 스웜이나 쿠버네티스 같은 완전한 컨테이너 플랫폼은 아니다.
즉 앱이 지속적으로 정의된 상태를 유지하도록 하는 기능은 없다.
일부 컨테이너가 오류 또는 종료가 돼도 docker-compose up 명령을 다시 실행하지 않는 한 앱의 상태를 되돌릴 수 없다.

운영 환경에서는 도커 컴포즈보단, 도커 스웜이나 쿠버네티스가 쓰인다.
그러나 앱 정의에는 컴포즈파일 포맷을 사용한다.

도커 컴포즈가 모든 운영 환경에서 부적합하다는 것은 아니다.
컨테이너 클러스터의 운영 계획이 없는 한 도커 컴포즈로도 충분하다.

## 7.6 연습 문제

# 8장 헬스 체크와 디펜던시 체크로 애플리케이션의 신뢰성 확보하기
실행중인 컨테이너 앱을 운영 환경에 맞게 다듬을 수 있다.
도커 스웜이나 쿠버네티스 등과 같은 컨테이너 플랫폼을 통해 자동으로 에러에서 회복 할 수 있는 기능을 제공한다.
실행 중인 컨테이너의 앱이 상태가 정상인지 체크하는 정보가 이미지와 함께 패키징 되어 있다.

## 8.1 헬스 체크를 지원하는 도커 이미지 빌드하기

## 8.2 디펜던시 체크가 적용된 컨테이너 실행하기

## 8.3 애플리케이션 체크를 위한 커스텀 유틸리티 만들기

## 8.4 도커 컴포즈에 헬스 체크와 디펜던시 체크 정의하기

## 8.5 헬스 체크와 디펜던시 체크로 복원력 있는 애플리케이션을 만들 수 있는 이유

## 8.6 연습 문제


# 9장 컨테이너 모니터링으로 투명성 있는 애플리케이션 만들기

# 10장 도커 컴포즈를 이용한 여러 환경 구성

# 11장 도커와 도커 컴포즈를 이용한 애플리케이션 빌드 및 테스트



















