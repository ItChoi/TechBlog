# 트랜잭션
우리는 항상 트랜잭션 없이 사용하는 것 보다, 과용해서 사용 후 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리 하는 게 좋다고 생각한다.

데이터 시스템은 여러 가지 문제가 생길 수 있다.
1. DB는 언제라도 실패 가능성이 있다.
2. 애플리케이션은 언제라도 뻗을 수 있다. 
3. 앱과 디비 사이의 연결이 끊기거나, 디비 내부 노드들 사이의 통신이 안 될 수 있다.
4. 디비에서 여러 쓰기 작업이 내용을 덮을 수 있다.
5. 부분적 갱신으로 비정상 데이터를 읽을 수 있다.
6. 클라이언트 사이의 경쟁 조건은 예측못한 버그 유발 가능성이 있다.

시스템 신뢰성을 유지하기 위해서는 이런 결함을 처리 후 장애로 이어지지 않게 해야 한다.
그러나 내결함성을 갖춘 시스템 구현을 위한 작업은 많다. 따라서 신중한 결정과 실제 동작하는지 체크는 필수다.

수십년 동안 트랜잭션은 위에 문제들을 단순화하는 메커니즘으로 채택됐다.
트랜잭션은 전체가 성공(커밋) 또는 실패(어보트, 롤백)한다. 부분적인 실패를 걱정 안 해도 된다.

DB 접속 앱에서 프로그래밍 모델을 단순화 목적으로 만들었다. 트랜잭션을 사용하는 환경을 당연하게 생각하면 안 된다.
트랜잭션을 사용하게 되면서 앱에서 어느 정도의 잠재적 문제나 동시성 문제를 무시할 수 있다.
DB에서 이런 역할을 대신해준다. 

모든 앱에서 트랜잭션이 필요하지는 않고, 때로는 트랜잭션 사용을 줄이거나 쓰지 않는 것이 이득이다.
예를 들어 성능 향상 또는 가용성을 높일 수 있다.
Q) 실제로 스프링 부트 JPA 환경에서 요청에 대한 트랜잭션을 완화하는 방법이 많지는 않다.

트랜잭션 필요 여부를 어떻게 알 수 있을까? 먼저 트랜잭션이 제공하는 안전성 보장이 무엇이 있고, 비용이 무엇인지 정확히 이해해야한다.
트랜잭션은 간단히 적용되지만, 실제로 여러 가지 미묘하면서도 중요 세부 사항이 적용된다.

단일 노드 DB와 분산 DB 환경에서 발생하는 난제는 다를 수 있는데, 이번 장은 공통적인 내용을 살펴본다.

## 애매모호한 트랜잭션의 개념
트랜잭션은 이점과 한계가 있다. 이 트레이드 오프를 이해해야 하며, 여러 트랜잭션 제공 사례를 살펴 봐야 한다.

### ACID의 의미
트랜잭션 제공 안전성 보장은 흔히 네 가지가 있다. (ACID)
1. 원자성(Atomicity)
2. 일관성(Consistency)
3. 격리성(Isolation)
4. 지속성(Durability)

내결함성 메커니즘을 나타내는 정확한 용어 확립을 위해 ACID를 만들었다.
그러나 현실에서 DB마다 ACID 구현이 제각각이다. 오늘날 ACID는 마케팅 용어가 됐다.

## 원자성
다중 스레드 환경에서 한 스레드가 원자적 연산을 실행한다면, 다른 스레드에서 절반만 완료된 연산을 관찰 할 수 없다.
시스템은 연산 전, 후 상태만 존재하고, 중간 상태에 머무를 수 없다. 

ACID 원자성은 클라이언트가 쓰기 작업 여러 개 실행 중 일부만 처리된 후 결함이 생긴다면, 롤백된다.
즉 모두가 성공하면 커밋되고, 전체 중 하나라도 실패하면 어보트(롤백)된다.
원자성이 없으면 여러 번의 요청에서 어떤 요청에서 어떤 데이터가 변경됐는지 체크가 어렵다.
또한 반복된 요청으로 원하지 않는 데이터가 최종 결과물이 될 수 있다.

## 일관성
ACID 일관성은 데이터 불변식이 있다. 즉 내가 CRUD 할 때 일관된 데이터가 보장된다면 불변식이 항상 만족된다고 확신 할 수 있다.
일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.
즉 데이터베이스가 보장할 수 없다.

## 격리성
동시에 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 된다.
ACID 격리성은 동시 실행 트랜잭션은 서로 격리된다는 것을 의미한다.
한 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 

한 트랜잭션이 여러 번 쓰기 작업을 할 다른 트랜잭션은 그 내용을 전부 볼 수 있거나 볼수 없어야 한다. 
일부만 볼 수 있어서는 안 된다.

직렬성 -> 각 트랜잭션이 전체 DB에서 유일한 트랜잭션인 것 처럼 동작한다. 실제로 여러 트랜잭션이 동시 실행되더라도, 
커밋 결과는 트랜잭션들이 순차적으로 실행됐을 때와 동일하도록 보장한다. 

그러나 직렬성 격리는 성능 손해를 동반한다. 따라서 거의 사용되지 않는다.
실제로는 직렬성 격리보단, 스냅숏 격리를 구현한 것이다.

## 지속성
데이터의 영구적 보장이 돼야 한다.
즉 커밋 됐다면, 어떠한 오류나 결함에 인해 데이터는 손실이 되지 않는다.
완벽한 지속성은 존재하지 않는다.

단일 노드 DB에서 지속성은 데이터가 하드디스크나 SSD같은 비휘발성 저장소에 기록된 것을 의미한다.
디스크 안에 데이터 구조가 오염됐을 경우, 쓰기 전 로그 또는 비슷한 수단을 통해 복구 할 수 있다.

복제 기능이 있는 DB에서 지속성은 다른 노드에 복사 됐다는 것을 의미한다.
즉, 성공 커밋을 알리기 전 복제 완료까지 기다려야 한다.

지속성의 절대적 보장은 없다. 디스크에  쓰기, 원격 장비에 복제하기, 백업 등을 포함해 위험을 줄이려는 기법이 있을 뿐이다.


## 단일 객체 연산과 다중 객체 연산
ACID에서 원자성과 격리성은 한 트랜잭션 내에서 여러 번 쓰기를 하면 DB가 어떻게 해야 하는지 서술한다.

한 번에 여러 객체를 변경할 때(아이템, 아이템 상세, ...) 
다중 객체 트랜잭션은 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.  

다중 객체 트랜잭션은 읽기, 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.
RDBMS에서는 전형적으로 클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다.
특정 연결 내에서 트랜잭션 시작과 커밋 사이의 모든 것은 같은 트랜잭션으로 여긴다.


## 단일 객체 쓰기
원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.
1. 20KB JSON 문서 쓰기 작업 중, 10KB 보낸 후 결함 발생
2. 디스크에 기존 값을 덮어 쓰는 도중에 결함 발생 
3. 쓰기 작업을 통해 일부만 갱신 됐을 때, 다른 클라이언트에서 읽을 때 부분적으로 읽게 할 건지

## 다중 객체 트랜잭션의 필요성
많은 경우에 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션 돼야 한다.
트랜잭션이 없어도 앱을 구현할 수 있지만, 원자성이 없으면 오류처리가 훨씬 복잡해지고, 격리성이 없으면 동시성 문제가 생길 수 있다.

## 오류와 어보트 처리
트랜잭션의 핵심 기는은 오류 발생시 롤백되고, 재시도가 가능하다.

## 완화된 격리수준
동시성 문제는 서로 다른 트랜잭션이 동시에 변경한 데이터를 읽거나 서로 변경하려 할 때 나타난다.
이런 경우 테스트로 발견하기도 어렵고 동시성을 추론하기 어렵다.

따라서 DB는 트랜잭션 격리를 제공함으로써 개발자에게 동시성 문제를 감추려 했다.
즉 이론상 트랜잭션 격리를 통해 동시성이 없는 것 처럼 행동할 수 있다.
직렬성 격리는 동시성 없이 한 번에 한 트랜잭션을 수행하게 하지만, 성능상 문제가 있어 쓰지 않는다.

완화된 트랜잭션 격리가 유발하는 동시성 버그는 데이터를 오염시키고, 실질적인 손해를 만든다.

## 커밋 후 읽기
기본이 되는 트랜잭션 격리 수준이다. 
1. 조회시 커밋된 데이터만 대상이 된다. (더티 읽기 없음)
2. 쓰기 작업시 커밋된 데이터만 덮어 쓴다. (더티 쓰기 없음)

### 더티 읽기 방지
DB 쓰기 작업시 커밋 또는 어보트가 되지 않았을 때, 다른 트랜잭션이 데이터 조회가 가능하다면 더티 읽기라 부른다
즉 uncommited data 조회 가능시 -> 더티 읽기
커밋 후 읽기에서는 더티 읽기를 막아야 한다.

더티 읽기 방지가 유용한 이유
1. 다른 트랜잭션에서 조회시, 조회마다 값이 유동적일 수 있다. 
2. 트랜잭션 안에서 일부 실패로 어보트시, 모두 롤백돼야 한다.
   - 더티 읽기 허용시, 롤백 대상 데이터를 읽게 된다.

### 더티 쓰기 방지
두 트랜잭션이 동일 객체 변경 시도시 나중에 쓴 내용이 값을 덮어쓴다.
그러나 먼저 A 트랜잭션이 쓰기 작업 후 커밋되지 않고, 그 후 B 트랜잭션이 쓰기 작업을 하는데, 
A의 커밋되지 않은 데이터를 덮어 씌울 때, 더티 쓰기라고 한다.

일반적으로 첫 번째 트랜잭션이 커밋 또는 어보트 될 때 까지 두 번째 트랜잭션 쓰기를 지연시키는 방법 사용

더티 쓰기 방지 - 몇 가지 동시성 문제 회피 가능
1. 여러 트랜잭션이 동일 객체 변경을 시도할 때 원하지 않는 결과가 나올 수 있다.
   - 1개 상품을 A와 B가 동시에 구매할 때, 구매는 A가 하지만, 상품 구매 결과는 B에게 통보될 수 있다.
2. 카운트 증가 사이에 발생하는 경쟁 조건을 막지 못한다. -> 더티 쓰기 때문은 아니지만, 여전히 잘못 카운팅된다.

### 커밋 후 읽기 구현
매우 널리 쓰이는 격리 수준이다. -> 오라클, 포스트그레스큐엘, sql 서버, ...

가장 흔한 방법으로 DB는 로우 수준 잠금을 사용해 더티 쓰기 방지
트랜잭션에서 로우나 문서 변경 전 먼저 해당 객체 잠금을 획득해야 한다.
잠근은 커밋 또는 어보트 전 까지 보유한다. 오직 한 트랜잭션만 객체에 대한 잠금을 보유한다.
한 트랜잭션에서 락 반환 전 다른 트랜잭션에서 쓰기 작업 시도시 락 반환을 기다리고, 획득 후 쓰기 작업을 진행한다.
커밋 후 읽기에서는 위에 내용을 자동으로 실행해준다. 

더티 읽기 방지
1. 동일하게 잠금을 써서 락 획득, 반환을 통해 방지한다. 
   - 다른 트랜잭션이 언커밋된 읽기를 방지 할 수 있다.
   - 그러나 읽기 잠금 요구 방식은 현실에서 잘 동작하지 않는다. -> 읽기 락을 통해 쓰기 작업도 막힌다.

쓰기 잠금을 가진 객체는 과거 커밋된 값, 새로운 값 모두 기억한다.
잠금 반환 전 다른 트랜잭션은 조회시 과거 값을 읽는다.
즉 새 값이 커밋 돼야 조회 가능하고, 그 전에는 과거 값을 읽는다. 

### 스냅숏 격리와 반복 읽기 (repeatable read)
커밋 후 읽기 격리를 자동으로 다 해주는 완벽한 격리 수준으로 보일 수도 있다.
더티 읽기 방지와 동시 실행 쓰기가 섞이는 것을 방지해주기 떄문이다.
강력한 기능이긴 하지만, 동시성 버그가 생길 여지는 아직 많이 있다.

은행 예시
1. A는 두(B, C) 은행에 500달러씩 총 1,000 달러를 가지고 있다. 
2. B -> C 은행으로 100 달러 송금시, B - 100과 C + 100 두 개의 쿼리가 실행된다.
3. 두 쿼리 사이 조회 발생시 B: 400, C 500 값이 조회 될 수 있다 (조회상 100 달러 증발)
- 위에 예시를 비반복 읽기(nonrepeatable read) 또는 읽기 스큐(read skew)라 한다.
- 즉 일시적 비일관성이 발생한다.
Q) 이 부분도 커밋 후 읽기를 통해 해결하면 되는거 아닌가?
A) 트랜잭션 시작 시점에 커밋된 데이터를 일관적으로 본다는 점에서 다른듯 - 트랜잭션 시작 지점에서 스냅숏 읽은 후, 객체의 값이 변경돼도 과거의 데이터를 본다.
Q) 트랜잭션 시작 시점에 데이터를 보더라도, 이 데이터가 트랜잭션 끝나기 전 과거 데이터가 된다면, 동시성 이슈 여뷰가  없나? - 쓰기 락 획득 반환을 통해 괜찮나?

스냅숏 격리는 위에 문제의 가장 흔한 해결책이다.
각 트랜잭션은 DB의 일관된 스냅숏으로부터 읽는다.
즉 트랜잭션 시작시 커밋된 상태였던 모든 데이터를 본다.

그러나 스냅숏 격리는 백업이나 분석처럼 실행시 오래 걸리고 읽기 질의에만 요긴하다.
읽기 질의 실행 중 데이터가 변경된다면, 질의 의미 추론이 매우 어려운데, 일관된 스냅숏만 본다면 훨씬 쉬워진다.
널리 쓰이는 기능이며 포스트그레스큐엘, mysql, oracle, sql server 등에서 지원된다.

### 스냅숏 격리 구현
전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다.
그러나 읽을 땐 아무 잠금이 필요 없다.
스냅숏 격리의 핵심 원리는 읽기 때 쓰기를 차단하지 않고, 쓰기 때 읽기를 차단하지 않는다.
Q) 그럼 커밋 후 읽기라는건가 더티 읽기라는건가?
A) 트랜잭션 시작 시점에 커밋된 데이터를 읽는다.

따라서 DB는 잠금 경쟁 없이 쓰기 작업과 일관성 있는 스냅숏에 대해 읽기를 처리 할 수 있다.
Q) 더티 쓰기 방지를 위해 쓰기 잠금 사용한다는데, "잠금 경쟁 없이 쓰기 작업" ???? 

DB는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.
Q) 여기서 객체란 테이블인가?
진행중인 여러 트랜잭션에서 서로 다른 시점의 DB 상태를 봐야할 수도 있다.
DB가 객체의 여러 버전을 함께 유지하는 기법을 다중 버전 동시성 제어 (MVCC, multi-version concurrency control)라 한다.

DB가 커밋 후 읽기 격리만 제공한다면, 객체마다 두 개씩만 유지하면 충분하다.
Q) 커밋 후 읽기 두 버전이 언두, 리두 영역인가?

스냅숏 격리 지원 저장소 엔진은 보통 읽기 격리를 위해서 MVCC를 사용한다.
전형적인 방법은 커밋 후 읽기는 질의마다 독립된 스냅숏 사용하고 전체 트랜잭션에 동일한 스냅숏을 사용한다.

포스트그레스큐엘 MVCC 예시 (p.239 그림)
1. 트랜잭션 시작시 고유한 트랜잭션 ID를 할당받는다. (계속 증가하는 숫자)
2. 트랜잭션이 쓰기 작업시 실행한 트랜잭션 ID가 함께 붙는다.
3. 테이블 각 로우에는 추가 & 삭제한 트랜잭션 아이디를 갖는 필드가 있다.
4. 트랜잭션이 로우 삭제시 물리적 삭제가 아닌, 삭제 트랜잭션 아이디 필드에 트랜잭션 ID를 설정
5. 아무런 트랜잭션도 삭제 로우 데이터 접근하지 않는게 확실해지면 DB 가비지 컬렉션 프로세스가 삭제 필드에 트랜잭션 Id가 설정된 로우들 삭제
- 갱신의 경우 내부에서 삭제와 생성으로 변환

### 일관된 스냅숏을 보는 가시성 규칙
스냅숏 격리 수준에서 트랜잭션은 DB 객체 읽을 때 TxId를 사용해 어디까지 읽고 못 읽는지 결정한다.
스냅숏 격리 동작 방식
1. DB는 각 트랜잭션 시작 시점에 uncommited(커밋 또는 어보트 되지 않은)된 모든 트랜잭션 목록을 만든다.
   - 각 트랜잭션이 쓰기 작업한 데이터도 모두 무시된다. (커밋되도 마찬가지) 
Q) 모든 테이블의 모든 로우에 대한 uncommited 데이터를 말하는건가? 너무 방대한데, 트랜잭션 시작 시점에는 어떤 테이블에 접근 할 지 모르니까 모든 것을 대상으로 하나?
Q) 트랜잭션 실행 시점에 모두를 가져오는게 아니라, 캐싱된 어떤 공간에서 가져오는건가?
2. 롤백된 트랜잭션이 쓴 데이터 모두 무시
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 커밋 여부와 관계없이 모두 무시
Q) created by를 기준으로 TxId가 초과되는 데이터는 안 읽는건가? 
4. 그 외 모든 데이터는 가능 질의로 본다.
- 위 규칙들은 객체 생성 및 삭제에 모두 적용

즉 트랜잭션 실행 시점에 커밋된 데이터는 볼 수 있고,
읽기 대상 객체가 삭제로 표시되지 않았거나, 삭제로 표시됐지만, 커밋되지 않은 데이터는 볼 수 있다.
Q) 삭제로 표시 됐지만 커밋된 것은 어떻게 구분할까?

오래 실행된 트랜잭션은 스냅숏을 이용해 어디까지가 허용 가능 범위에서 덮어 씌워졌고, 삭제된 데이터를 오랫동안 읽을 수 있다.
DB는 갱신 값을 바로 교체하지 않고, 변경마다 새 버전을 생섬함으로써 작은 오버헤드만 유발하면서 일관된 스냅샷 사용

### 색인과 스냅숏 격리
다중 버전 DB에서 색인은 어떻게 동작할까?
- 색인이 객체의 모든 버전을 가리키고, 색인 질의를 통해 볼 수 없는 버전 걸러내는 심플한 방식도 있다.
  - GC는 어떤 트랜잭션에게도 더 이상 보이지 않는 오래된 객체 버전을 삭제 할 때 대응되는 색인 항목도 삭제

MVCC는 여러 구현 세부 사항에 따라 성능이 결정된다.
- 동일 객체 다른 버전들이 같은 페이지 저장 가능하다면, 색인 갱신을 회피하는 최적화를 한다.

### 반복 읽기와 혼란스러운 이름
스냅숏 격리는 유용하며 특히 읽기 전용 트랜잭션에 유용하다.
오라클에서는 직렬성이라고 하며, mysql에서는 반복 읽기(repeatable read) 라고 한다.

### 갱신 손실 방지
동시 실행 쓰기 트랜잭션 사이에 발생 가능 충돌은 몇 가지 더 있다.
- 가장 널리 알려진 것은 갱실 손실(lost update) 문제다.
  - ex) 두 트랜 잭션이 동시에 카운터를 증가시킨다.
  - 앱에서 DB의 값을 읽고 쓰기 작업 후 다시 쓰기 작업 할 때 발생할 수 있다. (read-modify-write)

두 트랜잭션이 동시에 동일 객체에 쓰기 작업을 할 때, 두 번 째 작업이 첫 번째를 포함하지 않으므로 변경 중 하나는 손실된다.
위와 같은 패턴은 다양한 시나리오를 발생시킨다.
1. 카운터 증가 or 계좌 잔고 갱신
2. 복잡한 값을 지역적으로 변경 (단계적 변경?)
3. DB에 저장된 값을 덮어 쓰도록 만들어진 환경에서 두 명이 동시에 쓰기 작업 실행

갱신 손실은 흔한 문제라서, 다양한 해결책이 존재한다.

### 원자적 쓰기 연산
여러 DB에서 원자적 갱신 연산 제공한다. 이는 앱 코드에서 read-modify-write 주기 구현 필요를 없애준다.
원자적 연산은 보통 객체 읽기 시 독점적인 잠금 획득해서 구현한다. 이를 커서 안정성이라 한다.
또는 단일 스레드에서 실행되도록 강제한다.

### 명시적인 잠금
앱 로직에 신중해야 하고, 추가적으로 필요한 추가 잠금을 깜빡하면 경쟁 조건 유발이 높아진다.

### 갱실 손실 자동 감지
앱 코드에서 DB 기능을 쓸 필요 없게 도와주어 좋은 기능이다.
오류를 덜 발생하게 도와준다.

### Compare-and-set
값을 마지막으로 읽은 후 변경되지 않았을 때만 갱신 허용

### 충돌 해소와 복제

### 쓰기 스큐와 팬텀

### 쓰기 스큐를 특징짓기

### 추가적인 쓰기 스큐의 예

### 쓰기 스큐를 유발하는 팬텀
예시
1. 두명 이상 근무, 한명은 필수로 근무, 두명이 동시에 휴가를 쓰는 경우
2. 회의실 예약
3. 닉네임 획득

위에 모든 예는 비슷한 패턴을 따른다.
1. 조회 질의를 통해 점유 되지 않음을 확인
2. 조회 결과에 따라 진행 방식 결정
3. 점유 후 커밋

어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 한다.

### 충돌 구체화
예약 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 로우를 잠글 수 있다 (SELECT FOR UPDATE)
먼저 로우를 잠금하고, 겹치는 예약이 있는지 체크 후 새 예약을 삽입한다.
단지 회의실, 시간 범위가 동일한 예약이 있는지 체크하기 위한 잠금일 뿐이다.
이런 방법을 충돌 구체화라고 한다.

## 직렬성
가장 강력한 격리 수준이다.
최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.

### 실제적인 직렬 실행

### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
OTLP 환경에서 대화식으로 요청과 응답을 함으로써 트랜잭션을 짧게 유지한다.
한 번에 하나씩 처리한다면 성능에 무리가 간다.

### 스토어드 프로시저의 장단점

### 파티셔닝

### 직렬 실행 요약

### 2단계 잠금 (2PL)
30년간 DB 직렬성 구현에 널리 쓰인 유일한 알고리즘이다.

### 2단계 잠금 구현

### 2단계 잠금의 성능

### 서술 잠금

### 색인 범위 잠금

### 직렬성 스냅숏 격리

### 비관적 동시성 제어 vs 낙관적 동시성 제어

### 뒤쳐진 전제에 기반

### 오래된 MVCC 읽기 감지하기

### 과거의 읽기에 영향을 미치는 쓰기 감지하기

### 직렬성 스냅숏 격리의 성능

## 정리














