# 트랜잭션
우리는 항상 트랜잭션 없이 사용하는 것 보다, 과용해서 사용 후 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리 하는 게 좋다고 생각한다.

데이터 시스템은 여러 가지 문제가 생길 수 있다.
1. DB는 언제라도 실패 가능성이 있다.
2. 애플리케이션은 언제라도 뻗을 수 있다. 
3. 앱과 디비 사이의 연결이 끊기거나, 디비 내부 노드들 사이의 통신이 안 될 수 있다.
4. 디비에서 여러 쓰기 작업이 내용을 덮을 수 있다.
5. 부분적 갱신으로 비정상 데이터를 읽을 수 있다.
6. 클라이언트 사이의 경쟁 조건은 예측못한 버그 유발 가능성이 있다.

시스템 신뢰성을 유지하기 위해서는 이런 결함을 처리 후 장애로 이어지지 않게 해야 한다.
그러나 내결함성을 갖춘 시스템 구현을 위한 작업은 많다. 따라서 신중한 결정과 실제 동작하는지 체크는 필수다.

수십년 동안 트랜잭션은 위에 문제들을 단순화하는 메커니즘으로 채택됐다.
트랜잭션은 전체가 성공(커밋) 또는 실패(어보트, 롤백)한다. 부분적인 실패를 걱정 안 해도 된다.

DB 접속 앱에서 프로그래밍 모델을 단순화 목적으로 만들었다. 트랜잭션을 사용하는 환경을 당연하게 생각하면 안 된다.
트랜잭션을 사용하게 되면서 앱에서 어느 정도의 잠재적 문제나 동시성 문제를 무시할 수 있다.
DB에서 이런 역할을 대신해준다. 

모든 앱에서 트랜잭션이 필요하지는 않고, 때로는 트랜잭션 사용을 줄이거나 쓰지 않는 것이 이득이다.
예를 들어 성능 향상 또는 가용성을 높일 수 있다.
Q) 실제로 스프링 부트 JPA 환경에서 요청에 대한 트랜잭션을 완화하는 방법이 많지는 않다.

트랜잭션 필요 여부를 어떻게 알 수 있을까? 먼저 트랜잭션이 제공하는 안전성 보장이 무엇이 있고, 비용이 무엇인지 정확히 이해해야한다.
트랜잭션은 간단히 적용되지만, 실제로 여러 가지 미묘하면서도 중요 세부 사항이 적용된다.

단일 노드 DB와 분산 DB 환경에서 발생하는 난제는 다를 수 있는데, 이번 장은 공통적인 내용을 살펴본다.

## 애매모호한 트랜잭션의 개념
트랜잭션은 이점과 한계가 있다. 이 트레이드 오프를 이해해야 하며, 여러 트랜잭션 제공 사례를 살펴 봐야 한다.

### ACID의 의미
트랜잭션 제공 안전성 보장은 흔히 네 가지가 있다. (ACID)
1. 원자성(Atomicity)
2. 일관성(Consistency)
3. 격리성(Isolation)
4. 지속성(Durability)

내결함성 메커니즘을 나타내는 정확한 용어 확립을 위해 ACID를 만들었다.
그러나 현실에서 DB마다 ACID 구현이 제각각이다. 오늘날 ACID는 마케팅 용어가 됐다.

## 원자성
다중 스레드 환경에서 한 스레드가 원자적 연산을 실행한다면, 다른 스레드에서 절반만 완료된 연산을 관찰 할 수 없다.
시스템은 연산 전, 후 상태만 존재하고, 중간 상태에 머무를 수 없다. 

ACID 원자성은 클라이언트가 쓰기 작업 여러 개 실행 중 일부만 처리된 후 결함이 생긴다면, 롤백된다.
즉 모두가 성공하면 커밋되고, 전체 중 하나라도 실패하면 어보트(롤백)된다.
원자성이 없으면 여러 번의 요청에서 어떤 요청에서 어떤 데이터가 변경됐는지 체크가 어렵다.
또한 반복된 요청으로 원하지 않는 데이터가 최종 결과물이 될 수 있다.

## 일관성
ACID 일관성은 데이터 불변식이 있다. 즉 내가 CRUD 할 때 일관된 데이터가 보장된다면 불변식이 항상 만족된다고 확신 할 수 있다.
일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.
즉 데이터베이스가 보장할 수 없다.

## 격리성
동시에 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 된다.
ACID 격리성은 동시 실행 트랜잭션은 서로 격리된다는 것을 의미한다.
한 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 

한 트랜잭션이 여러 번 쓰기 작업을 할 다른 트랜잭션은 그 내용을 전부 볼 수 있거나 볼수 없어야 한다. 
일부만 볼 수 있어서는 안 된다.

직렬성 -> 각 트랜잭션이 전체 DB에서 유일한 트랜잭션인 것 처럼 동작한다. 실제로 여러 트랜잭션이 동시 실행되더라도, 
커밋 결과는 트랜잭션들이 순차적으로 실행됐을 때와 동일하도록 보장한다. 

그러나 직렬성 격리는 성능 손해를 동반한다. 따라서 거의 사용되지 않는다.
실제로는 직렬성 격리보단, 스냅숏 격리를 구현한 것이다.

## 지속성
데이터의 영구적 보장이 돼야 한다.
즉 커밋 됐다면, 어떠한 오류나 결함에 인해 데이터는 손실이 되지 않는다.
완벽한 지속성은 존재하지 않는다.

단일 노드 DB에서 지속성은 데이터가 하드디스크나 SSD같은 비휘발성 저장소에 기록된 것을 의미한다.
디스크 안에 데이터 구조가 오염됐을 경우, 쓰기 전 로그 또는 비슷한 수단을 통해 복구 할 수 있다.

복제 기능이 있는 DB에서 지속성은 다른 노드에 복사 됐다는 것을 의미한다.
즉, 성공 커밋을 알리기 전 복제 완료까지 기다려야 한다.

지속성의 절대적 보장은 없다. 디스크에  쓰기, 원격 장비에 복제하기, 백업 등을 포함해 위험을 줄이려는 기법이 있을 뿐이다.


## 단일 객체 연산과 다중 객체 연산
ACID에서 원자성과 격리성은 한 트랜잭션 내에서 여러 번 쓰기를 하면 DB가 어떻게 해야 하는지 서술한다.

한 번에 여러 객체를 변경할 때(아이템, 아이템 상세, ...) 
다중 객체 트랜잭션은 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.  

다중 객체 트랜잭션은 읽기, 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.
RDBMS에서는 전형적으로 클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다.
특정 연결 내에서 트랜잭션 시작과 커밋 사이의 모든 것은 같은 트랜잭션으로 여긴다.


## 단일 객체 쓰기
원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.
1. 20KB JSON 문서 쓰기 작업 중, 10KB 보낸 후 결함 발생
2. 디스크에 기존 값을 덮어 쓰는 도중에 결함 발생 
3. 쓰기 작업을 통해 일부만 갱신 됐을 때, 다른 클라이언트에서 읽을 때 부분적으로 읽게 할 건지

## 다중 객체 트랜잭션의 필요성
많은 경우에 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션 돼야 한다.
트랜잭션이 없어도 앱을 구현할 수 있지만, 원자성이 없으면 오류처리가 훨씬 복잡해지고, 격리성이 없으면 동시성 문제가 생길 수 있다.

## 오류와 어보트 처리
트랜잭션의 핵심 기는은 오류 발생시 롤백되고, 재시도가 가능하다.

## 완화된 격리수준
동시성 문제는 서로 다른 트랜잭션이 동시에 변경한 데이터를 읽거나 서로 변경하려 할 때 나타난다.
이런 경우 테스트로 발견하기도 어렵고 동시성을 추론하기 어렵다.

따라서 DB는 트랜잭션 격리를 제공함으로써 개발자에게 동시성 문제를 감추려 했다.
즉 이론상 트랜잭션 격리를 통해 동시성이 없는 것 처럼 행동할 수 있다.
직렬성 격리는 동시성 없이 한 번에 한 트랜잭션을 수행하게 하지만, 성능상 문제가 있어 쓰지 않는다.

완화된 트랜잭션 격리가 유발하는 동시성 버그는 데이터를 오염시키고, 실질적인 손해를 만든다.

## 커밋 후 읽기





