# 09 옵티마이저와 힌트
```text
- MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 결과를 만들어내는 방법은 매우 다양하다.
- 다양한 방법 중 최적, 최소의 비용을 위한 결정이 필요하다.
- MYSQL은 쿼리 최적 실행을 위해 각 테이블에 어떤 분포로 저장돼 있는지 통계 정보 참조하고, 기본 데이터를 비교해 최적의 실행 계획
수립 작업이 필요하다.
  - 대부분 DBMS에서는 옵티마이저가 이러한 기능을 담당한다.

- MYSQL -> EXPLAIN 명령 -> 쿼리 실행 계획 확인 가능
  - 상당히 많은 정보 출력 -> 제대로 이해하기 위해 옵티마이저 실행 최적화에 대한 어느정도 지식이 있어야 한다.
```

## 9.1 개요
```text
- 옵티마이저는 복잡하지만, 실행 계획을 이해할 수 있어야 불합리한 부분을 찾아내고 더 최적화된 실행 계획 수립 유도 가능
```

### 9.1.1 쿼리 실행 절차
```text
- MYSQL 서버 -> 쿼리 실행 과정 크게 세 단계
  1. 사용자 요청 쿼리 문장을 잘게 쪼개 MYSQL 서버가 이해 가능한 수준으로 분리(파스 트리)
    - SQL 파싱, SQL 파서 모듈로 처리 
    - 쿼리 문법 에러 체크
    - 파스 트리가 만들어지고 SQL 파스 트리를 이용해 쿼리 실행
    - MYSQL 엔진에서 처리
  2. SQL 파싱 정보(파스 트리) 확인
    - 어떤 테이블 부터 읽을지 선택
    - 어떤 인덱스를 이용하여 테이블 읽을지 선택
    - SQL 파스 트리 참조하여 다음 내용들을 처리
      1. 불필요 조건 제거, 복잡 연산 단순화
      2. 여러 테이블 조인 -> 어떤 순서로 테이블 읽을지 결정
      3. 각 테이블 조건, 인덱스 통계 정보를 이용해 사용할 인덱스 결정
      4. 임시 테이블에 가져온 레코드 넣고, 가공 여부 결정
    - 최적화 및 실행 계획 수립 단계
    - MYSQL 서버 옵티마이저에서 처리
    - 이 단계 완료시 "실행 계획"이 만들어진다.
  3. 결정된 읽기 순서나 선택된 인덱스를 이용해 스토리지엔진으로부터 데이터를 가져온다.
    - 가져온 데이터 -> 조인, 정렬 작업 수행
    - MYSQL 엔진과 스토리지 엔진 동시 참여하여 처리
```

### 9.1.2 옵티마이저의 종류
```text
- 비용 기반 최적화 (Cost-based optimizer, CBO) - 현재 대부분 DBMS 선택
  - 쿼리 처리를 위해 여러 방법을 만들고, 각 단위 작업 비용 정보, 대상 테이블 예측된 통계 정보 이용해 실행 계획별 비용 산출
  - 산출된 실행 방법 별 비용 최소 처리 방식 선택해 최종 쿼리 실행
  - 대부분 RDBMS가 채택 (MYSQL 포함)
- 규칙 기반 최적화 (Rule-based optimizer, RBO) - 초기 오라클 DBMS 많이 사용
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저 내장 우선순위에 따라 실행 계획 수립
  - 같은 쿼리에 대해서 항상 같은 실행방법을 만든다.
  - 데이터 분포도가 매우 다양한 요즘은 사용하지 않는다.
```

## 9.2 기본 데이터 처리
```text
- 데이터 정렬, 그루핑 등 기본 데이터 가공 기능은 결과물이 같더라도 RDBMS 별로 결과를 만들어내는 과정은 천차만별
```

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
```text
- 옵티마이저 -> 풀 테이블 스캔 선택 조건
  1. 테이블 레코드 건수가 너무 작은 경우 (일반적으로 테이블이 페이지 1개로 구성)
  2. WHERE절 또는 ON절에 인덱스 이용할 수 있는 적절 조건이 없는 경우
  3. 인덱스 레인지 스캔 사용 가능 -> 옵티마이저 판단에 조건 일치 레코드 건수가 너무 많은 경우 (B-Tree를 샘플링해 조사한 통계 정보 기준)
- 대부분 DBMS의 풀 테이블 스캔 실행 시 한꺼번에 여러 개의 블록, 페이지를 읽어오는 기능 내장
  - 시스템 변수로는 없기에 하나씩 읽어오는 걸로 착각 할 수 있다. (MyISAM 스토리지 엔진은 맞는 말)
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업 자동 시작
  - Read ahead: 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해 요청 전 미리 디스크를 읽어 InnoDB 버퍼풀에 저장
  - 테이블 풀 스캔시
    - 처음 몇 개 데이터 페이지는 포그라운드 스레드로 읽기 실행
    - 특정 시점부터 백그라운드 스레드가 읽기 실행 
      - 한 번에 4 ~ 8개 페이지를 읽으며 계쏙 그 수를 증가 (최대 64개 데이터 페이지 읽어 버퍼풀 저장)
      - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터 사용 -> 쿼리 빠르게 처리 가능
- 시스템 변수 이용해 InnoDB의 언제 read ahead 시작 할 지 임계 값 설정 가능
  - 디폴트 설정으로 충분, 데이터 웨어하우스용으로는 옵션을 더 낮게 설정해 빠르게 시작되도록 유도 가능
- Read Ahead는 풀 인덱스 스캔에서도 동일하게 사용된다.
  - SELECT COUNT(*) FROM EMPLOYEES;
    - 실제 실행 계획은 풀 인덱스 스캔 가능성이 높다.
    - 단순 레코드 건수 필요 쿼리시 용량이 작은 인덱스 선택이 디스크 읽기 횟수 줄일 수 있다.
  - SELECT * FROM EMPLOYEES;
    - 레드코에만 있는 컬럼 필요시 풀 테이블 스캔을 한다.
```

### 9.2.2 병렬 처리
```text
- 8.0부터 용도가 한정돼 있지만, 쿼리의 병렬 처리 가능
  - 하나의 쿼리를 여러 스레드가 작업을 나누어 동시 처리
  - 여러 스레드가 각각 쿼리 처리하는 것은 MYSQL 서버 시작 때 부터 가능했다.
  - 시스템 변수를 통해 하나의 쿼리 최대 몇개 스레드 이용 할 지 변경 가능
  - 아무런 WHERE 조건 없이 단순 테이블 전체 건수 가져오는 쿼리만 병렬 처리 가능!
    - SET SESSION innodb_parallel_read_threads=1; // 2; 4; 8;
    - SELECT COUNT(*) FROM EMPLOYEES;
  - 병렬 처리용 스레드 개수를 CPU 코어 개수를 넘어서면 성능 저하 유발되니 주의
```

### 9.2.3 ORDER BY 처리 (Using filesort)
```text
- 레코드 정렬 요건은 대부분 조회 쿼리에 포함, 정렬 처리 방법은 인덱스 이용과 Filesort라는 별도 처리 방법으로 나뉜다.
```

|               |                                  장점                                  |                                                  단점                                                  |
|:-------------:|:--------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|
|    인덱스 이용     |             C,U,D 쿼리 실행시 이미 인덱스가 정렬되어 순서대로 읽기만 되서 매우 빠름              |  C, U, D 작업 시 부가적 인덱스 추가/삭제 작업 필요<br/>인덱스 때문에 디스크 공간 더 필요<br/>인덱스 개수가 늘어날수록 InnoDB 버퍼풀을 위한 메모리 더 필요  |
|  Filesort 이용  |  인덱스 생성하지 않아도 된다.<br/>정렬 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.  |                            정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상이 많을 수록 응답 속도가 느리다.                            |

```text
- 레코드 정렬시 항상 "Filesort" 정렬 작업을 하는 것은 아니고 아래와 같은 이유로 모든 정렬을 인덱스 이용하도록 튜닝하기란 불가능하다.
  1. 정렬 기준이 너무 많아 요건 별 모두 인덱스 생성이 불가능
  2. GROUP BY, DISTINCT 처리 결과를 정렬해야 하는 경우
  3. UNION 결과와 같이 임시 테이블 결과를 다시 정렬해야 하는 경우
  4. 랜덤하게 결과 레코드를 가져와야 하는 경우

- Mysql -> 인덱스 이용하지 않고 별도 정렬 처리 수행 여부는 실행 계획의 Extra 컬럼에 "Using filesort"로 판단 가능
```

#### 9.2.3.1 소트 버퍼
```text
- MYSQL은 정렬 수행을 위해 별도 메모리 공간 할당 받아 사용, 그 공간을 소트 버퍼(Sort buffer)라고 한다.
- 정렬이 필요한 경우에만 할당되고, 버퍼의 크기는 정렬 대상 레코드 크키에 따르 가변적으로 증가 (최대 사용은 시스템 변수 설정)
- 소트 버퍼 메모리 공간은 쿼리 실행 완료 후 즉시 시스템으로 반납

- 정렬이 왜 문제가 될까?
  - 정렬 대상 레코드 
    - 소량 -> 소트 버퍼만으로 빠르게 정렬 처리 가능
    - 정렬 대상 > 소트 버퍼 할당 공간 
      - 레코드 여러 조각 나눠 처리 -> 임시 저장을 위해 디스크 사용
      - 메모리의 소트 버퍼 정렬 수행 -> 결과를 임시로 디스크에 기록 

- 정렬
  1. 메모리 소트 버퍼 정렬 수행
  2. 결과 임시로 디스크 기록
  3. 레코드 가져온다.
  4. 다시 정렬 후 반복적으로 디스크에 임시 저장
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬 수행 (멀티 머지)
  - 위 작업들이 모두 디스크의 I/O 유발
  - 소트 버퍼 크게 설정해도 큰 차이를 보이지 않는다. (256KB ~ 8MB 사이에서 최적 성능)
  
- 
```