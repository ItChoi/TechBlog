# 09 옵티마이저와 힌트
```text
- MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 결과를 만들어내는 방법은 매우 다양하다.
- 다양한 방법 중 최적, 최소의 비용을 위한 결정이 필요하다.
- MYSQL은 쿼리 최적 실행을 위해 각 테이블에 어떤 분포로 저장돼 있는지 통계 정보 참조하고, 기본 데이터를 비교해 최적의 실행 계획
수립 작업이 필요하다.
  - 대부분 DBMS에서는 옵티마이저가 이러한 기능을 담당한다.

- MYSQL -> EXPLAIN 명령 -> 쿼리 실행 계획 확인 가능
  - 상당히 많은 정보 출력 -> 제대로 이해하기 위해 옵티마이저 실행 최적화에 대한 어느정도 지식이 있어야 한다.
```

## 9.1 개요
```text
- 옵티마이저는 복잡하지만, 실행 계획을 이해할 수 있어야 불합리한 부분을 찾아내고 더 최적화된 실행 계획 수립 유도 가능
```

### 9.1.1 쿼리 실행 절차
```text
- MYSQL 서버 -> 쿼리 실행 과정 크게 세 단계
  1. 사용자 요청 쿼리 문장을 잘게 쪼개 MYSQL 서버가 이해 가능한 수준으로 분리(파스 트리)
    - SQL 파싱, SQL 파서 모듈로 처리 
    - 쿼리 문법 에러 체크
    - 파스 트리가 만들어지고 SQL 파스 트리를 이용해 쿼리 실행
    - MYSQL 엔진에서 처리
  2. SQL 파싱 정보(파스 트리) 확인
    - 어떤 테이블 부터 읽을지 선택
    - 어떤 인덱스를 이용하여 테이블 읽을지 선택
    - SQL 파스 트리 참조하여 다음 내용들을 처리
      1. 불필요 조건 제거, 복잡 연산 단순화
      2. 여러 테이블 조인 -> 어떤 순서로 테이블 읽을지 결정
      3. 각 테이블 조건, 인덱스 통계 정보를 이용해 사용할 인덱스 결정
      4. 임시 테이블에 가져온 레코드 넣고, 가공 여부 결정
    - 최적화 및 실행 계획 수립 단계
    - MYSQL 서버 옵티마이저에서 처리
    - 이 단계 완료시 "실행 계획"이 만들어진다.
  3. 결정된 읽기 순서나 선택된 인덱스를 이용해 스토리지엔진으로부터 데이터를 가져온다.
    - 가져온 데이터 -> 조인, 정렬 작업 수행
    - MYSQL 엔진과 스토리지 엔진 동시 참여하여 처리
```

### 9.1.2 옵티마이저의 종류
```text
- 비용 기반 최적화 (Cost-based optimizer, CBO) - 현재 대부분 DBMS 선택
  - 쿼리 처리를 위해 여러 방법을 만들고, 각 단위 작업 비용 정보, 대상 테이블 예측된 통계 정보 이용해 실행 계획별 비용 산출
  - 산출된 실행 방법 별 비용 최소 처리 방식 선택해 최종 쿼리 실행
  - 대부분 RDBMS가 채택 (MYSQL 포함)
- 규칙 기반 최적화 (Rule-based optimizer, RBO) - 초기 오라클 DBMS 많이 사용
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저 내장 우선순위에 따라 실행 계획 수립
  - 같은 쿼리에 대해서 항상 같은 실행방법을 만든다.
  - 데이터 분포도가 매우 다양한 요즘은 사용하지 않는다.
```

## 9.2 기본 데이터 처리
```text
- 데이터 정렬, 그루핑 등 기본 데이터 가공 기능은 결과물이 같더라도 RDBMS 별로 결과를 만들어내는 과정은 천차만별
```

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
```text
- 옵티마이저 -> 풀 테이블 스캔 선택 조건
  1. 테이블 레코드 건수가 너무 작은 경우 (일반적으로 테이블이 페이지 1개로 구성)
  2. WHERE절 또는 ON절에 인덱스 이용할 수 있는 적절 조건이 없는 경우
  3. 인덱스 레인지 스캔 사용 가능 -> 옵티마이저 판단에 조건 일치 레코드 건수가 너무 많은 경우 (B-Tree를 샘플링해 조사한 통계 정보 기준)
- 대부분 DBMS의 풀 테이블 스캔 실행 시 한꺼번에 여러 개의 블록, 페이지를 읽어오는 기능 내장
  - 시스템 변수로는 없기에 하나씩 읽어오는 걸로 착각 할 수 있다. (MyISAM 스토리지 엔진은 맞는 말)
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업 자동 시작
  - Read ahead: 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해 요청 전 미리 디스크를 읽어 InnoDB 버퍼풀에 저장
  - 테이블 풀 스캔시
    - 처음 몇 개 데이터 페이지는 포그라운드 스레드로 읽기 실행
    - 특정 시점부터 백그라운드 스레드가 읽기 실행 
      - 한 번에 4 ~ 8개 페이지를 읽으며 계쏙 그 수를 증가 (최대 64개 데이터 페이지 읽어 버퍼풀 저장)
      - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터 사용 -> 쿼리 빠르게 처리 가능
- 시스템 변수 이용해 InnoDB의 언제 read ahead 시작 할 지 임계 값 설정 가능
  - 디폴트 설정으로 충분, 데이터 웨어하우스용으로는 옵션을 더 낮게 설정해 빠르게 시작되도록 유도 가능
- Read Ahead는 풀 인덱스 스캔에서도 동일하게 사용된다.
  - SELECT COUNT(*) FROM EMPLOYEES;
    - 실제 실행 계획은 풀 인덱스 스캔 가능성이 높다.
    - 단순 레코드 건수 필요 쿼리시 용량이 작은 인덱스 선택이 디스크 읽기 횟수 줄일 수 있다.
  - SELECT * FROM EMPLOYEES;
    - 레드코에만 있는 컬럼 필요시 풀 테이블 스캔을 한다.
```

### 9.2.2 병렬 처리
```text
- 8.0부터 용도가 한정돼 있지만, 쿼리의 병렬 처리 가능
  - 하나의 쿼리를 여러 스레드가 작업을 나누어 동시 처리
  - 여러 스레드가 각각 쿼리 처리하는 것은 MYSQL 서버 시작 때 부터 가능했다.
  - 시스템 변수를 통해 하나의 쿼리 최대 몇개 스레드 이용 할 지 변경 가능
  - 아무런 WHERE 조건 없이 단순 테이블 전체 건수 가져오는 쿼리만 병렬 처리 가능!
    - SET SESSION innodb_parallel_read_threads=1; // 2; 4; 8;
    - SELECT COUNT(*) FROM EMPLOYEES;
  - 병렬 처리용 스레드 개수를 CPU 코어 개수를 넘어서면 성능 저하 유발되니 주의
```

### 9.2.3 ORDER BY 처리 (Using filesort)
```text
- 레코드 정렬 요건은 대부분 조회 쿼리에 포함, 정렬 처리 방법은 인덱스 이용과 Filesort라는 별도 처리 방법으로 나뉜다.
```

|               |                                  장점                                  |                                                  단점                                                  |
|:-------------:|:--------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|
|    인덱스 이용     |             C,U,D 쿼리 실행시 이미 인덱스가 정렬되어 순서대로 읽기만 되서 매우 빠름              |  C, U, D 작업 시 부가적 인덱스 추가/삭제 작업 필요<br/>인덱스 때문에 디스크 공간 더 필요<br/>인덱스 개수가 늘어날수록 InnoDB 버퍼풀을 위한 메모리 더 필요  |
|  Filesort 이용  |  인덱스 생성하지 않아도 된다.<br/>정렬 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.  |                            정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상이 많을 수록 응답 속도가 느리다.                            |

```text
- 레코드 정렬시 항상 "Filesort" 정렬 작업을 하는 것은 아니고 아래와 같은 이유로 모든 정렬을 인덱스 이용하도록 튜닝하기란 불가능하다.
  1. 정렬 기준이 너무 많아 요건 별 모두 인덱스 생성이 불가능
  2. GROUP BY, DISTINCT 처리 결과를 정렬해야 하는 경우
  3. UNION 결과와 같이 임시 테이블 결과를 다시 정렬해야 하는 경우
  4. 랜덤하게 결과 레코드를 가져와야 하는 경우

- Mysql -> 인덱스 이용하지 않고 별도 정렬 처리 수행 여부는 실행 계획의 Extra 컬럼에 "Using filesort"로 판단 가능
```

#### 9.2.3.1 소트 버퍼
```text
- MYSQL은 정렬 수행을 위해 별도 메모리 공간 할당 받아 사용, 그 공간을 소트 버퍼(Sort buffer)라고 한다.
- 정렬이 필요한 경우에만 할당되고, 버퍼의 크기는 정렬 대상 레코드 크키에 따르 가변적으로 증가 (최대 사용은 시스템 변수 설정)
- 소트 버퍼 메모리 공간은 쿼리 실행 완료 후 즉시 시스템으로 반납
- 세션(로컬) 메모리 영역에 해당 (글로볼 메모리 영역, 세션 메모리 영역)
- 커넥션이 많거나 정렬 작업이 많을수록 소비되는 메모리 공간이 커진다.
  - 메모루 여유 공간이 없을 경우 -> 프로세스 강제 종료 (OOM-Killer: 메모리 가장 많이 사용 중인 프로세스 강제 종료 - MYSQL 서버가 1순위 종료)
- 빠른 성능을 얻을순 없지만 디스크 I/O 사용량을 줄일 수 있다.

- 정렬이 왜 문제가 될까?
  - 정렬 대상 레코드 
    - 소량 -> 소트 버퍼만으로 빠르게 정렬 처리 가능
    - 정렬 대상 > 소트 버퍼 할당 공간 
      - 레코드 여러 조각 나눠 처리 -> 임시 저장을 위해 디스크 사용
      - 메모리의 소트 버퍼 정렬 수행 -> 결과를 임시로 디스크에 기록 

- 정렬
  1. 메모리 소트 버퍼 정렬 수행
  2. 결과 임시로 디스크 기록
  3. 레코드 가져온다.
  4. 다시 정렬 후 반복적으로 디스크에 임시 저장
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬 수행 (멀티 머지)
  - 위 작업들이 모두 디스크의 I/O 유발
  - 소트 버퍼 크게 설정해도 큰 차이를 보이지 않는다. (256KB ~ 8MB 사이에서 최적 성능)
```

#### 9.2.3.2 정렬 알고리즘
```text
- 정렬 모드 - 옵티마이저 트레이스 기능으로 확인 가능
  - 투 패스: 레코드 정렬시 레코드 전체를 소트 버퍼에 담는다.
    - 테이블을 두번 읽어야 한다.
    - 레코드 건수가 상당히 많은 경우 효율적
  - 싱글 패스: 정렬 기준 컬럼만 소트 버퍼에 담는다.
    - 투 패스에 비해 더 많은 소트 버퍼 공간이 필요
    - 레코드 건수가 작은 경우 빠른 성능
- 최신 버전은 싱글패스를 사용 (특정 상황에는 투 패스를 사용)
  - 특정 상황
    1. 레코드 크기가 시스템 변수에 설정된 소트버퍼 공간보다 클 때
    2. BLOB, TEXT 타입 컬럼이 SELECT 포함될 때
```

##### 9.2.3.2.1 싱글 패스 정렬 방식
```text
- 소트 버퍼에 정렬 기준 컬럼을 포함한 SELECT 컬럼을 전부 담아 정렬 수행
```

##### 9.2.3.2.2 투 패스 정렬 방식
```text
- 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아 정렬 수행
```

#### 9.2.3.3 정렬 처리 방법
```text
- 쿼리 ORDER BY 사용시 세 가지 처리 방식 (아래로 갈 수록 처리 속도 저하)
  1. 인덱스 사용 정렬 (실행 계획 Extra: 별됴 표기 없음)
  2. 조인에서 드라이빙 테이블만 정렬 (실행 계획 "Using filesort" 메시지 표기)
  3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 (실행 계획 "Using temporary; Using filesort" 메시지 표기)
- 옵티마이저
  - 정렬 처리를 위해 인덱스 사용할지 선 검토 
    - 인덱스 사용: 사용시 Filsort 과정 없이 인덱스를 순서대로 읽어 결과 반환
    - 인덱스 미사용: WHERE 조건 일치 레코드 검색해 정렬 버퍼에 저장 후 정렬 처리(Filesort)
      - 이 때 MYSQL 옵티마이저는 정렬 대상 레코드 최소화를 위해 두 가지 중 하나를 선택
        1. 조인의 드라이빙 테이블만 정렬 후 다음 조인 수행
          - 일반적으로 조인 수행 후 레코드 건수와 크기는 배수로 늘어나기에 이 방법이 효율적 
        2. 조인 종료 후 일치 레코드 모두 가져온 후 정렬 수행
```

##### 9.2.3.3.1 인덱스를 이용한 정렬
```text
 JOIN시 먼저 액세스 돼서 ACCESS PATH를 주도하는 테이블을 드라이빙테이블이라고 한다. 
즉, 조인시 먼저 액세스되는 쪽을 드라이빙 테이블(DRIVING TABLE, OUTER TABLE)이라고 하며,
나중에 액세스 되는 테이블을 드리븐 테이블(DRIVEN TABLE, INNER TABLE)이라고 한다.

- 인덱스 이용 정렬을 위해서는 ORDER BY 명시 컬럼이 제일 먼저 읽는 테이블에 속하고 순서대로 생성된 인덱스가 있어야 한다.
- WHERE절 첫 번째 컬럼이 ORDER BY 컬럼과 같은 인덱스를 사용할 수 있어야 한다. 
- 해시 인덱스, 전문 검색 인덱스 등은 인덱스 이용 정렬 사용 불

 ORDER BY 절을 넣지 않고 자동 정렬되더라도, 생략하는 것은 좋지 않은 선택이다. MYSQL 서버는 생략하지 않더라도 부가적으로 불필요한 정렬 작업을
수행하지 않는다. 명시한다고 해서 쿼리 작업량이 더 늘지는 않는다. 
 또한 어떤 이유로 쿼리 실행 계획 변경시 ORDER BY 명시하지 않으면 기대했던 순서로 결과를 얻을 수 없을 수 있다. 따라서 ORDER BY 없이 자동 정렬 되더라도
ORDER BY를 명시하도록 하자.
```

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
```text
 일반적으로 조인 수행시 레코드 건수와 크기가 늘어난다. 따라서 조인 실행 전 테이블의 레코드를 먼저 정렬 후 조인 실행하는 것이 정렬의 차선책이 된다.
따라서 첫 째 테이블 (조인의 경우 드라이빙 테이블) 컬럼만으로 ORDER BY 절을 작성해야 한다.
```
```sql
SELECT *
FROM EMPLOYEES e, SALARIES s
WHERE 
    s.emp_no = e.emp_no
    AND e.mp_no BETWEEN 1002 AND 1010
ORDER BY e.last_name; -- 첫 째 테이블로 정렬
```
```text
 우선 WHERE 절의 두 가지 조건에 의해 옵티마이저는 EMPLOYESS 테이블을 드라이빙 테이블로 선택할 것이다.
1. BETWWEN 조건은 드라이빙 테이블의 PK를 이용해 검색하여 작업량을 줄일 수 있다. 
2. 드리븐 테이블(SALARIES)의 조인 컬럼인 EMP_NO 컬럼에 인덱스가 있다.

 검색은 인덱스 레인지 스캔이 가능하지만, ORDER BY절은 드라이빙 테이블의 PK와 전혀 연관이 없으므로 인덱스 이용 정렬 불가능
하지만 드라이빙 테이블의 컬럼이므로 옵티마이저는 드라이빙 테이블만 검색해서 정렬 후 그 결과와 드리븐 테이블을 조인한다.
EMPLOYEES 테이블 -> 소트버퍼 임시 저장 -> 소트 버퍼 정렬 결과와 SALARIES 테이블 조인 (?)
```

##### 9.2.3.3.3 임시 테이블을 이용한 정렬
```text
 단 하나의 테이블만으로 SELECT 정렬 하는 경우 임시 테이블이 필요하지 않다. (Q: 임시 테이블, 뷰 테이블 차이)
그러나 두 개 이상의 테이블 조인 후 결과 정렬시 임시 테이블이 필요할 수 있다. 드라이빙 테이블만 정렬이 필요한 경우 임시 테이블이 필요 없지만,
그 외에는 항상 조인 결과를 임시 테이블에 저장하고 결과를 다시 정렬하는 과정이 필요하다.

- 정렬 대상 레코드 건수가 가장 많기 때문에 정렬 방법 중 가장 느리다.
```
```sql
SELECT *
FROM EMPLOYESS e, SALARIES s
WHERE
    s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 1002 AND 1010
ORDER BY s.salary; -- 바로 위 쿼리와 정렬 대상만 다르다.  
```
```text
 ORDER BY 정렬 기준 컬럼이 드리븐 테이블 컬럼이다. 따라서 조인된 데이터로 정렬할 수 밖에 없다.
실행 계획에서 Extra에 "Using temporary; Using filesort" -> 조인 결과 임시 테이블 저장, 결과를 다시 정렬 처
```

##### 정렬 처리 방법의 성능 비교
```text
 주로 웹 서비스용 쿼리는 ORDER BY와 함께 LIMIT이 거의 필수시 되는 경향이 있다.
LIMIT은 처리 결과 일부만 가져오기에 MYSQL 서버가 처리 작업량을 줄이는 역할을 하는데, ORDER BY나 GROUP BY 작업은
WHERE 조건 만족 결과를 가져온 후 LIMIT 할 수 없다. 즉, 조건 만족 레코드를 모두 가져와 정렬, 그루핑 작업 실행 후 비로소 LIMIT 제한 가능
따라서 WHERE 조건의 인덱스를 잘 설계해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생

- 쿼리에서 인덱스를 사용하지 못하는 정렬, 그루핑 작업이 느리게 작동 하는 이유
  - 쿼리 처리 방식 "스트리밍 처리"와 "버퍼링 처리" 두 가지 방식 이해 필요 (Q: 디폴트 방식 무엇?, 테이블, 쿼리 마다 지정 가능?) 
```

###### 9.2.3.3.4.1 스트리밍 방식
```text
- 조건에 일치하는 레코드가 검색될 때 마다 즉시 클라이언트로 전송해주는 방식
  - 클라이언트는 쿼리 요청 후 바로 첫 번째 레코드를 전달 받는다.
  - 마지막 레코드를 언제 받을 지 알 수 없다 (그다지 중요하지 않다.)
- 클라이언트는 MYSQL서버가 일치하는 레코드 찾는 즉시 전달받아 데이터를 받는 동시에 데이터 가공 작업 시작 가능
- 웹 서비스 같은 OLTP(Online transaction processing) 환경에서는 쿼리 요청시 첫 레코드 응답 시간이 중요하다. 따라서 레코드 양과 관계 없이 빠른 응답 시간 보장
- LIMIT처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여준다.
- 풀 테이블 스캔 결과가 버퍼링, 필터링 과정 없이 클라이언트로 스트리밍

 스트리밍 처리는 클라이언트 도구, API에 따라 방식 차이가 있다.
대표적으로 JDBC 라이브러리는 MYSQL 서버는 레코드를 익자마자 클라이언트로 결과 전달 -> JDBC는 MYSQL 서버로부터 받은 레코드 내부 버퍼에 담아둔다. 
마지막 레코드 전달 받은 후 클라이언트에게 전달한다. 즉 MYSQL 서버는 스트리밍 방식 처리 후 반환하지만 JDBC 라이브러리가 버퍼링 하는 것이다.
 JDBC 라이브러리가 자체적 레코드 버퍼링 하는 이유는 전체 처리 시간이 짧고, MYSQL 서버와의 통신 횟수가 적어 자원 소모가 줄어들기 떄문이다.
MYSQL 서버와 JDBC 라이브러리는 대화형이 아니라, 무조건 전송만 하고, 전송되는 데이터를 받아서 저장하기 때문에 불필요한 네트웤 요청 최소화되어 전체 처리량이 뛰어난다.

 하지만 JDBC 버퍼링 처리는 기본 작동 방식이고, 아주 대랴의 데이터를 가져와야 할 때는 MYSQL 서버와 JDBC 간의 전송 방식을 스트리밍 방식으로 변경 가능

 ORDER BY 처리 방식 중 인덱스 사용 정렬 방식만 스트리밍 형태, 드라이빙 테이블 정렬과 트리븐 테이블 정렬은 모두 버퍼링된 후 정렬한다.

```

###### 9.2.3.3.4.2 버퍼링 방식
```text
 ORDER BY, GROUP BY 등의 처리는 쿼리 결과가 스트리밍되는 것이 불가능하다.
우선 WHERE 조건 일치하는 모든 레코드를 가져온 후 정렬, 그루핑해서 차례대로 보내야 하기 때문이다.
MYSQL 서버에서는 모든 레코드 검색하고 정렬 작업 하는 동안 클라이언트는 기다려야하기 때문에 응답 속도가 늦다.

- 쿼리 결과를 모아서 MYSQL 서버에서 일갈 가공 후 모든 결과를 스토리지 엔진으로부터 가져올 때 까지 기다려야 한다.
  - LIMIT 건수 제한 조건이 있어도 성능 향상에 별로 도움이 되지 않는다. -> 네트웍 전송 레코드 건수를 줄일 수 있지만 MYSQL 서버 작업량에는 그다지 변화 없다.
```

```sql
-- 조인과 함께 ORDER BY, LIMIT 사용시 정렬 처리 방볍 별로 차이를 알아보자.
-- t1 테이블이 100건, t2 테이블이 1,000건 (t1 한 건당 t2 열건 가정)
SELECT *
FROM TB_TEST1 t1, TB_TEST@ t2
WHERE t1.col1 = t2.col1
ORDER BY t1.col2
LIMIT 10;
```
####### t1 테이블이 드라이빙되는 경우
| 정렬 방법 | 읽어야 할 건수               | 조인 횟수                  | 정렬 대상 건수                      |
|:-----|:-----------------------|:-----------------------|:------------------------------|
|인덱스 사용| t1: 1건<br/>t2: 10건     | 1번                     | 0건                            |
|조인 드라이빙 테이블만 정렬| t1: 100건<br/>t2: 10건   | 1번                     | 100건 (t1 레코드 건수만큼 정렬 필요)      |
|임시 테이블 사용 후 정렬| t1: 100건<br/>t2: 1000건| 100번 (t1레코드 건수만큼 조인 발생| 1,000건 (조인된 결과 레코드 건수를 전부 정렬) |
####### t2 테이블이 드라이빙되는 경우
| 정렬 방법 | 읽어야 할 건수               | 조인 횟수                  | 정렬 대상 건수                      |
|:-----|:-----------------------|:-----------------------|:------------------------------|
|인덱스 사용| t2: 10건<br/>t1: 10건    | 10번                    | 0건                            |
|조인 드라이빙 테이블만 정렬| t2: 1000건<br/>t1: 10건  | 10번                    | 1000건 (t2 레코드 건수만큼 정렬 필요)     |
|임시 테이블 사용 후 정렬| t2: 1000건<br/>t1: 100건 | 100번 (t2레코드 건수만큼 조인 발생 | 1,000건 (조인된 결과 레코드 건수를 전부 정렬) |

```text
 드라이빙 테이블 선정도 중요하지만, 정렬 방식에 따른 처리는 더 큰 성능 차이를 만든다. 따라서 가능하다면 인덱스 사용 정렬을 유도하고, 
최소한 드라이빙 테이블 정렬로 유도하는 것도 좋은 튜닝 방법이다.

 인덱스를 사용하지 못해 filesort 하는 경우의 쿼리에서 limit은 모든 레코드를 가져와 필요한 순서대로 정렬해서 limit만큼 정렬치 채워지면 정렬을 반환한다.
따라서 도움은 되지만, MYSQL 서버는 정렬을 위해 퀵 소트와 힙 소트 알고리즘을 사용하는데 LIMIT 10 정렬을 위해 더 많은 작업이 필요하다.
 결론: 인덱스 사용하지 않는 쿼리 페이징의 경우 LIMIT 5 ~ 10건 조회해도 쿼리가 기대만큼 아주 빨라지지는 않는다.
```

#### 9.2.3.4 정렬 관련 상태 변수
```text
 MYSQL 서버는 명령어를 통해 몇 건의 레코드를 정렬 수행했고, 소트 버퍼 간의 병합 작업 등을 확인할 수 있다.
- FLUSH STATUS;
- SHOW STATUS LIKE 'Sort%';
```

### 9.2.4 GROUP BY 처리
```text
- ORDER BY와 GROUP BY는 스트리밍된 처리를 할 수 없게한다.
- GROUP BY에 사용된 조건은 인덱스 처리 불가하므로 HAVING절 튜닝을 위한 인덱스 생성 등의 작업이 필요없다.
  - GROUP BY 작업 자체도 인덱스 사용, 미사용으로 나뉜다.
  - 인덱스 타지 않는 GROUP BY는 임시 테이블을 사용한다.
```

#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
```text
 드라이빙 테이블(앞 테이블)의 컬럼만 이용해 그루핑 할 때 인덱스가 있다면 차례대로 읽으면서 그루핑 작업 수행하고 그 결과로 조인을 처리한다.
인덱스 사용하면 임시 테이블을 사용하지 않는다고 했지만, 그룹 함수 등의 그룹 값 처리를 위해 임시 테이블이 필요할 때도 있다. 
이 때는 쿼리 실행 계획 Extra에 "Using index for group-by", "Using temporary, Using filesort"가 표시되지 않는다.
```

#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
```text
- 루스(Loose) 인덱스 스캔은 인덱스를 건너 뛰며 필요한 부분만 읽어서 가져오는 것
  - Extra -> Using index for group-by 표시
```
```sql
# 루스 인덱스 스캔 예재 
# 인덱스 (emp_no, from_date)
EXPLAIN 
    SELECT emp_no
    FROM SALARIES
    WHERE from_date = '1985-03-01'
    GROUP BY emp_no
```
```text
 위에 예제의 WHERE 조건은 인덱스 레인지 스캔 방식 이용 할 수 없는 것 같지만, 인덱스 레인지 스캔 타입 이용 가능하다.
실제 실행 계획을 보면 Extra -> Using where; using index for group-by로 되어 있는 것을 확인 가능하다.

 그렇다면 위에 예제는 어떻게 인덱스 조건과 일치하지 않는데 이용이 가능할까? 실행 순서를 살펴보자.
1. (emp_no_ from_date) 인덱스를 차례대로 스캔하고 emp_no의 첫 번째 그룹 키(유일값) '10001'을 찾아낸다.
2. 인덱스에서 emp_no가 '10001'인 것 중 입력한 from_date를 가져오고 1번 단계와 조건을 합쳐 emp_no = ###, from_date = ### 조건으로 검색하는 것과 흡사
3. 다음 그룹 키 '10002' 값을 가져오고, 없으면 종료 있으면 2번 과정으로 돌아가서 반복 수행

- 프리픽스 인덱스는 루스 인덱스 스캔 사용 불가 (컬럼 값 앞쪽 일부분만으로 생성된 인덱스)
- 인덱스 레인지 스캔은 유니크한 값의 수가 많을수록 성능이 향상
- 루스 인덱스 스캔은 인덱스의 유니크한 값의 수가 적을수록 성능 향상
  - 분포도가 좋지 않은 인덱스일수록 더 빠른 결과 
  - 별도의 임시 테이블 필요하지 않다.
  
 8.0부터는 루스 인덱스 스캔과 동일 방식 작동하는 인덱스 스킵 스캔 최적화가 도입됐다. 
```

```sql
# 루스 인덱스 스캔 사용 여부는 복잡하다. 따라서 여러 패턴을 통해 연습이 필요하다.
# 인덱스 생성 (co1l, col2, col3)

# 루스 인덱스 스캔 사용 가능
SELECT col1, col2 FROM TEST GROUP BY col1, col2;
SELECT DISTINCT col1, col2 FROM TEST;
SELECT col1, MIN(col2) FROM TEST GROUP BY col1;
SELECT col1, col2 FROM TEST WHERE col1 < const GROUP BY col1, col2;
SELECT MAX(col3), MIN(col3), col1, col2 FROM TEST WHERE col2 > const GROUP BY col1, col2;
SELECT col2 FROM TEST WHERE col1 < const GROUP BY col1, col2;
SELECT col1, col2 FROM TEST WHERE col3 = const GROUP BY col1, col2;

# 루스 인덱스 스캔 사용 불가능
# MIN, MAX 외 집합 함수 사용은 루스 인덱스 스캔 사용 불가
SELECT col1, SUM(col2) FROM TEST GROUP BY col1;

# GROUP BY에 사용 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않아 사용 불가
SELECT col1, col2 FROM TEST GROUP BY col2, col3;

# SELECT 절 컬럼과 GROUP BY절 불일치로 사용 불가
SELECT col1, col3 FROM TEST GROUP BY col1, col2;
```

#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
```sql
# GROUP BY 기준 컬럼이 드라이빙, 드리븐 테이블 존재 여부와 관계없이 인덱스를 타지 못할 때는 아래 방식으로 처리 된다.
# 쿼리 예제
EXPLAIN 
    SELECT e.last_name, AVG(s.salary)
    FROM EMPLOYEES e, SALARIES s
    WHERE s.emp_no = e.emp_no
    GROUP BY e.last_name
```
```text
 위 쿼리 실행계획 Extra - "Using temporary" 메시지 표시되고 임시 테이블이 사용된다.
임시 테이블 사용 이유는 인덱스를 전혀 사용 할 수 없는 GROUP BY이기 때문이다. 
 실행 계획 Extra - Using filesort가 표시 되지 않았다. 이유는 8.0 전에는 GROUP BY 포함 쿼리는 그루핑 컬럼으로 묵시적인 정렬을 함께 수행
그래서 정렬을 수행하지 않는 경우 ORDER BY NULL이 필요했다. 크진 않지만 성능 향상을 볼 수 있었지만, 8.0부터는 추가하지 않아도 된다.
 8.0 부터는 묵시적인 정렬은 실행되지 않는다. GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 컬럼들로 구성된 유니크 인덱스를 가진 
임시 테이블을 만들어 중복 제거, 집합 함수 연산 수행한다. 즉, 위의 쿼리 처리를 위해서도 임시 테이블이 필요하다.
조인 결과를 한 건씩 가져와 임시 테이블 중복 체크를 하면서 등록, 수정을 실행, 즉 별도 정렬 작업 없이 처리된다.

 8.0 이상도 GROUP BY와 ORDER BY 같이 사용되는 경우 명시적으로 정렬 작업 수행한다.
위에 쿼리와 동일한 쿼리에 ORDER BY e.last_name이 추가된다면, 실행 계획 Extra - Using filesort도 같이 표시되는 걸 확인 가능하다.
```

### 9.2.5 DISTINCT 처리
```text
 DISTINCT는 집합 함수와 함께 사용되는 경우와 그렇지 않은 경우 영향을 미치는 범위가 달라지기 떄문에 같이 살펴볼 필요가 있다.
집합 함수와 DISTINCT가 같이 사용되는 경우 인덱스 사용하지 못할 때 항상 임시 테이블이 필요하다. 하지만 Extra - Using temporary가 표시되지 않는다.
```

#### 9.2.5.1 SELECT DISTINCT ...
```text
 단순히 유니크한 SELECT 레코드 조회를 위해 사용시 GROUP BY와 동일한 방식으로 처리된다.
특히 8.0부터 다음 아래 두 쿼리는 내부적으로 같은 작업 수행한다.
 DISTINCT 사용시 주의점은 당연하지만, 특정 컬럼만 유니크하게 하는 것이 아니라 레코드를 유니크하게 조회하는 것이다.   
에러도 나지 않고 MYSQL 서버는 의미 없이 사용된 괄호로 해석하고 제거하기에 오해의 여지가 생길 수 있다.
```
```sql
SELECT DISTINCT emp_no FROM SALARIES;
SELECT emp_no FROM SALARIES GROUP BY emp_no;
```

#### 집합 함수와 함께 사용된 DISTINCT
```text
 집합함수 내에서 사용된 경우 일반적인 SELECT DISTINCT와 다른 형태로 해석된다.
집합 함수 인자로 전달된 컬럼 값이 유니크한 것들만 가져오고 내부적으로 임시 테이블을 사용한다. 하지만 앞서 말했듯이 쿼리 실행 계획에 메시지로 뜨지 않는다.
```
```sql
# (1)
EXPLAIN 
    SELECT COUNT(DISTINCT s.salary)
    FROM EMPLOYEES e, SALARIES s
    WHERE
        e.emp_no = s.emp_no
        AND em.emp_no BETWEEN 1001 AND 1010;
        
# (2) 집합 함수 두 개 사용
SELECT
    COUNT(DISTINCT s.salary),
    COUNT(DISTINCT e.last_name)
FROM EMPLOYEES e, SALARIES S
WHERE
    e.emp_no = s.emp_no
    AND e.emp_no BETWEEN 1001 AND 1010;

# (3) 인덱스 이용 - 인덱스 풀 스캔 OR 인덱스 레인지 스캔 -> 임시 테이블 없이 최적화 처리 수행 가능
SELECT COUNT(DISTINCT emp_no) FROM EMPLOYEES;
SELECT COUNT(DISTINCT emp_no) FROM DEPT_EMP GROUP BY dept_no;
```
```text
 (1) 쿼리의 경우 드라이빙, 드리븐 테이블 조인 결과에서 salary 컬럼의 값만 저장하기 위해 임시 테이블을 만들어 사용한다.
임시 테이블의 salary 컬럼에 유니크 인덱스 생성되기에 레코드 건수가 많아지면 상당히 느려질 수 있는 형태이다.
 (2)의 경우 인덱스를 이용 할 수 없어서 두 개의 임시 테이블을 사용한다.
 (3)의 경우 인덱스를 이용해 임시 테이블 없이 최적화 처리 가능하다.
```

### 9.2.6 내부 임시 테이블 활용
```text
 MYSQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬 또는 그루핑 할 때 내부적인 임시 테이블을 사용한다.
여기서 내부적 임시 테이블이란 명령어로 만든 임시 테이블과는 다르다. (CREATE TEMPORARY TABLE ...)
 일반적으로 MYSQL 엔진의 임시 테이블은 처음에 메모리로 생성됐다가 테이블 크기가 커지면 디스크로 옮겨진다. 
물론 바로 디스크 임시테이블이 만들어지기도 한다.
 MYSQL 내부 임시 테이블은 다른 세션이나 쿼리에서 볼 수 없고 사용 불가능하고 쿼리 처리 완료 후 자동 삭제된다.
```

#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블
```text
 8.0 이전에는 임시 테이블이 메모리 사용시 MEMORY 스토리지 엔진을 사용하며, 디스크 저장시 MYISAM 스토리지 엔진 이용한다.
MEMORY 스토리지 엔진은 가변 길이 타입을 지원하지 않기에 메모리 생성시 타입의 최대 길이만큼 메모리 할당 사용하여 낭비가 심했고,
MYISAM은 트랜잭션일 지원하지 못한다는 문제점이 있었다.
 8.0 부터는 메모리는 TempTable이라는 스토리지 엔진 사용하고, 디스크 저장되는 임시 테이블은 InnoDB 스토리지 엔진 사용하도록 개선됐다.
또한 시스템 변수를 통해 MEMORY, TempTable 스토리지 엔진 중 선택 사용 가능 기본 값은 TempTable이다.
임시 테이블의 설정한 크키를 넘어서는 경우 임시 테이블을 디스크로 기록하는데, MYSQL 서버는 두 가지 방식중 하나를 선택한다.
'MMAP 파일로 디스크에 기록', 'InnoDB 테이블로 기록' 기본은 MMAP인데, 오버헤드가 더 적기 때문이다.
```

#### 9.2.6.2 임시 테이블이 필요한 쿼리
```text
1. ORDER BY와 GROUP BY가 명시된 컬럼이 다른 쿼리
2. ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
3. DISTINCT와 ORDER BY 동시 사용의 경우 또는 DISTINCT가 인덱스를 타지 못할 때
4. UNION이나 UNION DISTINCT가 사용된 쿼리
5. 쿼리 실행 계획 select_type이 DERIVED인 쿼리

 임시 테이블 사용 여부는 실행 계획 Extra - Using temporary 메시지 표시 확인하면 된다. 
그러나 위에 예제 2,3,4처럼 메시지가 표시되지 않는 경우도 있다.  
```

#### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우
```text
 일반적으로 내부 임시 테이블은 기본적으로 메모리에 생성되지만 아래의 경우 디스크 기반의 임시 테이블 사용한다.
1. UNION 또는 UNION ALL에서 SELECT 컬럼 중 길이가 512바이트 이상 컬럼이 있는 경우
2. GROUP BY나 DISTINCT 컬럼에서 512 바이트 이상인 크기의 컬럼이 있는 경우
3. 메모리 임시 테이블의 크기가 시스템 변수 설정 값보다 큰 경우

 8.0.13 이전 까진 BLOB나 TEXT 컬럼의 경우 임시 테이블을 디스크에 생성했다. 
하지만 메모리 임시 테이블 생성할 수 있게 개선됐다. (TempTable 스토리지 엔진을 사용할 경우)
```

#### 9.2.6.4 임시 테이블 관련 상태 변수
```text
 실행 계획 Extra - Using temporary를 통해 임시 테이블 사용 유무는 알 수 있지만, 메모리, 디스크 중 어디에서 처리 됐는지는 알 수 없다.
또한 하나만 표시 됐다고 임시 테이블이 하나만 사용된 것도 아니다. 이를 확인하기 위해서 명령어 'SHOW SESSION STATUS LIKE 'Created_tmp%;'로 확인 가능
```

## 9.3 고급 최적화
```text
 MYSQL 옵티마이저 실행 계획 수립할 때 통계 정보와 옵티마이저 옵션을 결합해 최적 실행 계획을 수립한다.
옵티마이저 옵션은 크게 조인 관련 옵션과 옵티마이저 스위치로 구분한다. 조인이 많은 서비스에서는 알아야 하는 부분이고,
옵티마이저 스위치는 5.5부터 시작했고 MYSQL 고급 최적화 기능 활성화 제어 용도로 사용한다. 
```

### 9.3.1 옵티마이저 스위치 옵션
```text
- 시스템 변수로 제어하는데, 책 318 페이지 참고하기.
```

#### 9.3.1.1 MRR과 배치 키 액세스 (mrr & batched_key_access)
```text
- MRR (Multi-Range Read)
- 드라이빙 테이블 레코드를 한 건 읽어 드리븐 테이블들의 일치 레코드를 찾아 조인 수행 (MYSQL 서버 지금까지 지원하는 조인 방식)
  - 네스티드 루프 조인이라고 한다.
   
 MYSQL 서버의 내부 구조상 조인 처리는 MYSQL 엔진이 처리하지만, 실제 레코드 검색, 읽기는 스토리지 엔진이 담당한다. 
드라이빙 레코드 건별로 드리븐 테이블의 레코드 검색, 읽기 할 때 스토리지 엔진에서 최적화 수행를 할 수 없다.
 따라서 MYSQL 서버는 드라이빙 테이블 레코드를 읽고 드리븐 테이블과 조인을 즉시하지 않고 조인 대상을 버퍼링한다.
조인 버퍼에 레코드가 가득 차면 비로소 MYSQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한번에 요청한다.
 따라서 디스크의 데이터 페이지 읽기 최소화 가능, 이러한 읽기 방식을 MRR이라고 한다.
 
- 조인 쿼리 실행 계획 Extra -> Using Join buffer -> 조인 버퍼 사용한다는 의미
```

#### 9.3.1.2 블록 네스티드 루프 조인 (block_nested_loop)
```text
 MYSQL 서버의 사용의 대부분은 네스티드 루프인데, 조인 연결 컬럼 모두 인덱스가 있는 경우 사용된다.
```

```sql
-- 예제) EMPLOYEES where 조건 일치 레코드를 한 건 찾아서 SALARIES 테이블 일치 레코드 찾는 형태 조인
EXPLAIN
    SELECT
    FROM EMPLOYEES e
    INNER JOIN SALARIES s
        ON s.emp_no = e.emp_no
        AND s.from_date <= NOW()
        AND s.to_Date >= NOW()
    WHERE e.first_name = 'Amor';
```
```text
 위 예제는 프로그래밍 언어에서 마치 for문처럼 동작하는 것 같아서 네스티드 루프 조인이라 하는거 같다.
의사 코드 (Psuedo Code)
for (row1 IN employees) {
    for (row2 IN salaries) {
        if (condition_matched) return (row1, row2); 
    }
}

 드라이빙 테이블과 드리븐 테이블 조인시 인덱스를 이용할 수 없다면 테이블 풀 스캔을 하게 되는데,
옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스 이용할 수 있게 실행 계획을 수립한다.
하지만 인덱스를 이용하지 못할 땐 드라이빙 테이블의 레코드를 메모리 캐시에 저장 후 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리한다.
이 때 사용되는 메모리의 캐시를 조인 버퍼 (Join buffer)라고 한다.

- 8.0.18 버전부터 해시 조인 알고리즘 도입
  - 8.0.20 버전부터 블록 네스티드 루프 조인은 더이상 사용되지 않고 해시 조인 알고리즘 대체 사용!!!
    - 8.0.20 이후 버전 실행 계획 Extra - Using Join Buffer 메시지 표시되지 않을 수 있다.
```














































