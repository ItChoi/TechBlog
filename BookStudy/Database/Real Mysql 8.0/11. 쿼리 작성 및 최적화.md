# 11. 쿼리 작성 및 최적화
```text
 쿼리가 빠르게 동작하기 위해서는 어떻게 처리할지 예측할 수 있어야 한다.
데이터베이스를 통해 몇 십 배 성능 향상은 흔한 일이다. 따라서 쿼리를 어떻게 작성하고 처리 되는지 이해가 필요하다.
```

## 11.1 쿼리 작성과 연관된 시스템 변수
```text
 SQL 작성 규칙은 MYSQL 서버 시스템 설정에 따라 달라진다.
```

### 11.1.1 SQL 모드
```text
 sql_mode 시스템 설정은 여러 값을 설정할 수 있다.
테이블이 생성되고 데이터가 저장되면 그 이후로는 해당 시스템 설정을 바꾸지 않는 것이 좋다.
익숙하지 않다면 기본 값을 사용하자. 

- STRICT_ALL_TABLES & STRICT_TRANS_TABLES
  등록, 수정시 컬럼 타입과 다른 값이 들어오는 경우 자동으로 타입 변환을 수행한다.
 변환되기 어려운 경우 실행/에러도 결정 가능하다. 
 STRICT_ALL_TABLES: 모든 스토리지 엔진에 대해 엄격 모드 적용
 STRICT_TRANS_TABLES: 자동 변환을 막기 위해 서비스 적용 전 반드시 활성을 권장
 
- ANSI_QUOTES
  문자열 값(리터럴) 표현을 위해 홑따옴표, 쌍따옴표 동시 사용 가능
  
- ONLY_FULL_GROUP_BY
  5.7 까지는 기본 값이 비활성이지만, 8.0부터 기본 값이 활성이다.
 활성시 GROUP BY에 SELECT된 컬럼만 사용가능하다. 집계함수의 경우 명시되지 않더라도 사용가능하다.
 
- PIPE_AS_CONCAT
  ||는 OR 연산자와 같은 의미이지만, 이 옵션 설정시 문자열 연결 연산자(CONCAT)으로 사용 가능
  
- PAD_CHAR_TO_FULL_LENGTH
  기본적으로 CHAR 타입은 VARCHAR와 같이 유효 문자열 뒤 공백 문자 제거 후 반환되는데, 
  이 값의 설정을 통해 공백 문자 제거 없이 반환 가능하다.
  
- NO_BACKSLASH_ESCAPES
  설정시 역슬래시를 문자 이스케이프 용도로 사용하지 못한다.
  
- IGNORE_SPACE
  프로시저 이름 뒤 공백을 프로시저명으로 인식하지 않을 수 있도록 해준다.
  
- REAL_AS_FLOAT
  REAL -> DOUBLE에서 REAL -> FLOAT로 바뀐다.
  
- NO_ZERO_IN_DATE & NO_ZERO_DATE
  두 옵션 활성시 잘못된 날짜 형식 저장 불가능, 실제 존재 날짜만 저장 가능하다.
  
- ANSI
  최대한 SQL 표준에 맞게 동작하게 만들어준다.
  
- TRADITIONAL
  여러 옵션 조합
```

### 11.1.2 영문 대소문자 구분
```text
 MYSQL 서버는 설치된 운영체제에 따라 테이블명 대소문자 구분한다. DB나 테이블이 디스크의 디렉토리나 파일로 매핑되기 때문이다.
대소문자 구분 없애려면 lower_case_table_names 시스템 변수 설정을 하면 된다.
```

### 11.1.3 MySQL 예약어
```text
 테이블 생성시 항상 역따옴표(`)로 테이블이나 컬럼 이름을 감싸지 않은 상태로 생성하길 권장한다. 
```

## 11.2 매뉴얼의 SQL 문법 표기를 읽는 방법

## 11.3 MySQL 연산자와 내장 함수
```text
 MYSQL 전용 연산자가 있는데, 가능하면 SQL 가독성을 위해 ANSI 표준 연산자를 사용하길 권장한다.
```

### 11.3.1 리터럴 표기 문자열

#### 11.3.1.1 문자열 - 패스

#### 11.3.1.2 숫자 - 패스

#### 11.3.1.2 숫자 - 날짜
```text
 다른 DBMS에서 날짜 타입을 비교하거나 등록시 문자열 -> DATE 타입 변환 코드 필요하다.
그러나 MYSQL은 자동으로 DATE나 DATETIME 값으로 변환해준다.
```

#### 11.3.1.4 불리언
```text
 BOOL, BOOLEAN 타입은 TINYINT 타입에 대한 동의어일뿐이다.
BOOL 타입 뿐만 아니라 숫자 타입에도 적용 가능 (TRUE, FALSE)
즉 TRUE, FALSE는 정수로 매핑해서 사용한다. (0, 1)
BOOLEAN 타입을 꼭 사용해야 할 경우 ENUM 타입으로 관리
```

### 11.3.2 MYSQL 연산자

#### 11.3.2.1 동등(Equal) 비교(=, <=>)
```text
 동등 비교 =, <=>를 제공하는데, <=>는 NULL 비교까지 수행  
NULL은 ISNULL 연산자 이외에 비교 방법이 없다. 하지만 <=> (Null-Safe)를 통해 비교 NULL <=> NULL 비교 가능
NULL을 하나의 값으로 인식하교 비교
```

#### 11.3.2.2 부정 (Not-Equal) 비교 (<>, !=)
```text
 무엇을 사용해도 괜찮지만, 통일된 방식으로 사용하길 권장
```

#### 11.3.2.3 NOT 연산자 (!) - 패스

#### 11.3.2.4 AND(&&)와 OR(||) 연산자
```text
 오라클 ||는 문자를 연결한다. MYSQL에서는 OR 연산자로 사용가능한데, 시스템 변수를 통해 용도 변경 가능하다.
```

#### 11.3.2.5 나누기(/, DIV)와 나머지(%, MOD) 연산자 - 패스

#### 11.3.2.6 REGEXP 연산자
```text
 문자열 값이 어떤 패턴을 만족하는지 체크한다. RLIKE, REGEXP는 똑같은 비교를 수행한다.
```

#### 11.3.2.7 LIKE 연산자
```text
 LIKE 'start%' -> 인덱스 레인지 스캔을 통해 검색 가능 
 LIKE '%end' -> 인덱스 풀 스캔 방식
```

#### 11.3.2.8 BETWEEN 연산자
```text
 동등 조건이 아니라 크거나 같다, 같거나 크다기 때문에 모든 인덱스 범위 검색해야 한다.
BETWEEN은 범위 검색, IN은 여러 개를 동등 비교해서 성능을 최적화 할 수 있다.
```

#### 11.3.2.9 IN 연산자
```text
 IN은 여러개 값에 대해 동등 비교 연산을 수행한다. 즉 범위 검색이 아니라서 일반적으로 빠르게 처리된다.
IN 연산자는 두 형태를 구분해서 생각해볼 필요가 있다.
 1. 상수가 사용된 경우
   - IN (?, ?, ?)
 2. 서브쿼리가 사용된 경우 
   - IN (SELECT .. FROM ..)
```

```sql
-- 8.0까지는 IN 절에 튜플(레코드)을 사용하면서 항상 풀 테이블 스캔을 했었다.
SELECT *
FROM dept_no
WHERE (dept_no, emp_no) IN (('d001', '10017'), ('d002', 10144), ('d003', 10054));
```
```text
 위 쿼리에서 IN 절의 상숫 값이 단순 스칼라 값이 아니라 튜플이 사용됐다.
8.0 이전 버전까지 이런 쿼리 실행시 성능 문제가 생겨 일부러 쿼리를 쪼개어 여러 번 실행해야 했다. 
8.0부터 IN절에 튜플을 그대로 나열해도 인덱스 최적으로 사용 가능하도록 개선됐다.

 IN절 안에 서브쿼리가 들어간 경우 최적화가 매우 까다로운데, 8.0 전에는 최적화가 상당히 불안했다.
8.0부터 IN (subquery) 같은 세미 조인의 최적화가 많이 안정됐다.

 NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시된다. 동등이 아닌, 부정형 비교는 인덱스 범위 검색으로 사용될 수 없다.
NOT INT이 PK와 비교될 때 가끔 인덱스 레인지 스캔이 표시되는 경우가 있는데, InnoDB는 PK가 클러스터링 키이기 때문일 뿐
실제 IN과 효율적으로 실행되는 것이 아니다.
```

### 11.3.3 MySQL 내장 함수
```text
 기본 내장함수와, 사용자 정의 함수로 구분된다.
MySQL에서 제공하는 C/C++ API를 이용하여 사용자가 직접 함수를 만들어 추가 가능하다. 
 참고로 이 부분의 내장 함수는 프로시저나 스토어드 함수와는 의미가 다르다.
```

#### 11.3.3.1 NULL 값 비교 및 대체(IFNULL, ISNULL)
```text
 IFNULL의 경우 표현식의 값이 NULL인지 비교 후 NULL인 경우 다른 값으로 대체 가능하다.
 ISNULL의 경우 NULL 여부에 따라 TRUE(1), FALSE(0)을 반환한다. 
```

#### 11.3.3.2 현재 시각 조회(NOW, SYSDATE)
```text
 두 함수 모두 현재 시간을 반환하는 함수다. 그러나 작동 방식에 큰 차이가 있다.
SQL에서 모든 NOW()는 같은 값을 갖는다.
SYSDATE()의 경우 호출 시점에 따라 결과 값이 달라진다. (시간이 다르다.)

- SYSDATE는 두 가지 문제가 있다.
  1. 레플리카 서버에서 안정적으로 복제되지 못한다.
  2. 인덱스 효율적 사용 불가 - 호출마다 다른 값을 반환하므로 상수가 아니다. (매번 레코드마다 비교)

 따라서 SYSDATE는 사용하지 않는 편이 좋다. 이미 사용하고 있다면, 시스템 변수를 통해 문제점을 제거하거나 NOW와 동일하게 동작하도록 할 수 있다.
```

##### 11.3.3.3 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)
```text
- datetype -> 문자열 변환시 DATE_FORMAT() 함수 사용 (대소문자 구분 필요)
  - %Y: 4자리 연도
  - %m: 2자리 숫자 표시 월 (01 ~ 12)
  - %d: 2자리 숫자 표시 일자 (01 ~ 31)
  - %H: 2자리 숫자 표시 시 (00 ~ 23)
  - %i: 2자리 숫자 표시 분 (00 ~ 59)
  - %s: 2자리 숫자 표시 초 (00 ~ 59)
 문자열, 기타 방법 등은 DATETIME으로 자동 변환 가능한 형태가 있다. 그렇지 않은 경우 MYSQL 서버가 날짜 타입을 이해하도록 함수를 사용하여 명시해야 한다.
 
- 문자열 -> datetype 변환시 STR_TO_DATE() 함수 사용  
```

#### 11.3.3.4 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
```text
 특정 날짜를 더하거나 뺄 때 사용한다. DATE_ADD함수로 더하거나 뺼 수 있기에 SUB은 크게 필요하지 않다.
```

##### 11.3.3.5 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
```text
 1970-01-01 00:00:00으로부터 경과된 초를 반환한다. 
```

##### 11.3.3.6 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)
```text
 RPAD, LPAD는 문자열 좌, 우에 문자를 덧붙일 수 있다.
 RTRIM, LTRIM, TRIM는 공백 문자 제거 함수이다.
```

##### 11.3.3.7 문자열 결합(CONCAT)
```text
 여러개 문자열을 연결해서 하나의 문자열로 반환하는 함수이다. 숫자는 자동 변환 후 연결한다.
따라서 의도된 변환이 아닌 경우 명시적 CAST 함수 사용하는 것이 안전하다.
```

##### 11.3.3.8 GROUP BY 문자열 결합(GROUP_CONCAT)
```text
 COUNT, MAX, MIN과 같은 그룹 함수 중 하나다.
주로 GROUP BY에서 사용하지만, 없이 사용하는 경우 단 하나의 결과 값을 만들어낸다.

 값으 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하고, 중복 제거 후 연결하는 것도 가능하므로 유용하다.
지정한 컬럼의 값을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 
지정 크기 초과시 WARNING 발생한다. JDBC에서 실행될 때 경고가 아니라 에러 취급되어 쿼리 실패한다. 따라서 초과하지 않게 주의!
버퍼의 기본 크기는 1KB고 당연히 시스템 변수로 설정 가능하다.
```

#### 11.3.3.9 값의 비교와 대체(CASE WHEN ... THEN ... END)

#### 11.3.3.10 타입의 변환(CAST, CONVERT)
```text
 Prepared Statemet를 제외하면 SQL은 텍스트(문자열) 기반 작동 - 모든 입력 값은 문자열 취급
따라서 명시적 타입 변환이 필요한 경우 CAST를 사용한다. CONVERT도 CAST와 거의 비슷하고, 인자 사용 규칙만 다르다.
```

##### 11.3.3.11 이진값과 16진수 문자열(Hex String) 변환(HEX, UNHEX)

##### 11.3.3.12 암호화 및 해시 함수(MD5, SHA, SHA2)
```text
 MD5와 SHA 모두 비대칭형 암호화 알고리즘이다. 인자로 전달한 문자열을 지정된 비트 수의 해시 값을 만들어낸다.
```

##### 11.3.3.13 처리 대기(SLEEP)
```text
 SQL 개발이나 디버깅 용도로 잠깐 대기하거나 쿼리 실행 시간을 유지하고자 할 때 사용한다.
```

##### 11.3.3.14 벤치마크(BENCHMARK)
```text
 SLEEP과 같이 디버깅이나 간단한 함수 성능 테스트용으로 유용하다.
실제 쿼리와 벤치마크 함수 사용은 차이가 있다.
```

##### 11.3.3.15 IP 주소 변환(INET_ATON, INET_NTOA)
```text
 IP는 부호 없는 정수다. 그러나 대부분 VARCHAR(15)로 '.'까지 같이 저장한다. 문자열로 저장된 IP 주소는 저장 공간을 훨씬 많이 필요로 한다.
많은 DBMS에서 IP 주소를 저장하는 타입을 별도 제공하지 않는다.
 MYSQL에서는 INET_NTOA를 이용하여 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공한다.
INET6_ATON, INET6_NTOA응 이용하면 IPv6 주소 변환 가능하다. 
모든 IP 주소를 BINARY 타입으로 변환도 가능하다. 당연히 BINARY -> 문자열 변환도 가능하다.
 이 함수를 사용할 경우 BINARY 또는 VARBINARY 타입을 사용하면 된다. (4, 6에 따라 BINARY 크기는 다르게 지정)
```

##### 11.3.3.16 JSON 포맷(JSON_PRETTY)
```text
 MYSQL 클라이언트에서 JSON 데이터의 기본 표시 방법은 단순 텍스트 포맷인데, 이 포맷의 가독성을 좋게하기 위해 JSON_PRETTY 함수 사용 가능
```

##### 11.3.3.17 JSON 필드 크기(JSON_STORAGE_SIZE)
```text
 MYSQL 서버는 JSON 텍스트 기반 데이터를 실제 디스크에 저장할 때 BSON(BINARY JSON) 포맷을 사용한다. 
하지만 BSON은 저장 공간 크기 예측이 어렵다. 그때 사용한다.
```

##### 11.3.3.18 JSON 필드 추출(JSON_EXTRACT)
```text
 특정 필드의 값을 가져오는 일반적인 방법이다.
```

##### 11.3.3.19 JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
```text
 JSON 경로에 JSON 필드를 가지고 있는지 확인하는 함수다.
```

##### 11.3.3.20 JSON 오브젝트 생성(JSON_OBJECT)
```text
 RDBMS 값을 이용해 JSON 오브젝트 생성한다.
```

##### 11.3.3.21 JSON 컬럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)
```text
 GROUP BY와 함께 사용되는 집계 함수로서, 컬럼의 값을 모아 JSON 배열 또는 도큐먼트를 생성한다.
```

##### 11.3.3.22 JSON 데이터를 테이블로 변환(JSON_TABLE)
```text
 JSON의 데이터 값들을 모아 RDBMS 테이블을 만들어 반환한다.
```

## SELECT
```text
 OLTP 환경에서 데이터 등록, 수정은 대부분 레코드 단위로 발생되어 성능상 문제가 되는 경우가 별로 없다.
그러나 SELECT 조회의 경우 여러 테이블을 조합하여 데이터를 가져오기 때문에 각 테이블에 어떻게 접근할 것인가 주의해야 한다.
```


### 11.4.1 SELECT 절의 처리 순서
```text
 SELECT 문장의 각 절에서(select절, from절, where절 등) 어느 절이 먼저 실행되는지 모르면 처리 내용, 결과를 예측할 수 없다.
```

### 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
```text
 WHERE 절의 조건 뿐만 아니라, GROUP BY, ORDER BY 절도 인덱스를 이용해 빠르게 처리 할 수 있다. 
그렇다면 어떤 요건을 갖췄을 때 인덱스를 이용할 수 있을까? 
```

#### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙
```text
 WHERE, ORDER BY, GROUP BY가 인덱스를 타게 하기 위해서는 인덱스로 선정된 컬럼의 값 자체를 변환해서는 안된다. 
인덱스는 컬럼의 값을 변환없이 B-Tree에 정렬해서 저장한다. 
 WHERE, ORDER BY, GROUP BY에서도 원본 값을 검색하거나 정렬할 때만 B-Tree에 정렬된 인덱스 이용한다.
 복잡한 연산 수행, MD5() 함수와 같이 해시 값을 만들어 비교해야 하는 경우 미리 계산된 값을 저장하도록 가상 컬럼을 추가하고 크 컬럼에 인덱스를 생성하여 사용하면 된다.
 
 WHERE 절 비교 조건에서는 비교 대상의 데이터 타입이 일치해야한다. (형변환 - 값 자체 변환이 생긴다.)
두 타입이 다를 때 MySQL 옵티마이저가 내부적으로 문자열 타입을 숫자로 변환후 비교 작업 처리한다. (숫자 값을 문자열로 변환하여 인덱스 레인지 스캔을 유도 할 수 있다.)
```

#### 11.4.2.2 WHERE 절의 인덱스 사용
```text
WHERE 조건이 인덱스 사용하는 방법은 크게 두 가지 방식으로 구분한다.
 1. 작업 범위 결정 조건
 2. 체크 조건
 
- 작업 범위 결정 조건
 WHERE 절에서 동등 비교 조건, IN 구성 조건들이 인덱스 컬럼 구성과 좌츨에서부터 비교해서 얼마나 일치하는가에 따라 달라진다.
 실제 조건 컬럼들이 인덱스 순서와 일치하지 않더라도 옵티마이저는 인덱스 사용 가능 조건들을 뽑아 최적화 수행 가능! 
 
8.0부터 인덱스 컬럼별 정순, 역순 정렬 혼합 생성 가능!  
ex) ALTER TABLE ... ADD INDEX ix_col1234 (col_1 ASC, col_2 DESC, col_3 ASC, col_4 ASC);

WHERE 절에서는 인덱스가 생성된 순서는 중요하지 않고 인덱스 구성 컬럼의 존재 여부가 중요하다.

WHERE 절 조건들이 AND, OR 중 어떤 것을 사용하느냐에 따라 처리 방법이 완전히 바뀐다.
A, B 컬럼으로 생성된 인덱스가 있다고 했을 때 A AND B로 조건을 걸면 인덱스를 타지만, OR로 연결되면 테이블 풀 스캔을 선택할 수 있다.
풀 테이블 스캔 + 인덱스 레인지 스캔의 작업량보다 풀 테이블 스캔이 빠른 경우 풀 테이블 스캔을 선택한다.
AND로 연결되면 읽어야 할 레코드를 줄이는 역할을 하지만, OR인 경우 비교 할 레코드가 더 늘어나기에 WHERE 절 OR은 주의해서 사용하자!
```

#### 11.4.2.3 GROUP BY 절의 인덱스 사용
```text
GROUP BY 절은 비교 연산자 쓰지 않으므로 '작업 범위 결정 조건', '체크 조건'을 구분해서 생각할 필요가 없다.
- GROUP BY 절 명시한 컬럼 순서와 인덱스 구성 컬럼 순서가 같으면 인덱스 이용 가능하다. 
- 인덱스 앞에 명시된 앞에 컬럼 순서대로 GROUP BY 절에 명시되어야 하며, 인덱스 구성 컬럼 뒷 부분은 GROUP BY 절에 몇 개 없어도 인덱스를 이용 가능하다.
- GROUP BY 절에 사용한 컬럼이 인덱스 구성 컬럼에 포함되지 않는다면 인덱스 이용 불가능하다. 
```

#### 11.4.2.4 ORDER BY 절의 인덱스 사용
```text
ORDER BY 절과 GROUP BY 절의 인덱스 사용 요건은 흡사하다.
하지만 ORDER BY 절에 조건이 하나 더 있는데, 정렬 컬럼의 ASC, DESC 옵션이 인덱스와 같거나 정반대인 경우에 사용 할 수 있다.
인덱스의 컬럼 정렬과 ORDER BY의 정렬 방식이 다르면 인덱스를 사용하지 못한다.
```

#### 11.4.2.5 WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용
```text
쿼리 문장에 WHERE, ORDER BY, GROUP BY 중 하나만 쓰인다면, 사용된 절에 초점을 인덱스를 튜닝하면 된다.
하지만 보통 애플리케이션에 사용되는 쿼리 문장은 간단하지 않다.

- WHERE 절 + ORDER BY 절 같이 사용하는 경우 세 가지 방법 중 한 가지로 인덱스를 이용한다.
 1. WHERE 절과 ORDER BY 절이 동시에 같은 인덱스 이용
   - 이 방식은 나머지 방식보다 훨씬 빠른 성능을 보여준다. 따라서 이 방식으로 유도하여 튜닝하거나 인덱스를 생성하는 것이 좋다.
 2. WHERE 절만 인덱스를 이용
   - ORDER BY 절은 인덱스 이용 정령 불가능하다. 즉 인덱스를 통해 검색된 결과들을 별도 정렬 처리 과정(Using Filesort)를 거려 정렬을 수행한다.
   - 주로 WHERE 절 조건에 일치하는 레코드가 수가 많지 않을 때 효율적인 방식이다.
 3. ORDER BY 절만 인덱스 이용
   - ORDER BY 절의 순서대로 인덱스를 읽으며 한 건씩 WHERE 절 조건에 일치하는지 비교 후 일치하지 않을 때 버리는 형태로 처리한다.
   - 주로 아주 많은 레코드 조회 후 정렬해야 할 때 이런 형태로 튜닝을 한다.   
- WHERE 절 동등 조건 비교 컬럼과 ORDER BY 절 명시 컬럼 순서가 모두 일치해야 한다.
```
```sql
-- 예제 -> 인덱스 생성 (COL1 ASC, COL2 ASC, COL3 ASC, COL4 ASC)
-- 동등 조건 예제
SELECT
    *
FROM
    TEST
WHERE  
    COL1 = 10
ORDER BY COL2, COL3;

/*
얼핏 보면 위 예제의 ORDER BY 절은 첫 인덱스가 없기 때문에 인덱스를 이용하지 못 한다고 생각할 수 있지만 WHERE 조건이 상수로 동등 비교를
하기 때문에 ORDER BY COL1, COL2, COL3과 정렬 순서에 변화가 없다.
즉, MySQL 옵티마이저는 인덱스를 적절히 사용 가능하도록 실행 계획을 수립한다.
*/

-- 범위 조건 예제1 -> 범위 조건이지만, ORDER BY에 인덱스 생성 순서대로 모두 명시 됐기에 인덱스를 사용해 WHERE, ORDER BY 절 처리 가능
SELECT
    *
FROM
    TEST
WHERE
    COL1 > 10
ORDER BY COL1, COL2, COL3;

-- 범위 조건 예제2 -> 범위 조건인데, ORDER BY 절에 인덱스 생성 순서대로 컬럼이 명시되지 않아 인덱스 이용 불가능
SELECT
    *
FROM
    TEST
WHERE
    COL1 > 10
ORDER BY COL2, COL3;
```

#### 11.4.2.6 GROUP BY 절과 ORDER BY 절의 인덱스 사용
```text
ORDER BY, GROUP BY 두 절이 모두 하나의 인덱스를 사용하기 위해서는 각 절에 명시된 컬럼의 순서가 같아야 한다.
두 절 중 하나라도 인덱스 이용 불가능할 때 둘 다 인덱스 사용 불가능하다.

5.7까지는 GROUP BY는 명시 컬럼에 대한 정렬까지 함께 수행했지만, 8.0부터 정렬을 보장하지 않는 형태로 변경됐다.  
```

#### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
```text
- WHERE, GROUP BY, ORDER BY가 모두 포함된 SQL 문장에 인덱스 사용 여부를 판단하기 위해 3가지를 살펴보면 된다. (P.65 참고)
 1. WHERE 절이 인덱스를 사용할 수 있는가?
 2. GROUP BY 절이 인덱스를 사용할 수 있는가?
 3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가? 
 
앞서 말했듯 GROUP BY, ORDER BY 두 절 중 하나라도 인덱스를 사용 못하면 두 절 모두 인덱스를 사용하지 못한다.
결국 세 절 모두 사용 가능, WHERE 절만 사용 가능, (GROUP BY, ORDER BY) 사용 가능, 인덱스 사용 못함으로 구분된다. 
```

### 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항
```text
쿼리 최적 실행을 위해 적합한 인덱스와 함께 WHERE 절의 비교 조건 표현식을 적절히 사용해야 한다.
```

#### 11.4.3.1 NULL 비교
```text
MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다. 즉 NULL을 하나의 값으로 인정한다.
쿼리 NULL 비교시 IS NULL 또는 <=> 연산자를 사용해야 한다. 
인덱스 컬럼을 IS NULL 조건을 주는 경우 인덱스를 이용가능하게 할 수 있다.
```

#### 11.4.3.2 문자열이나 숫자 비교
```text

```











































































