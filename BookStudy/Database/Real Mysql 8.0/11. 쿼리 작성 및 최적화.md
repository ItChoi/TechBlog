# 11. 쿼리 작성 및 최적화
```text
 쿼리가 빠르게 동작하기 위해서는 어떻게 처리할지 예측할 수 있어야 한다.
데이터베이스를 통해 몇 십 배 성능 향상은 흔한 일이다. 따라서 쿼리를 어떻게 작성하고 처리 되는지 이해가 필요하다.
```

## 11.1 쿼리 작성과 연관된 시스템 변수
```text
 SQL 작성 규칙은 MYSQL 서버 시스템 설정에 따라 달라진다.
```

### 11.1.1 SQL 모드
```text
 sql_mode 시스템 설정은 여러 값을 설정할 수 있다.
테이블이 생성되고 데이터가 저장되면 그 이후로는 해당 시스템 설정을 바꾸지 않는 것이 좋다.
익숙하지 않다면 기본 값을 사용하자. 

- STRICT_ALL_TABLES & STRICT_TRANS_TABLES
  등록, 수정시 컬럼 타입과 다른 값이 들어오는 경우 자동으로 타입 변환을 수행한다.
 변환되기 어려운 경우 실행/에러도 결정 가능하다. 
 STRICT_ALL_TABLES: 모든 스토리지 엔진에 대해 엄격 모드 적용
 STRICT_TRANS_TABLES: 자동 변환을 막기 위해 서비스 적용 전 반드시 활성을 권장
 
- ANSI_QUOTES
  문자열 값(리터럴) 표현을 위해 홑따옴표, 쌍따옴표 동시 사용 가능
  
- ONLY_FULL_GROUP_BY
  5.7 까지는 기본 값이 비활성이지만, 8.0부터 기본 값이 활성이다.
 활성시 GROUP BY에 SELECT된 컬럼만 사용가능하다. 집계함수의 경우 명시되지 않더라도 사용가능하다.
 
- PIPE_AS_CONCAT
  ||는 OR 연산자와 같은 의미이지만, 이 옵션 설정시 문자열 연결 연산자(CONCAT)으로 사용 가능
  
- PAD_CHAR_TO_FULL_LENGTH
  기본적으로 CHAR 타입은 VARCHAR와 같이 유효 문자열 뒤 공백 문자 제거 후 반환되는데, 
  이 값의 설정을 통해 공백 문자 제거 없이 반환 가능하다.
  
- NO_BACKSLASH_ESCAPES
  설정시 역슬래시를 문자 이스케이프 용도로 사용하지 못한다.
  
- IGNORE_SPACE
  프로시저 이름 뒤 공백을 프로시저명으로 인식하지 않을 수 있도록 해준다.
  
- REAL_AS_FLOAT
  REAL -> DOUBLE에서 REAL -> FLOAT로 바뀐다.
  
- NO_ZERO_IN_DATE & NO_ZERO_DATE
  두 옵션 활성시 잘못된 날짜 형식 저장 불가능, 실제 존재 날짜만 저장 가능하다.
  
- ANSI
  최대한 SQL 표준에 맞게 동작하게 만들어준다.
  
- TRADITIONAL
  여러 옵션 조합
```

### 11.1.2 영문 대소문자 구분
```text
 MYSQL 서버는 설치된 운영체제에 따라 테이블명 대소문자 구분한다. DB나 테이블이 디스크의 디렉토리나 파일로 매핑되기 때문이다.
대소문자 구분 없애려면 lower_case_table_names 시스템 변수 설정을 하면 된다.
```

### 11.1.3 MySQL 예약어
```text
 테이블 생성시 항상 역따옴표(`)로 테이블이나 컬럼 이름을 감싸지 않은 상태로 생성하길 권장한다. 
```

## 11.2 매뉴얼의 SQL 문법 표기를 읽는 방법

## 11.3 MySQL 연산자와 내장 함수
```text
 MYSQL 전용 연산자가 있는데, 가능하면 SQL 가독성을 위해 ANSI 표준 연산자를 사용하길 권장한다.
```

### 11.3.1 리터럴 표기 문자열

#### 11.3.1.1 문자열 - 패스

#### 11.3.1.2 숫자 - 패스

#### 11.3.1.2 숫자 - 날짜
```text
 다른 DBMS에서 날짜 타입을 비교하거나 등록시 문자열 -> DATE 타입 변환 코드 필요하다.
그러나 MYSQL은 자동으로 DATE나 DATETIME 값으로 변환해준다.
```

#### 11.3.1.4 불리언
```text
 BOOL, BOOLEAN 타입은 TINYINT 타입에 대한 동의어일뿐이다.
BOOL 타입 뿐만 아니라 숫자 타입에도 적용 가능 (TRUE, FALSE)
즉 TRUE, FALSE는 정수로 매핑해서 사용한다. (0, 1)
BOOLEAN 타입을 꼭 사용해야 할 경우 ENUM 타입으로 관리
```

### 11.3.2 MYSQL 연산자

#### 11.3.2.1 동등(Equal) 비교(=, <=>)
```text
 동등 비교 =, <=>를 제공하는데, <=>는 NULL 비교까지 수행  
NULL은 ISNULL 연산자 이외에 비교 방법이 없다. 하지만 <=> (Null-Safe)를 통해 비교 NULL <=> NULL 비교 가능
NULL을 하나의 값으로 인식하교 비교
```

#### 11.3.2.2 부정 (Not-Equal) 비교 (<>, !=)
```text
 무엇을 사용해도 괜찮지만, 통일된 방식으로 사용하길 권장
```

#### 11.3.2.3 NOT 연산자 (!) - 패스

#### 11.3.2.4 AND(&&)와 OR(||) 연산자
```text
 오라클 ||는 문자를 연결한다. MYSQL에서는 OR 연산자로 사용가능한데, 시스템 변수를 통해 용도 변경 가능하다.
```

#### 11.3.2.5 나누기(/, DIV)와 나머지(%, MOD) 연산자 - 패스

#### 11.3.2.6 REGEXP 연산자
```text
 문자열 값이 어떤 패턴을 만족하는지 체크한다. RLIKE, REGEXP는 똑같은 비교를 수행한다.
```

#### 11.3.2.7 LIKE 연산자
```text
 LIKE 'start%' -> 인덱스 레인지 스캔을 통해 검색 가능 
 LIKE '%end' -> 인덱스 풀 스캔 방식
```

#### 11.3.2.8 BETWEEN 연산자
```text
 동등 조건이 아니라 크거나 같다, 같거나 크다기 때문에 모든 인덱스 범위 검색해야 한다.
BETWEEN은 범위 검색, IN은 여러 개를 동등 비교해서 성능을 최적화 할 수 있다.
```

#### 11.3.2.9 IN 연산자
```text
 IN은 여러개 값에 대해 동등 비교 연산을 수행한다. 즉 범위 검색이 아니라서 일반적으로 빠르게 처리된다.
IN 연산자는 두 형태를 구분해서 생각해볼 필요가 있다.
 1. 상수가 사용된 경우
   - IN (?, ?, ?)
 2. 서브쿼리가 사용된 경우 
   - IN (SELECT .. FROM ..)
```

```sql
-- 8.0까지는 IN 절에 튜플(레코드)을 사용하면서 항상 풀 테이블 스캔을 했었다.
SELECT *
FROM dept_no
WHERE (dept_no, emp_no) IN (('d001', '10017'), ('d002', 10144), ('d003', 10054));
```
```text
 위 쿼리에서 IN 절의 상숫 값이 단순 스칼라 값이 아니라 튜플이 사용됐다.
8.0 이전 버전까지 이런 쿼리 실행시 성능 문제가 생겨 일부러 쿼리를 쪼개어 여러 번 실행해야 했다. 
8.0부터 IN절에 튜플을 그대로 나열해도 인덱스 최적으로 사용 가능하도록 개선됐다.

 IN절 안에 서브쿼리가 들어간 경우 최적화가 매우 까다로운데, 8.0 전에는 최적화가 상당히 불안했다.
8.0부터 IN (subquery) 같은 세미 조인의 최적화가 많이 안정됐다.

 NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시된다. 동등이 아닌, 부정형 비교는 인덱스 범위 검색으로 사용될 수 없다.
NOT INT이 PK와 비교될 때 가끔 인덱스 레인지 스캔이 표시되는 경우가 있는데, InnoDB는 PK가 클러스터링 키이기 때문일 뿐
실제 IN과 효율적으로 실행되는 것이 아니다.
```

### 11.3.3 MySQL 내장 함수
```text
 기본 내장함수와, 사용자 정의 함수로 구분된다.
MySQL에서 제공하는 C/C++ API를 이용하여 사용자가 직접 함수를 만들어 추가 가능하다. 
 참고로 이 부분의 내장 함수는 프로시저나 스토어드 함수와는 의미가 다르다.
```

#### 11.3.3.1 NULL 값 비교 및 대체(IFNULL, ISNULL)
```text
 IFNULL의 경우 표현식의 값이 NULL인지 비교 후 NULL인 경우 다른 값으로 대체 가능하다.
 ISNULL의 경우 NULL 여부에 따라 TRUE(1), FALSE(0)을 반환한다. 
```

#### 11.3.3.2 현재 시각 조회(NOW, SYSDATE)
```text
 두 함수 모두 현재 시간을 반환하는 함수다. 그러나 작동 방식에 큰 차이가 있다.
SQL에서 모든 NOW()는 같은 값을 갖는다.
SYSDATE()의 경우 호출 시점에 따라 결과 값이 달라진다. (시간이 다르다.)

- SYSDATE는 두 가지 문제가 있다.
  1. 레플리카 서버에서 안정적으로 복제되지 못한다.
  2. 인덱스 효율적 사용 불가 - 호출마다 다른 값을 반환하므로 상수가 아니다. (매번 레코드마다 비교)

 따라서 SYSDATE는 사용하지 않는 편이 좋다. 이미 사용하고 있다면, 시스템 변수를 통해 문제점을 제거하거나 NOW와 동일하게 동작하도록 할 수 있다.
```

##### 11.3.3.3 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)
```text
- datetype -> 문자열 변환시 DATE_FORMAT() 함수 사용 (대소문자 구분 필요)
  - %Y: 4자리 연도
  - %m: 2자리 숫자 표시 월 (01 ~ 12)
  - %d: 2자리 숫자 표시 일자 (01 ~ 31)
  - %H: 2자리 숫자 표시 시 (00 ~ 23)
  - %i: 2자리 숫자 표시 분 (00 ~ 59)
  - %s: 2자리 숫자 표시 초 (00 ~ 59)
 문자열, 기타 방법 등은 DATETIME으로 자동 변환 가능한 형태가 있다. 그렇지 않은 경우 MYSQL 서버가 날짜 타입을 이해하도록 함수를 사용하여 명시해야 한다.
 
- 문자열 -> datetype 변환시 STR_TO_DATE() 함수 사용  
```

#### 11.3.3.4 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
```text
 특정 날짜를 더하거나 뺄 때 사용한다. DATE_ADD함수로 더하거나 뺼 수 있기에 SUB은 크게 필요하지 않다.
```

##### 11.3.3.5 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
```text
 1970-01-01 00:00:00으로부터 경과된 초를 반환한다. 
```

##### 11.3.3.6 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)
```text
 RPAD, LPAD는 문자열 좌, 우에 문자를 덧붙일 수 있다.
 RTRIM, LTRIM, TRIM는 공백 문자 제거 함수이다.
```

##### 11.3.3.7 문자열 결합(CONCAT)
```text
 여러개 문자열을 연결해서 하나의 문자열로 반환하는 함수이다. 숫자는 자동 변환 후 연결한다.
따라서 의도된 변환이 아닌 경우 명시적 CAST 함수 사용하는 것이 안전하다.
```

##### 11.3.3.8 GROUP BY 문자열 결합(GROUP_CONCAT)
```text
 COUNT, MAX, MIN과 같은 그룹 함수 중 하나다.
주로 GROUP BY에서 사용하지만, 없이 사용하는 경우 단 하나의 결과 값을 만들어낸다.

 값으 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하고, 중복 제거 후 연결하는 것도 가능하므로 유용하다.
지정한 컬럼의 값을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 
지정 크기 초과시 WARNING 발생한다. JDBC에서 실행될 때 경고가 아니라 에러 취급되어 쿼리 실패한다. 따라서 초과하지 않게 주의!
버퍼의 기본 크기는 1KB고 당연히 시스템 변수로 설정 가능하다.
```

#### 11.3.3.9 값의 비교와 대체(CASE WHEN ... THEN ... END)

#### 11.3.3.10 타입의 변환(CAST, CONVERT)
```text
 Prepared Statemet를 제외하면 SQL은 텍스트(문자열) 기반 작동 - 모든 입력 값은 문자열 취급
따라서 명시적 타입 변환이 필요한 경우 CAST를 사용한다. CONVERT도 CAST와 거의 비슷하고, 인자 사용 규칙만 다르다.
```

##### 11.3.3.11 이진값과 16진수 문자열(Hex String) 변환(HEX, UNHEX)

##### 11.3.3.12 암호화 및 해시 함수(MD5, SHA, SHA2)
```text
 MD5와 SHA 모두 비대칭형 암호화 알고리즘이다. 인자로 전달한 문자열을 지정된 비트 수의 해시 값을 만들어낸다.
```

##### 11.3.3.13 처리 대기(SLEEP)
```text
 SQL 개발이나 디버깅 용도로 잠깐 대기하거나 쿼리 실행 시간을 유지하고자 할 때 사용한다.
```

##### 11.3.3.14 벤치마크(BENCHMARK)
```text
 SLEEP과 같이 디버깅이나 간단한 함수 성능 테스트용으로 유용하다.
실제 쿼리와 벤치마크 함수 사용은 차이가 있다.
```

##### 11.3.3.15 IP 주소 변환(INET_ATON, INET_NTOA)
```text
 IP는 부호 없는 정수다. 그러나 대부분 VARCHAR(15)로 '.'까지 같이 저장한다. 문자열로 저장된 IP 주소는 저장 공간을 훨씬 많이 필요로 한다.
많은 DBMS에서 IP 주소를 저장하는 타입을 별도 제공하지 않는다.
 MYSQL에서는 INET_NTOA를 이용하여 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공한다.
INET6_ATON, INET6_NTOA응 이용하면 IPv6 주소 변환 가능하다. 
모든 IP 주소를 BINARY 타입으로 변환도 가능하다. 당연히 BINARY -> 문자열 변환도 가능하다.
 이 함수를 사용할 경우 BINARY 또는 VARBINARY 타입을 사용하면 된다. (4, 6에 따라 BINARY 크기는 다르게 지정)
```

##### 11.3.3.16 JSON 포맷(JSON_PRETTY)
```text
 MYSQL 클라이언트에서 JSON 데이터의 기본 표시 방법은 단순 텍스트 포맷인데, 이 포맷의 가독성을 좋게하기 위해 JSON_PRETTY 함수 사용 가능
```

##### 11.3.3.17 JSON 필드 크기(JSON_STORAGE_SIZE)
```text
 MYSQL 서버는 JSON 텍스트 기반 데이터를 실제 디스크에 저장할 때 BSON(BINARY JSON) 포맷을 사용한다. 
하지만 BSON은 저장 공간 크기 예측이 어렵다. 그때 사용한다.
```

##### 11.3.3.18 JSON 필드 추출(JSON_EXTRACT)
```text
 특정 필드의 값을 가져오는 일반적인 방법이다.
```

##### 11.3.3.19 JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
```text
 JSON 경로에 JSON 필드를 가지고 있는지 확인하는 함수다.
```

##### 11.3.3.20 JSON 오브젝트 생성(JSON_OBJECT)
```text
 RDBMS 값을 이용해 JSON 오브젝트 생성한다.
```

##### 11.3.3.21 JSON 컬럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)
```text
 GROUP BY와 함께 사용되는 집계 함수로서, 컬럼의 값을 모아 JSON 배열 또는 도큐먼트를 생성한다.
```

##### 11.3.3.22 JSON 데이터를 테이블로 변환(JSON_TABLE)
```text
 JSON의 데이터 값들을 모아 RDBMS 테이블을 만들어 반환한다.
```























