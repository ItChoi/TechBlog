# 11. 쿼리 작성 및 최적화
```text
 쿼리가 빠르게 동작하기 위해서는 어떻게 처리할지 예측할 수 있어야 한다.
데이터베이스를 통해 몇 십 배 성능 향상은 흔한 일이다. 따라서 쿼리를 어떻게 작성하고 처리 되는지 이해가 필요하다.
```

## 11.1 쿼리 작성과 연관된 시스템 변수
```text
 SQL 작성 규칙은 MYSQL 서버 시스템 설정에 따라 달라진다.
```

### 11.1.1 SQL 모드
```text
 sql_mode 시스템 설정은 여러 값을 설정할 수 있다.
테이블이 생성되고 데이터가 저장되면 그 이후로는 해당 시스템 설정을 바꾸지 않는 것이 좋다.
익숙하지 않다면 기본 값을 사용하자. 

- STRICT_ALL_TABLES & STRICT_TRANS_TABLES
  등록, 수정시 컬럼 타입과 다른 값이 들어오는 경우 자동으로 타입 변환을 수행한다.
 변환되기 어려운 경우 실행/에러도 결정 가능하다. 
 STRICT_ALL_TABLES: 모든 스토리지 엔진에 대해 엄격 모드 적용
 STRICT_TRANS_TABLES: 자동 변환을 막기 위해 서비스 적용 전 반드시 활성을 권장
 
- ANSI_QUOTES
  문자열 값(리터럴) 표현을 위해 홑따옴표, 쌍따옴표 동시 사용 가능
  
- ONLY_FULL_GROUP_BY
  5.7 까지는 기본 값이 비활성이지만, 8.0부터 기본 값이 활성이다.
 활성시 GROUP BY에 SELECT된 컬럼만 사용가능하다. 집계함수의 경우 명시되지 않더라도 사용가능하다.
 
- PIPE_AS_CONCAT
  ||는 OR 연산자와 같은 의미이지만, 이 옵션 설정시 문자열 연결 연산자(CONCAT)으로 사용 가능
  
- PAD_CHAR_TO_FULL_LENGTH
  기본적으로 CHAR 타입은 VARCHAR와 같이 유효 문자열 뒤 공백 문자 제거 후 반환되는데, 
  이 값의 설정을 통해 공백 문자 제거 없이 반환 가능하다.
  
- NO_BACKSLASH_ESCAPES
  설정시 역슬래시를 문자 이스케이프 용도로 사용하지 못한다.
  
- IGNORE_SPACE
  프로시저 이름 뒤 공백을 프로시저명으로 인식하지 않을 수 있도록 해준다.
  
- REAL_AS_FLOAT
  REAL -> DOUBLE에서 REAL -> FLOAT로 바뀐다.
  
- NO_ZERO_IN_DATE & NO_ZERO_DATE
  두 옵션 활성시 잘못된 날짜 형식 저장 불가능, 실제 존재 날짜만 저장 가능하다.
  
- ANSI
  최대한 SQL 표준에 맞게 동작하게 만들어준다.
  
- TRADITIONAL
  여러 옵션 조합
```

### 11.1.2 영문 대소문자 구분
```text
 MYSQL 서버는 설치된 운영체제에 따라 테이블명 대소문자 구분한다. DB나 테이블이 디스크의 디렉토리나 파일로 매핑되기 때문이다.
대소문자 구분 없애려면 lower_case_table_names 시스템 변수 설정을 하면 된다.
```

### 11.1.3 MySQL 예약어
```text
 테이블 생성시 항상 역따옴표(`)로 테이블이나 컬럼 이름을 감싸지 않은 상태로 생성하길 권장한다. 
```

## 11.2 매뉴얼의 SQL 문법 표기를 읽는 방법

## 11.3 MySQL 연산자와 내장 함수
```text
 MYSQL 전용 연산자가 있는데, 가능하면 SQL 가독성을 위해 ANSI 표준 연산자를 사용하길 권장한다.
```

### 11.3.1 리터럴 표기 문자열

#### 11.3.1.1 문자열 - 패스

#### 11.3.1.2 숫자 - 패스

#### 11.3.1.2 숫자 - 날짜
```text
 다른 DBMS에서 날짜 타입을 비교하거나 등록시 문자열 -> DATE 타입 변환 코드 필요하다.
그러나 MYSQL은 자동으로 DATE나 DATETIME 값으로 변환해준다.
```

#### 11.3.1.4 불리언
```text
 BOOL, BOOLEAN 타입은 TINYINT 타입에 대한 동의어일뿐이다.
BOOL 타입 뿐만 아니라 숫자 타입에도 적용 가능 (TRUE, FALSE)
즉 TRUE, FALSE는 정수로 매핑해서 사용한다. (0, 1)
BOOLEAN 타입을 꼭 사용해야 할 경우 ENUM 타입으로 관리
```

### 11.3.2 MYSQL 연산자

#### 11.3.2.1 동등(Equal) 비교(=, <=>)
```text
 동등 비교 =, <=>를 제공하는데, <=>는 NULL 비교까지 수행  
NULL은 ISNULL 연산자 이외에 비교 방법이 없다. 하지만 <=> (Null-Safe)를 통해 비교 NULL <=> NULL 비교 가능
NULL을 하나의 값으로 인식하교 비교
```

#### 11.3.2.2 부정 (Not-Equal) 비교 (<>, !=)
```text
 무엇을 사용해도 괜찮지만, 통일된 방식으로 사용하길 권장
```

#### 11.3.2.3 NOT 연산자 (!) - 패스

#### 11.3.2.4 AND(&&)와 OR(||) 연산자
```text
 오라클 ||는 문자를 연결한다. MYSQL에서는 OR 연산자로 사용가능한데, 시스템 변수를 통해 용도 변경 가능하다.
```

#### 11.3.2.5 나누기(/, DIV)와 나머지(%, MOD) 연산자 - 패스

#### 11.3.2.6 REGEXP 연산자
```text
 문자열 값이 어떤 패턴을 만족하는지 체크한다. RLIKE, REGEXP는 똑같은 비교를 수행한다.
```

#### 11.3.2.7 LIKE 연산자
```text
 LIKE 'start%' -> 인덱스 레인지 스캔을 통해 검색 가능 
 LIKE '%end' -> 인덱스 풀 스캔 방식
```

#### 11.3.2.8 BETWEEN 연산자
```text
 동등 조건이 아니라 크거나 같다, 같거나 크다기 때문에 모든 인덱스 범위 검색해야 한다.
BETWEEN은 범위 검색, IN은 여러 개를 동등 비교해서 성능을 최적화 할 수 있다.
```

#### 11.3.2.9 IN 연산자
```text
 IN은 여러개 값에 대해 동등 비교 연산을 수행한다. 즉 범위 검색이 아니라서 일반적으로 빠르게 처리된다.
IN 연산자는 두 형태를 구분해서 생각해볼 필요가 있다.
 1. 상수가 사용된 경우
   - IN (?, ?, ?)
 2. 서브쿼리가 사용된 경우 
   - IN (SELECT .. FROM ..)
```

```sql
-- 8.0까지는 IN 절에 튜플(레코드)을 사용하면서 항상 풀 테이블 스캔을 했었다.
SELECT *
FROM dept_no
WHERE (dept_no, emp_no) IN (('d001', '10017'), ('d002', 10144), ('d003', 10054));
```
```text
 위 쿼리에서 IN 절의 상숫 값이 단순 스칼라 값이 아니라 튜플이 사용됐다.
8.0 이전 버전까지 이런 쿼리 실행시 성능 문제가 생겨 일부러 쿼리를 쪼개어 여러 번 실행해야 했다. 
8.0부터 IN절에 튜플을 그대로 나열해도 인덱스 최적으로 사용 가능하도록 개선됐다.

 IN절 안에 서브쿼리가 들어간 경우 최적화가 매우 까다로운데, 8.0 전에는 최적화가 상당히 불안했다.
8.0부터 IN (subquery) 같은 세미 조인의 최적화가 많이 안정됐다.

 NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시된다. 동등이 아닌, 부정형 비교는 인덱스 범위 검색으로 사용될 수 없다.
NOT INT이 PK와 비교될 때 가끔 인덱스 레인지 스캔이 표시되는 경우가 있는데, InnoDB는 PK가 클러스터링 키이기 때문일 뿐
실제 IN과 효율적으로 실행되는 것이 아니다.
```

### 11.3.3 MySQL 내장 함수
```text
 기본 내장함수와, 사용자 정의 함수로 구분된다.
MySQL에서 제공하는 C/C++ API를 이용하여 사용자가 직접 함수를 만들어 추가 가능하다. 
 참고로 이 부분의 내장 함수는 프로시저나 스토어드 함수와는 의미가 다르다.
```

#### 11.3.3.1 NULL 값 비교 및 대체(IFNULL, ISNULL)
```text
 IFNULL의 경우 표현식의 값이 NULL인지 비교 후 NULL인 경우 다른 값으로 대체 가능하다.
 ISNULL의 경우 NULL 여부에 따라 TRUE(1), FALSE(0)을 반환한다. 
```

#### 11.3.3.2 현재 시각 조회(NOW, SYSDATE)
```text
 두 함수 모두 현재 시간을 반환하는 함수다. 그러나 작동 방식에 큰 차이가 있다.
SQL에서 모든 NOW()는 같은 값을 갖는다.
SYSDATE()의 경우 호출 시점에 따라 결과 값이 달라진다. (시간이 다르다.)

- SYSDATE는 두 가지 문제가 있다.
  1. 레플리카 서버에서 안정적으로 복제되지 못한다.
  2. 인덱스 효율적 사용 불가 - 호출마다 다른 값을 반환하므로 상수가 아니다. (매번 레코드마다 비교)

 따라서 SYSDATE는 사용하지 않는 편이 좋다. 이미 사용하고 있다면, 시스템 변수를 통해 문제점을 제거하거나 NOW와 동일하게 동작하도록 할 수 있다.
```

##### 11.3.3.3 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)
```text
- datetype -> 문자열 변환시 DATE_FORMAT() 함수 사용 (대소문자 구분 필요)
  - %Y: 4자리 연도
  - %m: 2자리 숫자 표시 월 (01 ~ 12)
  - %d: 2자리 숫자 표시 일자 (01 ~ 31)
  - %H: 2자리 숫자 표시 시 (00 ~ 23)
  - %i: 2자리 숫자 표시 분 (00 ~ 59)
  - %s: 2자리 숫자 표시 초 (00 ~ 59)
 문자열, 기타 방법 등은 DATETIME으로 자동 변환 가능한 형태가 있다. 그렇지 않은 경우 MYSQL 서버가 날짜 타입을 이해하도록 함수를 사용하여 명시해야 한다.
 
- 문자열 -> datetype 변환시 STR_TO_DATE() 함수 사용  
```

#### 11.3.3.4 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
```text
 특정 날짜를 더하거나 뺄 때 사용한다. DATE_ADD함수로 더하거나 뺼 수 있기에 SUB은 크게 필요하지 않다.
```

##### 11.3.3.5 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
```text
 1970-01-01 00:00:00으로부터 경과된 초를 반환한다. 
```

##### 11.3.3.6 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)
```text
 RPAD, LPAD는 문자열 좌, 우에 문자를 덧붙일 수 있다.
 RTRIM, LTRIM, TRIM는 공백 문자 제거 함수이다.
```

##### 11.3.3.7 문자열 결합(CONCAT)
```text
 여러개 문자열을 연결해서 하나의 문자열로 반환하는 함수이다. 숫자는 자동 변환 후 연결한다.
따라서 의도된 변환이 아닌 경우 명시적 CAST 함수 사용하는 것이 안전하다.
```

##### 11.3.3.8 GROUP BY 문자열 결합(GROUP_CONCAT)
```text
 COUNT, MAX, MIN과 같은 그룹 함수 중 하나다.
주로 GROUP BY에서 사용하지만, 없이 사용하는 경우 단 하나의 결과 값을 만들어낸다.

 값으 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하고, 중복 제거 후 연결하는 것도 가능하므로 유용하다.
지정한 컬럼의 값을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 
지정 크기 초과시 WARNING 발생한다. JDBC에서 실행될 때 경고가 아니라 에러 취급되어 쿼리 실패한다. 따라서 초과하지 않게 주의!
버퍼의 기본 크기는 1KB고 당연히 시스템 변수로 설정 가능하다.
```

#### 11.3.3.9 값의 비교와 대체(CASE WHEN ... THEN ... END)

#### 11.3.3.10 타입의 변환(CAST, CONVERT)
```text
 Prepared Statemet를 제외하면 SQL은 텍스트(문자열) 기반 작동 - 모든 입력 값은 문자열 취급
따라서 명시적 타입 변환이 필요한 경우 CAST를 사용한다. CONVERT도 CAST와 거의 비슷하고, 인자 사용 규칙만 다르다.
```

##### 11.3.3.11 이진값과 16진수 문자열(Hex String) 변환(HEX, UNHEX)

##### 11.3.3.12 암호화 및 해시 함수(MD5, SHA, SHA2)
```text
 MD5와 SHA 모두 비대칭형 암호화 알고리즘이다. 인자로 전달한 문자열을 지정된 비트 수의 해시 값을 만들어낸다.
```

##### 11.3.3.13 처리 대기(SLEEP)
```text
 SQL 개발이나 디버깅 용도로 잠깐 대기하거나 쿼리 실행 시간을 유지하고자 할 때 사용한다.
```

##### 11.3.3.14 벤치마크(BENCHMARK)
```text
 SLEEP과 같이 디버깅이나 간단한 함수 성능 테스트용으로 유용하다.
실제 쿼리와 벤치마크 함수 사용은 차이가 있다.
```

##### 11.3.3.15 IP 주소 변환(INET_ATON, INET_NTOA)
```text
 IP는 부호 없는 정수다. 그러나 대부분 VARCHAR(15)로 '.'까지 같이 저장한다. 문자열로 저장된 IP 주소는 저장 공간을 훨씬 많이 필요로 한다.
많은 DBMS에서 IP 주소를 저장하는 타입을 별도 제공하지 않는다.
 MYSQL에서는 INET_NTOA를 이용하여 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공한다.
INET6_ATON, INET6_NTOA응 이용하면 IPv6 주소 변환 가능하다. 
모든 IP 주소를 BINARY 타입으로 변환도 가능하다. 당연히 BINARY -> 문자열 변환도 가능하다.
 이 함수를 사용할 경우 BINARY 또는 VARBINARY 타입을 사용하면 된다. (4, 6에 따라 BINARY 크기는 다르게 지정)
```

##### 11.3.3.16 JSON 포맷(JSON_PRETTY)
```text
 MYSQL 클라이언트에서 JSON 데이터의 기본 표시 방법은 단순 텍스트 포맷인데, 이 포맷의 가독성을 좋게하기 위해 JSON_PRETTY 함수 사용 가능
```

##### 11.3.3.17 JSON 필드 크기(JSON_STORAGE_SIZE)
```text
 MYSQL 서버는 JSON 텍스트 기반 데이터를 실제 디스크에 저장할 때 BSON(BINARY JSON) 포맷을 사용한다. 
하지만 BSON은 저장 공간 크기 예측이 어렵다. 그때 사용한다.
```

##### 11.3.3.18 JSON 필드 추출(JSON_EXTRACT)
```text
 특정 필드의 값을 가져오는 일반적인 방법이다.
```

##### 11.3.3.19 JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
```text
 JSON 경로에 JSON 필드를 가지고 있는지 확인하는 함수다.
```

##### 11.3.3.20 JSON 오브젝트 생성(JSON_OBJECT)
```text
 RDBMS 값을 이용해 JSON 오브젝트 생성한다.
```

##### 11.3.3.21 JSON 컬럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)
```text
 GROUP BY와 함께 사용되는 집계 함수로서, 컬럼의 값을 모아 JSON 배열 또는 도큐먼트를 생성한다.
```

##### 11.3.3.22 JSON 데이터를 테이블로 변환(JSON_TABLE)
```text
 JSON의 데이터 값들을 모아 RDBMS 테이블을 만들어 반환한다.
```

## SELECT
```text
 OLTP 환경에서 데이터 등록, 수정은 대부분 레코드 단위로 발생되어 성능상 문제가 되는 경우가 별로 없다.
그러나 SELECT 조회의 경우 여러 테이블을 조합하여 데이터를 가져오기 때문에 각 테이블에 어떻게 접근할 것인가 주의해야 한다.
```


### 11.4.1 SELECT 절의 처리 순서
```text
 SELECT 문장의 각 절에서(select절, from절, where절 등) 어느 절이 먼저 실행되는지 모르면 처리 내용, 결과를 예측할 수 없다.
```

### 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
```text
 WHERE 절의 조건 뿐만 아니라, GROUP BY, ORDER BY 절도 인덱스를 이용해 빠르게 처리 할 수 있다. 
그렇다면 어떤 요건을 갖췄을 때 인덱스를 이용할 수 있을까? 
```

#### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙
```text
 WHERE, ORDER BY, GROUP BY가 인덱스를 타게 하기 위해서는 인덱스로 선정된 컬럼의 값 자체를 변환해서는 안된다. 
인덱스는 컬럼의 값을 변환없이 B-Tree에 정렬해서 저장한다. 
 WHERE, ORDER BY, GROUP BY에서도 원본 값을 검색하거나 정렬할 때만 B-Tree에 정렬된 인덱스 이용한다.
 복잡한 연산 수행, MD5() 함수와 같이 해시 값을 만들어 비교해야 하는 경우 미리 계산된 값을 저장하도록 가상 컬럼을 추가하고 크 컬럼에 인덱스를 생성하여 사용하면 된다.
 
 WHERE 절 비교 조건에서는 비교 대상의 데이터 타입이 일치해야한다. (형변환 - 값 자체 변환이 생긴다.)
두 타입이 다를 때 MySQL 옵티마이저가 내부적으로 문자열 타입을 숫자로 변환후 비교 작업 처리한다. (숫자 값을 문자열로 변환하여 인덱스 레인지 스캔을 유도 할 수 있다.)
```

#### 11.4.2.2 WHERE 절의 인덱스 사용
```text
WHERE 조건이 인덱스 사용하는 방법은 크게 두 가지 방식으로 구분한다.
 1. 작업 범위 결정 조건
 2. 체크 조건
 
- 작업 범위 결정 조건
 WHERE 절에서 동등 비교 조건, IN 구성 조건들이 인덱스 컬럼 구성과 좌츨에서부터 비교해서 얼마나 일치하는가에 따라 달라진다.
 실제 조건 컬럼들이 인덱스 순서와 일치하지 않더라도 옵티마이저는 인덱스 사용 가능 조건들을 뽑아 최적화 수행 가능! 
 
8.0부터 인덱스 컬럼별 정순, 역순 정렬 혼합 생성 가능!  
ex) ALTER TABLE ... ADD INDEX ix_col1234 (col_1 ASC, col_2 DESC, col_3 ASC, col_4 ASC);

WHERE 절에서는 인덱스가 생성된 순서는 중요하지 않고 인덱스 구성 컬럼의 존재 여부가 중요하다.

WHERE 절 조건들이 AND, OR 중 어떤 것을 사용하느냐에 따라 처리 방법이 완전히 바뀐다.
A, B 컬럼으로 생성된 인덱스가 있다고 했을 때 A AND B로 조건을 걸면 인덱스를 타지만, OR로 연결되면 테이블 풀 스캔을 선택할 수 있다.
풀 테이블 스캔 + 인덱스 레인지 스캔의 작업량보다 풀 테이블 스캔이 빠른 경우 풀 테이블 스캔을 선택한다.
AND로 연결되면 읽어야 할 레코드를 줄이는 역할을 하지만, OR인 경우 비교 할 레코드가 더 늘어나기에 WHERE 절 OR은 주의해서 사용하자!
```

#### 11.4.2.3 GROUP BY 절의 인덱스 사용
```text
GROUP BY 절은 비교 연산자 쓰지 않으므로 '작업 범위 결정 조건', '체크 조건'을 구분해서 생각할 필요가 없다.
- GROUP BY 절 명시한 컬럼 순서와 인덱스 구성 컬럼 순서가 같으면 인덱스 이용 가능하다. 
- 인덱스 앞에 명시된 앞에 컬럼 순서대로 GROUP BY 절에 명시되어야 하며, 인덱스 구성 컬럼 뒷 부분은 GROUP BY 절에 몇 개 없어도 인덱스를 이용 가능하다.
- GROUP BY 절에 사용한 컬럼이 인덱스 구성 컬럼에 포함되지 않는다면 인덱스 이용 불가능하다. 
```

#### 11.4.2.4 ORDER BY 절의 인덱스 사용
```text
ORDER BY 절과 GROUP BY 절의 인덱스 사용 요건은 흡사하다.
하지만 ORDER BY 절에 조건이 하나 더 있는데, 정렬 컬럼의 ASC, DESC 옵션이 인덱스와 같거나 정반대인 경우에 사용 할 수 있다.
인덱스의 컬럼 정렬과 ORDER BY의 정렬 방식이 다르면 인덱스를 사용하지 못한다.
```

#### 11.4.2.5 WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용
```text
쿼리 문장에 WHERE, ORDER BY, GROUP BY 중 하나만 쓰인다면, 사용된 절에 초점을 인덱스를 튜닝하면 된다.
하지만 보통 애플리케이션에 사용되는 쿼리 문장은 간단하지 않다.

- WHERE 절 + ORDER BY 절 같이 사용하는 경우 세 가지 방법 중 한 가지로 인덱스를 이용한다.
 1. WHERE 절과 ORDER BY 절이 동시에 같은 인덱스 이용
   - 이 방식은 나머지 방식보다 훨씬 빠른 성능을 보여준다. 따라서 이 방식으로 유도하여 튜닝하거나 인덱스를 생성하는 것이 좋다.
 2. WHERE 절만 인덱스를 이용
   - ORDER BY 절은 인덱스 이용 정령 불가능하다. 즉 인덱스를 통해 검색된 결과들을 별도 정렬 처리 과정(Using Filesort)를 거려 정렬을 수행한다.
   - 주로 WHERE 절 조건에 일치하는 레코드가 수가 많지 않을 때 효율적인 방식이다.
 3. ORDER BY 절만 인덱스 이용
   - ORDER BY 절의 순서대로 인덱스를 읽으며 한 건씩 WHERE 절 조건에 일치하는지 비교 후 일치하지 않을 때 버리는 형태로 처리한다.
   - 주로 아주 많은 레코드 조회 후 정렬해야 할 때 이런 형태로 튜닝을 한다.   
- WHERE 절 동등 조건 비교 컬럼과 ORDER BY 절 명시 컬럼 순서가 모두 일치해야 한다.
```
```sql
-- 예제 -> 인덱스 생성 (COL1 ASC, COL2 ASC, COL3 ASC, COL4 ASC)
-- 동등 조건 예제
SELECT
    *
FROM
    TEST
WHERE  
    COL1 = 10
ORDER BY COL2, COL3;

/*
얼핏 보면 위 예제의 ORDER BY 절은 첫 인덱스가 없기 때문에 인덱스를 이용하지 못 한다고 생각할 수 있지만 WHERE 조건이 상수로 동등 비교를
하기 때문에 ORDER BY COL1, COL2, COL3과 정렬 순서에 변화가 없다.
즉, MySQL 옵티마이저는 인덱스를 적절히 사용 가능하도록 실행 계획을 수립한다.
*/

-- 범위 조건 예제1 -> 범위 조건이지만, ORDER BY에 인덱스 생성 순서대로 모두 명시 됐기에 인덱스를 사용해 WHERE, ORDER BY 절 처리 가능
SELECT
    *
FROM
    TEST
WHERE
    COL1 > 10
ORDER BY COL1, COL2, COL3;

-- 범위 조건 예제2 -> 범위 조건인데, ORDER BY 절에 인덱스 생성 순서대로 컬럼이 명시되지 않아 인덱스 이용 불가능
SELECT
    *
FROM
    TEST
WHERE
    COL1 > 10
ORDER BY COL2, COL3;
```

#### 11.4.2.6 GROUP BY 절과 ORDER BY 절의 인덱스 사용
```text
ORDER BY, GROUP BY 두 절이 모두 하나의 인덱스를 사용하기 위해서는 각 절에 명시된 컬럼의 순서가 같아야 한다.
두 절 중 하나라도 인덱스 이용 불가능할 때 둘 다 인덱스 사용 불가능하다.

5.7까지는 GROUP BY는 명시 컬럼에 대한 정렬까지 함께 수행했지만, 8.0부터 정렬을 보장하지 않는 형태로 변경됐다.  
```

#### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
```text
- WHERE, GROUP BY, ORDER BY가 모두 포함된 SQL 문장에 인덱스 사용 여부를 판단하기 위해 3가지를 살펴보면 된다. (P.65 참고)
 1. WHERE 절이 인덱스를 사용할 수 있는가?
 2. GROUP BY 절이 인덱스를 사용할 수 있는가?
 3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가? 
 
앞서 말했듯 GROUP BY, ORDER BY 두 절 중 하나라도 인덱스를 사용 못하면 두 절 모두 인덱스를 사용하지 못한다.
결국 세 절 모두 사용 가능, WHERE 절만 사용 가능, (GROUP BY, ORDER BY) 사용 가능, 인덱스 사용 못함으로 구분된다. 
```

### 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항
```text
쿼리 최적 실행을 위해 적합한 인덱스와 함께 WHERE 절의 비교 조건 표현식을 적절히 사용해야 한다.
```

#### 11.4.3.1 NULL 비교
```text
MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다. 즉 NULL을 하나의 값으로 인정한다.
쿼리 NULL 비교시 IS NULL 또는 <=> 연산자를 사용해야 한다. 
인덱스 컬럼을 IS NULL 조건을 주는 경우 인덱스를 이용가능하게 할 수 있다.
```

#### 11.4.3.2 문자열이나 숫자 비교
```text
문자열이나 숫자 컬럼 비교시 반드시 그 타입에 맞는 상수값 사용이 권장된다.
형변환이 일어나면 인덱스를 타지 못하게 된다.
옵티마이저는 숫자 타입 비교가 우선순위를 가진다. 
따라서 숫자 = 문자는 성능 저하는 발생하지 않고, 문자 = 숫자인 경우 인덱스를 이용하지 못한다.

옵티마이저의 타입 변환 유도 방식을 정확히 아는 것도 필요하지만, 컬럼 타입에 맞는 상수 리터럴 비교하는 것도 중요하다.
```

#### 11.4.3.3 날짜 비교
```text
DATE 타입: 날짜만 저장
DATETIME, TIMESTAMP 타입: 날짜와 시간을 함께 저장
TIME 타입: 시간만 저장  
```

##### 11.4.3.3.1 DATE 또는 DATETIME과 문자열 비교
```text
DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 자동으로 DATETIME 타입 변환 후 비교 수행
```

```sql
-- 밑에 두 쿼리는 동일하게 해석된다.
SELECT COUNT(*)
FROM EMPLOYEES
WHERE hire_Date > STR_TO_DATE('2010-09-09', '%Y-%m-%d');

SELECT COUNT(*)
FROM EMPLOYEES
WHERE hire_Date > '2010-09-09';

-- 그러나 밑에 쿼리는 데이트 타입을 강제적으로 문자열로 변경해서 인덱스를 효율적으로 이용하지 못한다.
SELECT COUNT(*)
FROM EMPLOYEES
WHERE DATE_FORMAT(hire_date, '%Y-%m-%d') > '2010-09-09';
```

##### 11.4.3.3.2 DATE와 DATETIME의 비교
```sql
DATETIME 값에서 날짜만 비교하기 위해서는 DATE() 함수를 사용하면 된다. 
DATE 타입으로 변환 후 비교하는 것이 아니라, 타입을 유지하면서 DATETME과 비교하는 경우 
MySQL 서버가 DATE 타입의 값을 DATETIME으로 변환해서 같은 타입만든 다음 비교한다. ('2020-09-09 00:00:00')
```

##### 11.4.3.3.3 DATETIME과 TIMESTAMP 비교
```text
DATE, DATETIME과 TIMESTAMP 값을 타입 변환없이 비교하는 경우 FROM_UNIXTIME(), UNIX_TIMESTAP() 함수 이용하여
비교 대상 타입으로 변환 후 비교하거나 NOW() 함수를 이용하면 된다. 
```

#### 11.4.3.4 Short-Circuit Evaluation
```text
if (A() && B()) -> A()가 false면 B()는 호출하지 않는다. 
여러 개 표현식이 AND 또는 OR로 연결된 경우 선행 표현식 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화를
Short-Circuit Evaluation라고 한다.
WHERE 조건에서 A, B를 비교했을 때 A에 대한 조건이 0건이 나오면 B 조건은 호출되지 않는다.
하지만 WHERE 조건 중 인덱스 사용 조건이 있다면 Short-Circuit Evaluation와 무관하게 그 조건을 최우선 사용한다.
인덱스 사용 가능 조건을 먼저 비교하고 그 다음 순서대로 비교한다.
```

### 11.4.4 DISTINCT
```text
DISTINCT를 남용하는 경우 성능적인 문제도 있지만, 결과도 의도한 바와 달라질 수 있다.
```

### 11.4.5 LIMIT n
```text
LIMIT을 통해 쿼리 결과에서 지정된 순서에 위치한 레코드를 가져올 수 있다.  
```

```sql
-- LIMIT 예제
SELECT * FROM EMPLOYEES
WHERE emp_no BETWEEN 10001 AND 10010
ORDER BY first_name
LIMIT 0, 5;
```

```text
- 위 쿼리 예제 실행 순서
 1. EMPLOYEES 테이블에서 WHERE 조건 일치 레코드를 전부 읽어온다.
 2. 읽어온 레코드들을 first_name 컬럼 값에 따라 정렬
 3. 정렬된 결과에서 상위 5건 반환
 
오라클 ROWNUM에 익숙하다면 위체 실행 순서가 이상할 수 있다.  
그러나 MySQL에서는 LIMIT은 WHERE 절 조건이 아니다. 따라서 항상 쿼리 가장 마지막에 실행된다.

MySQL LIMIT은 필요한 레코드 건수만 준비되면 즉시 쿼리가 종료된다.
즉 위 쿼리에서 모든 레코드의 정렬이 완료되지 않아도 상위 5건만 정렬되면 작업을 멈춘다.
```

```sql
-- GROUP BY, DISTINCT와 같이 LIMIT이 사용되는 경우 동작 방식 확인
-- (1)
SELECT * FROM EMPLOYEES LIMIT 0, 10;
-- (2)
SELECT * FROM EMPLOYEES GROUP BY first_name LIMIT 0, 10;
-- (3)
SELECT DISTINCT first_name FROM EMPLOYEES LIMIT 0, 10;

-- (4)
SELECT * FROM EMPLOYEES
WHERE emp_no BETWEEN 10001 AND 11000
ORDER BY first_name
LIMIT 0, 10;
```
```text
(1) - LIMIT이 없는 경우 풀 테이블 스캔 실행한다. 그러나 LIMIT이 있는 경우 풀 테이블 스캔을 실행하면서 10개의 레코드를 읽는 순간 읽기 작업을 멈춘다.
따라서 정렬, 그루핑, DISINCT가 없는 경우 LIMIT 조건을 통해 쿼리 성능을 올릴 수 있다.

(2) - GROUP BY 처리 완료 후 LIMIT 처리를 수행 가능하다. 인덱스를 못타는 GROUP BY는 그루핑과 정렬 특성을 모두 가지기에, 완료 후 LIMIT 수행이 가능하다.
따라서 GROUP BY와 함께 LIMIT이 사용되는 경우 실질적 서버 작업을 크게 줄이지 못한다.

(3) - 정렬 조건 없이 유니크한 그룹만 만들면 된다. MySQL 스토리지 엔진은 풀 테이블 스캔을 이용해 레코드를 읽어들임과 동시에 DISTINCT를 위한 중복 제거 작업(임시 테이블 사용)을 진행한다.
반복 수행을 하면서 유니크 레코드가 LIMIT만큼 채워지면 쿼리를 멈춘다. 
따라서 DISTINCT, LIMIT을 함께 사용하면 실질적 중복 제거 작업 범위를 줄이는 역할을 한다. -> 10만건 읽을 작업을 10건을 읽어 완료하게 할 수 있게 된다.

(4) - WHERE 조건 일치 레코드를 읽은 후 정렬 조건으로 정렬을 수행하면서, 필요한 레코드를 다 읽으면 작업을 멈추고 결과를 반환한다.
읽어온 결과가 전부 정렬되는 것이 아니라 필요한 만큼만 정렬된다. 하지만 이 쿼리도 크게 작업량을 줄여주지는 못한다.

ORDER BY, GROUP BY가 사용되더라도 LIMIT 절이 있다면 크진 않지만 성능 향상은 있다.
따라서 LIMIT 절을 통해 꼭 필요한 만큼의 레코드만 읽게 만들어 주는 것이 중요하고 필요하다.

LIMIT 절은 두 개의 인자를 사용 할 수 있는데, 인자가 한 개인 경우 상위 n개 레코드를 가져오고, 두 개인 경우 첫 인자 지정 위치부터 두 번째 인자 명시된 개수만큼 레코드를 가져온다.
주의할 점은 인자 두 개를 사용할 경우 첫 번째 인자(시작 위치, 오프셋)는 0부터 시작한다.

실제 쿼리 성능은 이용자 화면에 레코드 몇 건을 출력하느냐보다 MySQL 서버가 그 결과를 만들어 내기 위해 어떠한 작업들을 했는지가 중요하다.
LIMIT의 "n"과 "m"에 주어지는 수치가 매우 커지면 쿼리 실행 시간이 오래 걸린다. 
LIMIT 200,0000, 10을 사용하는 경우 테이블을 처음부터 읽으면서 200,0010건을 읽은 후 200,0000을 버리고 마지막 10건만 사용자에게 반환한다.
따라서 실제 이용자 화면에는 10건을 보여줘야 하지만, 서버에서 200,0010건을 읽게 되는 것이다.
이런 경우 WHERE 절 조건을 이용해서 시작 지점 위치를 찾아 그 지점부터 10건만 읽는 형태로 쿼리를 작성하는 것이 좋다.
```

### 11.4.6 COUNT()
```text
COUNT() 함수는 컬럼이나 표현식을 인자로 받는다. COUNT(*)에서 "*"는 SELECT * 처럼 모든 컬럼을 말하는 것이 아니라, 레코드 자체를 의미한다.
그래서 굳이 COUNT(PK), COUNT(1)을 사용하지 않고 *을 사용해도 동일한 처리 성능을 보인다.
COUNT(col1)로 하는 경우는 col1이 null이 아닌 레코드 건수를 반환한다.
MyISAM의 경우 메타 정보에 전체 레코드 건수를 관리하기에 WHERE 조건이 없는 경우 레코드 건수를 세어보지 않고 반환이 가능하다. 
WHERE 조건이 있는 경우 일반적인 DBMS와 같이 처리된다.

InnoDB 스토리지 엔진은 WHERE 조건이 없어도 직접 데이터나 인덱스를 읽어야 레코드 건수를 가져오기에 큰 테이블 COUNT() 함수 작업은 주의를 해야한다.
그래서 대략적인 테이블 건수(정확하진 않음)가 필요한 경우 COUNT()보단 SHOW TABLE STATUS 명령으로 통계 정보를 참조하는 것도 좋은 방법이다.

단순 페이징 쿼리 처리를 위해, 일반 SELECT 문장과 같은 조건으로 사용하는 경우가 많다. COUNT(*)만 실행함에도 ORDER BY가 포함돼 있다거나
COUNT()에 필요하지 않은 LEFT JOIN을 그대로 남겨두는 경우가 있는데, 모두 제거하는 것이 성능상 좋다.

8.0부터 COUNT(*)에 사용된 ORDER BY 절은 옵티마이저가 무시하도록 개선됐다.

일반 컬럼 SELECT 쿼리보다 COUNT(*)가 훨씬 빠르게 실행될 것이라 생각한다. 
하지만 인덱스를 제대로 사용하지 못하는 COUNT(*)는 느릴 수 있다. 많은 부하 유발 가능성이 있기에 주의해야 한다.
```

### 11.4.7 JOIN
```text
JOIN이 어떻게 인덱스를 사용하는지에 대해 쿼리 패턴별로 자세히 살펴봅씨다~
```

#### 11.4.7.1 JOIN의 순서와 인덱스
```text
인덱스 레인지 스캔은 '인덱스 탐색 단계'와 '인덱스 스캔' 과정으로 구분해 볼 수 있다.
일반적으로 인덱스 이용 쿼리 작업은 레코드 건수가 소량이기에 부하가 적지만, 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높다.

조인 작업시 드라이빙 테이블을 읽을 때 인덱스 탐색 작업을 단 한 번만 수행하고, 이후에는 스캔만 실행하면 된다. 
하지만 드리븐 테이블은 인덱스 탐색 작업과 스캔 작업을 읽은 레코드 수만큼 반복한다. 
드라이빙 테이블, 드리븐 테이블이 1:1 조인돼도 드리븐 테이블 읽는 것이 더 큰 부하를 갖는다.
```

```sql
SELECT *
FROM EMPLOYEES e, DEPT_EMP de
WHERE e.emp_no = de.emp_no;
```

```text
위 쿼리 예제에서 두 테이블의 emp_no 컬럼에 각각 인덱스가 있을 때와 없을 때 조인 순서가 어떻게 달라지는지 확인해보자.

1. 두 컬럼 모두 인덱스가 있는 경우
    - 어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블을 빠리게 처리 가능하다. 옵티마이저는 통계 정보(레코드 건수)를 이용해 적절히 드라이빙 테이블을 선택한다.
     옵티마이저가 선태갛는 방법이 최적일 때가 많다.

2. EMPLOYEES 테이블의 컬럼만 인덱스가 있는 경우
    - DEPT_EMP 테이블이 드리븐 테이블로 선택된다면, EMPLOYEES 레코드 수만큼 풀 테이블 스캔을 해야만 WHERE 조건 일치 레코드를 찾을 수 있다. 
    그래서 옵티마이저는 항상 DEPT_EMP 테이블을 드라이빙 테이블로 선택하고, EMPLOYEES 테이블에 효율적인 접근을 위한 조건이 있더라도 옵티마이저는 
    EMPLOYEES 테이블을 드리븐 테이블로 선택할 가능성이 높다.

3. DEPT_EMP 테이블의 컬럼만 인덱스가 있는 경우
    - 2번과 반대로 처리된다. 즉 DEPT_EMP 테이블을 드리븐 테이블로 선택할 가능성이 높다.
    
4. 두 컬럼 모두 인덱스가 없는 경우
    - 어떤 테이블을 드라이빙 테이블로 선택하더라도 드리븐 테이블의 풀 테이블 스캔이 발생하기 때문에 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다.
    적절한 인덱스가 없는 경우 8.0.18 이전까진 블록 네스티드 루프 조인을 사용 했으나, 이후 버전부터 해시 조인으로 처리된다. 
```

#### 11.4.7.2 JOIN 컬럼의 데이터 타입
```text
조인 컬럼 간 비교에서도 데이터 타입이 일치하지 않으면 효율적인 인덱스 이용이 불가능하다.
즉 인덱스 레인지 스캔이 예상되도 테이블 풀 스캔으로 접근하고, 실행 계획을 보면 드리븐 테이블의 Extra 컬럼에
"Using join buffer (hash join)"가 표시된다. 
- 데이터 타입의 불일치에 영향을 주지 않을 수 있다.
  1. CHAR와 VARCHAR
  2. INT와 BIGINT
  3. DATE와 DATETIME
```

#### 11.4.7.3 OUTER JOIN의 성능과 주의사항
```text
MySQL 옵티마이저는 아우터 조인되는 테이블을 드라이빙 테이블로 선택하지 못한다.
따라서 이너 조인을 사용하면 옵티마이저가 조인 순서를 변경하면서 수행할 수 있는 최적화를 해주기 떄문에 쿼리 성능 향상 가능

OUTER JOIN 조건을 WHERE 절에 함께 명시하는 것은 잘못된 조인 방법이다.  
LEFT JOIN을 사용하면서 조인되는 테이블의 조건을 WHERE 절에 명시할 경우 MySQL 옵티마이저가 INNER JOIN으로 변환해서 실행해버릴 수 있다.
따라서 정상적인 OUTER JOIN을 만들기 위해서는 아우터 조인의 조건을 WHERE 절에서 ON 절로 이동시켜야 한다. 
```
```sql
-- WHERE 절 조건을 ON 절로 옮겨야 한다.
SELECT *
FROM EMPLOYEES e
LEFT JOIN DEPT_MANAGER dm
    ON dm.emp_no = e.emp_no
WHERE dm.dept_no = 'd001';

-- OUTER JOIN 조건이 WHERE 절에서 사용 가능한 유일한 경우: 안티 조인 효과를 기대하는 경우
-- 사원 중 매니저가 아닌 사람만 조회하는 쿼리 
SELECT *
FROM EMPLOYEES e
LEFT JOIN DEPT_MANAGER dm 
    ON dm.emp_no = e.emp_no
WHERE dm.emp_no IS NULL
LIMIT 10;
```

#### 11.4.7.4 JOIN과 외래키(FOREIGN KEY)
```text
DB에 외래키 생성 없이도 조인은 가능하다. 외래키는 조인과 아무런 연관이 없다.
외래키 생성 목적은 데이터 무결성을 보장하기 위함이다. (참조 무결성)
ex) 부서, 사원 테이블에서 사원의 소속된 부서 코드는 반드시 테이블에 존재해야 한다.
이렇게 참조 무결성이 깨지는 문제를 DBMS 차원에서 막기 위해 외래키를 생성한다.

전혀 무관한 컬럼끼리 조인해도 문법적으로 문제되지 않는다.
테이블 간의 조인을 사용하기 위해 외래키가 필요한 것은 아니다.
```

#### 11.4.7.5 지연된 조인 (Delayed Join)
```text
조인할 때 데이터 조회 쿼리에 GROUP BY, ORDER BY를 포함해도 각 처리 방법에 맞게 인덱스 사용한다면 이미 최적 처리 가능성이 높다.
그렇지 않다면, 우선 모든 조인을 실행 후 GROUP BY나 ORDER BY를 처리한다.
지연된 조인이란 조인 실행 전 GROUP BY나 ORDER BY를 처리하는 방식을 말하며, LIMIT과 함께 사용시 더 큰 효과를 얻을 수 있다. 
```
```sql
-- 인덱스 사용 안 하는 지연 조인 처리 예제
SELECT e.*
FROM 
    SALARIES s, EMPLOYEES e
WHERE
    e.emp_no = s.emp_no
    AND s.emp_no BETWEEN 10001 AND 13000
GROUP BY s.emp_no
ORDER BY SUM(s.salary) DESC
LIMIT 10;
```
```text
실행계획상 EMPLOYEES가 드라이빙 테이블이 되고, 조건 만족 3,000건을 읽고 SALARIES 테이블과 조인한다. 
조인 결과 읽은 레코드를 임시 테이블에 저장하고 GROUP BY 처리를 통해 3,000건으로 줄이고 ORDER BY를 통해 상위 10건만 최종 반환
```
```sql
-- 지연된 조인 
SELECT e.*
FROM
    (
        SELECT s.emp_no
        FROM SALARIES s
        WHERE
            s.emp_no BETWEEN 10001 AND 13000
        GROUP BY s.emp_no
        ORDER BY SUM(s.salary) DESC
        LIMIT 10
    ) x,
    EMPLOYEES e
WHERE
    e.emp_no = x.emp_no;
```
```text
위 지연된 조인 예제는 SALARIES 테이블에서 가능한 모든 처리 (WHERE 조건, GROUP BY, ORDER BY, LIMIT) 수행 후 결과를 임시 테이블에 저장한다.
그리고 임시 테이블 결과를 EMPLOYEES 테이블과 조인한다. 즉 모든 처리를 앞에서 수행하고 최종 10건만 EMPLOYEES 테이블과 조인한다.

실행계획을 보면 FROM 절 서브 쿼리 사용으로 파생 테이블(DERIVED)가 생겨나고, FROM 절 서브쿼리를 위해 전체 56,844 레코드를 
읽어야 한다고 나오지만 사실 28,606건의 레코드만 읽으면 되는 쿼리다.

지연된 조인으로 인해 s 테이블의 28,606건을 읽어 임시 테이블 저장 후 GROUP BY 처리를 통해 3,000건으로 줄인다. (P.92 참조)
그리고 ORDER BY를 통해 상위 10건만 임시 테이블에 저장하고, 10건과 e 테이블과 조인을 10번만 수행해서 결과 반환

지연된 조인이 임시 테이블을 한 번 더 사용하지만, 저장 레코드가 10건밖에 되지 않으므로 메모리를 이용해 빠르게 처리된다.
결과적으로 조인 횟수가 훨씬 적어졌다. 실제 테스트시 지연 조인 쿼리가 3 ~ 4배 정도 빠르게 실행되는 것 확인 가능

모든 조인을 지연된 조인 형태로 개선 가능한 것은 아니다. 다음과 같은 조건이 갖춰줘야만 한다.
1. LEFT JOIN의 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야 한다.
2. INNER JOIN의 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계임과 동시에 드라이빙 테이블 레코드는 드리븐 테이블에 모두 존재해야 한다.
   그리고 드라이빙 테이블을 서브 쿼리로 만들고, 서브 쿼리에 LIMIT을 추가해도 최종 결과 건수가 변하지 않는다는 보증이 있어야 한다.
```

#### 11.4.7.6 래터럴 조인 (Lateral Join)
```text
8.0부터 래터럴 조인 특징을 이용해 특정 그룹 별 서브쿼리 실행해서 그 결과 조인하는 것이 가능하다.
즉 그룹 별 몇 건씩만 가져오는 쿼리 작성이 가능하다.
```
```sql
SELECT *
FROM
    EMPLOYEES e
    LEFT JOIN LATERAL ( 
        SELECT *
        FROM
            SALARIES s
        WHERE s.emp_no = e.emp_no
        ORDER BY s.from_date DESC LIMIT 2
    ) s2
        ON s2.emp_no = e.emp_no
WHERE e.first_name = 'Matt';
```
```text
LATERAL 키워드의 서브쿼리는 조인 순서상 후순위로 밀린다. 
즉 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기에 꼭 필요한 경우에만 사용해야 한다.
```

#### 11.4.7.7 실행 계획으로 인한 정렬 흐트러짐
```text
8.0 부터는 네스티드-루프 방식 조인 뿐만 아니라 해시 조인 방식이 도입됐다. 
네스티드-루프 특성상 드라이빙 테이블에서 읽은 레코드의 순서가 다른 테이블이 모두 조인돼도 그대로 유지된다.

하지만 해시 조인 사용시 쿼리 결과의 레코드 정렬 순서가 달라진다.

정렬 결과가 필요한 경우 드라이빙 테이블 순서에 의존하지 말고 ORDER BY를 이용해야 한다.
```

### 11.4.8 GROUP BY
```text
특정 컬럼으로 레코드를 그루핑하거나 그룹별 집계 결과 하나의 레코드로 조회할 때 사용한다.
```

#### 11.4.8.1 WITH ROLLUP

#### 11.4.8.2 레코드를 컬럼으로 변환해서 조회

##### 11.4.8.2.1 레코드를 칼럼으로 변환

##### 11.4.8.2.2 하나의 칼럼을 여러 칼럼으로 분리

### 11.4.9 ORDER BY
```text
ORDER BY 절이 사용되지 않을 때 SELECT 쿼리 결과는 어떤 순서로 졍렬될까?
- 인덱스 사용 SELECT의 경우 인덱스에 정렬된 순서대로 레코드를 가져온다.
- 풀 테이블 스캔 SELECT의 경우 InnoDB의 경우 항상 PK로 클러스터링돼 있기 때문에 PK순으로 레코드를 가져온다.
- 임시 테이블을 거쳐 처리되면 조회 레코드 순을 예측하기 어렵다.

ORDER BY가 없다면 처리 절차에 따라 순서가 다르다.

ORDER BY 절에서 인덱스를 사용하지 못할 때 추가 정렬 작업이 수행되는데, 실행 계획에서 "Using filesort" 코멘트 표시된다.
이는 디스크 파일 이용해 정렬을 수행한다는 의미는 아니고, 쿼리 수행 도중 MySQL 서버가 명시적 정렬 알고리즘 수행 했다는 의미 정도로 생각하자. 
```

#### 11.4.9.1 ORDER BY 사용법 및 주의사항
```text
ORDER BY 절에 문자열 상수를 사용하는 경우 옵티마이저는 ORDER BY 절 자체를 무시한다.
```

#### 11.4.9.2 여러 방향으로 동시 정렬
```text
8.0부터 오름차순 내림차순 혼용해서 인덱스 생성 가능 
```

#### 11.4.9.3 함수나 표현식을 이용한 정렬

### 11.4.10 서브쿼리
```text
8.0부터 서브 쿼리 처리가 많이 개선 됐다. 
사용되는 위치에 따라 쿼리 성능 영향도와 MySQL 서버 최적화 방법은 완전히 달라진다.
```

#### 11.4.10.1 SELECT 절에 사용된 서브쿼리
```text
서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의사항 없다.

일반적으로 항상 칼럼과 레코드가 하나인 결과를 반환해야 한다.
하지만 MySQL의 체크 조건은 느슨하다.
- 서브 쿼리 결과가 0건이어도 NULL로 채워져 반환
- 2건 이상 반환시 에러나고 쿼리 종료
- 2개 이상 컬럼 반환시 에러 발생
즉, 로우 서브쿼리는 사용하지 못하고 스칼라 서브쿼리만 사용 가능

서브 쿼리보다 조인 처리가 조금 더 빠르기 때문에 조인으로 가능하면 조인 사용이 권장된다.
또한 래터럴 조인을 사용하여 무분별한 SELECT 서브 쿼리를 줄일 수 있다. 즉 테이블을 더 적게 읽고 쿼리 처리가 가능하다.
```

#### 11.4.10.2 FROM 절에 사용된 서브쿼리
```text
기존에는 서브 쿼리 결과를 임시 테이블 저장하고 필요할 때 읽는 방식으로 처리 됐으나 
5.7부터 옵티마이저가 FROM 절 서브 쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선됐다.
개선은 From 절 서브쿼리 뿐만 아니라 뷰도 마찬가지로 개선됐다.

FROM 절 모든 서브 쿼리를 외부 쿼리로 병합할 수 있는 것은 아니다. 
다음 항목들이 사용되면 FROM 절 외부 쿼리로 병합되지 못한다. 
1. 집합 함수 사용 (SUM, MIN, MAX, COUNT)
2. DISTINCT
3. GROUP BY, HAVING
4. LIMIT
5. UNION 또는 UNION ALL
6. SELECT 절에 서브쿼리 사용된 경우
7. 사용자 변수 사용 (값 동적 할당)

FROM 절 서브쿼리가 ORDER BY를 가진 경우
외부 쿼리에서 GROUP BY, DISTINCT를 사용한다면 서브 쿼리 정렬 작업은 무의미하기 때문에 서브 쿼리의 ORDER BY는 무시된다. 
```

#### 11.4.10.3 WHERE 절에 사용된 서브쿼리
```text
크게 다음 3가지로 구분해 살펴보자.
1. 동등 또는 크다, 작다 비교 where a = (subquery)
2. IN 비교 where a IN (subquery)
3. NOT IN 비교 where a NOT IN (subquery)
```

##### 11.4.10.3.1 동등 또는 크다 작다 비교
```sql
SELECT *
FROM DEPT_EMP de
WHERE
    de.emp_no = (
        SELECT e.emp_no
        FROM EMPLOYEES e
        WHERE 
            e.first_name = 'Georgi'
            AND e.last_name = 'Facello' 
        LIMIT 1
    );
```
```text
5.5 버전까지는 위 쿼리의 경우 DEPT_EMP 테이블을 풀 스캔 하면서 서브쿼리 조건 일치여부 체크
5.5부터 서브쿼리 먼저 실행 후 상수로 변환하고 상수 값으로 서브 쿼리를 대체해서 나머지 쿼리 부분 처리

위 예제는 동등비교지만, 크다 작다도 동일하게 처리된다.
```

##### 11.4.10.3.2 IN 비교 ( IN (subquery) )
```text
실제 조인이 아니지만 한 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지 체크 하는 형태를 세미조인이라고 하는데,
WHERE 절 IN (subquery) 형태의 조건을 조인의 한 방식인 세미 조인이라고 본다.

5.5 까지 세미 조인 최적화가 매우 부족해 대부분 테이블 풀 스캔을 했다.
5.6 ~ 8.0까지 많은 최적화가 이루어졌다. 더이상 안티 패턴이 아니다.

MySQL 세미 조인 최적화는 조인 관계에 맞게 아래의 다섯 가지 최적화 전략을 선택해 사용한다.
1. 테이블 풀 아웃
2. 퍼스트 매치
3. 루스 스캔
4. 구체화
5. 중복 제거
```

##### 11.4.10.3.3 NOT IN 비교 ( NOT IN (subquery) )
```text
IN과 비슷한 형태지만, 안티 세미조인이라고 명명한다.
최적화 할 방법이 많지 않다.

옵티마이저는 두 가지 방법으로 최적화를 수행
1. NOT EXISTS
2. 구체화
그러나 성능 향상에 크게 도움되진 않는다.
WHERE 절 단독으로 안티 세미 조인 조건만 있다면 풀 테이블 스캔을 피할 수 없다.
```

### 11.4.11 CTE (Common Table Expression)
```text
임시 테이블이다. 문장 종료시 CTE 임시 테이블은 삭제된다.
CTE는 재귀적 반복 시행 여부를 기준으로 Non-Recursive와 Recursive로 구분된다.

CTE로 생성된 임시 테이블은 다른 CTE 쿼리에서도 참조할 수 있다는 장점이 있다. 
```

#### 11.4.11.1 비 재귀적 CTE (Non-Recursive CTE)
```text
CTE를 재귀적으로 사용하지 않더라도 FROM 절 서브쿼리에 비해 세 가지 장점이 있다.
1. 임시 테이블은 재사용 가능
2. CTE는 다른 CTE에서도 참조 가능
3. CTE 생성과 사용 분리로 가독성이 높다.

비 재귀적 CTE는 단순히 쿼리를 한 번 실행 후 결과를 임시 테이블에 저장한다.
```

#### 11.4.11.2 재귀적 CTE (Recursive CTE)
```text
재귀적 CTE는 쿼리 결과가 없을 때 까지 반복 실행한다.
작동 방식을 살펴보자.
1. CTE 쿼리의 비 재귀적 파트 쿼리 실행
2. 1번 결과를 이용해 cte 이름 임시 테이블 생성
3. 1변 결과를 cte에 저장
4. 1번 결과를 입력으로 사용해 CTE 쿼리 재귀적 파트 쿼리 실행
5. 4번 결과를 cte 임시 테이블에 저장 (UNION, UNION DISTINCT의 경우 중복 제거 실행)
6. 전 단계 결과를 입력으로 사용해 CTE 쿼리 재귀적 파트 쿼리 실행
7. 6번 단계 결과 없으면 쿼리 종료
8. 6번 결과 cte 임시 테이블에 저장
9. 6번으로 돌아가서 반복 실행
```

#### 11.4.11.3 재귀적 CTE (Recursive CTE) 활용
```text
재귀적 쿼리 활용 가능 업무는 상당히 많다.
1. 단순히 1부터 단조 증가 값을 가지는 임시 테이블
2. 일 단위 증가 날짜 임시 테이블 생성
3. 조직도 조회
4. 등등등등

CTE를 사용하는 방법을 자세히 공부해두면 개발에 많은 도움이 될 것이다.
```

### 11.4.12 윈도우 함수 (Window Function)
```text
윈도우 함수는 조회 레코드 기준 연관된 레코드 집합의 연산을 수행한다.
```

#### 11.4.12.1 쿼리 각 절의 실행 순서
```text
윈도우 함수를 사용하여 나타나는 쿼리 결과는 FROM, WHERE, GROUP BY, HAVING 절에 의해 결정되고 그 이후 윈도우 함수가 실행된다.
그 후 SELECT, ORDER BY, LIMIT이 실행되어 최종 결과 반환

기본 쿼리 순서: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT
윈도우 함수: WHERE -> FROM -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT
    - WHERE, FROM 위치만 변경되는 듯?

쿼리 문장에 대한 실행 순서를 정확히 이해하고 있어야 한다. 그래야 정확한 쿼리 작성이 가능하다.
어떤 쿼리 실행 환경에서 어떻게 컬럼들을 활용할 수 있는지 잘 알아야 한다.
그래야 의도에 맞게 서브 쿼리를 활용하는 등의 행동으로 우회 사용 가능하다.
```

```sql
-- 예제 1
-- 서브쿼리 없이 LIMIT 5 -> 동등 조건 17건 레코드 가져온 후 윈도우 함수 실행하여 5건 반환
-- 즉 평균이 5건의 평균을 구한게 아니라 17건의 평균을 구하여 잘못된 결과를 반환할 수 있다.
SELECT
    emp_no,
    from_date,
    salary,
    AVG(salary) OVER() avg_salary
FROM
    salaries
WHERE
    emp_no = 10001
LIMIT 5;

-- 예제 2
-- 최종 5건의 평균이 정확히 나온다.
SELECT
    emp_no,
    from_date,
    salary,
    AVG(salary) OVER() avg_salary
FROM
    (
        SELECT * FROM salaries
        WHERE emp_no = 10001 
        LIMIT 5
    ) s2;
```

#### 11.4.12.2 윈도우 함수 기본 사용법

#### 11.4.12.3 윈도우 함수
| 집계 함수                         | 역할                     |
|-------------------------------|------------------------|
| AVG()                         | 평균 값 반환                |
| BIT_AND()                     | AND 비트 연산 결과 반환        |
| BIT_OR()                      | OR 비트 연산 결과 반환         |
| BIT_XOR()                     | XOR 비트 연산 결과 반환        |
| COUNT()                       | 건수 반환                  |
| JSON_ARRAYGG()                | 결과를 JSON 배열로 반환        |
| JSON_OBJECTGG()               | 결과를 JSON OBJECT 배열로 반환 |
| MAX()                         | 최댓값 반환                 |
| MIN()                         | 최솟값 반환                 |
| STDDEV_POP(), STDDEV(), STD() | 표준 편차 값 반환             |
| STDDEV_SAMP()                 | 표본 표준 편차 값 반환          |
| SUM()                         | 합계 값 반환                |
| VAR_POP(), VARIANCE()         | 표준 분산 값 반환             |
| VAR_SAMP()                    | 표본 분산 값 반환             |


| 비 집계 함수        | 역할                               |
|----------------|----------------------------------|
| CUME_DIST()    | 누적 표준 값 반환                       |
| DENSE_RANK()   | 랭킹 값 반환                          |
| FIRST_VALUE()  | 파티션 첫 레코드 반환                     |
| LAG()          | 파티션 내 파라미터(N)를 이용해 N번 째 이전 레코드 값 반환 |
| LAST_VALUE()   | 파티션 마지막 레코드 값 반환                 |
| LEAD()         | 파티션 내 파라미터(N)를 이용해 N번 째 이후 레코드 값 반환 |
| NTH_VALUE()    | 파티션의 n번째 값 반환                    |
| NTILE()        | 구글링                              |
| PERCENT_RANK() |     구글링                             |
| RANK()         |         구글링                         |
| ROW_NUMBER()   |             구글링                     |


##### 11.4.12.3.1 DENSE_RANK()와 RANK(), ROW_NUMBER()

##### 11.4.12.3.2 LAG()와 LEAD()

#### 11.4.12.4 윈도우 함수와 성능
```text
윈도우 함수는 MySQL 8.0 버전에 처음 도입됐다. 
```
```sql
-- 예제 1
SELECT 
    MAX(from_date) OVER(PARTITION BY emp_no) AS max_from_date
FROM salaries;

-- 예제 2
SELECT
    MAX(from_date)
FROM salaries
GROUP BY emp_no;
```
```text
위에 두 쿼리는 결과의 차이는 있지만 사용자별 MAX(from_date) 값을 구하는 쿼리다.
기본적으로 윈도우 함수 사용하면 많은 가공이 일어난다. 따라서 쿼리 성능도 좋을 수 없기 때문에 가급적 너무 의존하지 않는 것이 좋다.
배치 프로그램이라면 윈도우 함수 사용 무방하지만, OLTP 환경에서는 피하는 것이 좋다.
소량의 데이터는 딱히 성능에 대해 신경쓰지 않아도 된다.
```

### 11.4.13 잠금을 사용하는 SELECT
```text
InnoDB -> 테이블 SELECT시 레코드에 아무런 잠금도 걸지 않는다. 이를 잠금 없는 읽기라고 한다.
하지만 SELECT 실행된 후 다른 트랜잭션이 그 컬럼의 값을 변경하지 못하게 해야 한다. 
즉 레코드를 읽으면서 강제로 잠금을 걸어둘 필요가 있는데, 이 때 FOR SHARE와 FOR UPDATE 절이다.

- 두 설정은 모두 자동 커밋이 비활성화 상태 또는 BEGIN, START TRANSACTION 명령으로 트랜잭션이 시작된 상태에서 잠금 유지
FOR SHARE: SELECT 쿼리로 읽은 레코드에 대해 읽기 잠금을 건다. 
    - SELECT된 레코드에 대해 읽기 잠금을 걸어 다른 세션에서 해당 레코드를 변경하지 못하게 한다. 읽는 것은 가능하다.
FOR UPDATE: SELECT 쿼리가 읽은 레코드에 대해 쓰기 잠금을 건다.
    - 쓰기 잠금을 설정하고, 다른 트랜잭션에서 레코드를 변경 뿐 아니라 읽기도 수행할 수 없다.

참고: 8.0 이전에서는 LOCK IN SHARE MODE 절을 사용했지만, 이후 FOR SHARE로 변경됐다.

FOR UPDATE에 의해 잠겨진 상태더라도 FOR UPDATE, FOR SHARE를 가지지 않는 일반 SQL은 아무런 대기 없이 실행된다.
즉 다른 트랜잭션에서도 FOR UPDATE, FOR SHARE 옵션이 있어야 해당 옵션이 정상 동작한다.
```
```sql
SELECT * FROM WHERE emp_no = 10001 FOR SHARE;
SELECT * FROM WHERE emp_no = 10001 FOR UPDATE;
```

#### 11.4.13.1 잠금 테이블 선택
```text
쿼리 문장 안에 세 개 테이블(A, B, C)이 사용되고, 모두 조인으로 연결 됐다고 가정했을 때
A에만 쓰기 잠금을 걸고 싶다면 어떻게 해야될까?
8.0 이전에는 선택적 잠금 옵션이 없었지만, 
이후 버전에서 FOR UPDATE 또는 FOR SHARE 뒤 "OF 테이블" 절을 추가 하면 해당 테이블에 대해서만 잠금을 건다.
```

#### 11.4.13.2 NOWAIT & SKIP LOCKED
```text
8.0 부터 사용한 옵션이다.
누군가 레코드를 잠그고 있다면 다른 트랜잭션에서는 잠금 해제될 때 까지 기다려야 했다. 
하지만 이 방식이 서비스 이용자를 위해서는 적절하지 못한 방식일 때가 있다.

특정 애플리케이션에서 어떤 레코드가 잠겨진 상태라면 즉시 에러를 반환하고, 
다른 처리를 수행하거나 다시 트랜잭션을 시작하도록 구현해야 할 때가 있다.
이럴 때 SELECT 쿼리 마지막에 NOWAIT 옵션 사용!  
즉 다른 트랜잭션에 의해 잠겨진 상태라면 에러를 반환하며 쿼리를 즉시 종료한다.

SKIP LOCKED 옵션을 통해 잠겨진 레코드는 무시하고 그 외 레코드만 가져올 수 있다.

NOWAIT 또는 SKIP LOCKED 기능은 큐와 같은 기능을 MySQL 서버에서 구현하고자 할 때 매우 유용하다.
ex) 쿠폰 발급
    - 하나의 쿠폰은 한 이용자만 사용 가능
    - 쿠폰 개수는 1,000개 제한 - 선착순 발급
```

## 11.5 INSERT
```text
OLTP 환경에서 대부분은 레코드 한 건씩 등록하기 때문에 성능 고려 부분이 많지 않다. 
많은 INSERT 실행시 문장 자체보단 테이블 구조가 성능에 더 큰 영향을 미치는 경우가 더 많다. 
INSERT와 SELECT의 성능을 동시에 빠르게 만들 수 있는 테이블 구조는 없다. 
따라서 어느 정도 타협점을 찾아 테이블 구조를 설계해야 한다.
```

### 11.5.1 고급 옵션
```text
SELECT 문장만큼 다양하진 않다. 
대표적으로 INSERT IGNORE, INSERT ... ON DUPLICATE KEY UPDATE 옵션이 있다.

두 웁션 모두 유니크 인덱스나 PK에 대해 중복 레코드를 어떻게 처리할지 결정 
```

#### 11.5.1.1 INSERT IGNORE
```text
- 두 경우 무시하고 다음 레코드를 처리할 수 있다.
    1. 저장시 PK나 유니크 인덱스 칼럼의 값이 이미 존재하는 경우
    2. 저장 레코드의 칼럼이 테이블 컬럼과 호환되지 않는 경우
    
여러 레코드를 하나의 INSERT 문장으로 처리하는 경우 유용하게 사용 할 수 있는 옵션이다.

중복되는 레코드에 대해 에러를 경고 수준의 메시지로 변경하고 나머지 INSERT를 계속 진행할 수 있다.  
중복을 위해 옵션을 사용하게 될 때, 다른 에러 방향이 없는지 면밀히 살펴보고 적용하는 것이 좋다. 
의도하지 않은 에러까지 모두 무시해버릴 수 있다.
```

#### 11.5.1.2 INSERT .. ON DUPLICATE KEY UPDATE
```text
PK 또는 유니크 인덱스 중복 밠애시 UPDATE 역할을 수행하게 해준다.
MySQL - REPLACE와 비슷하지만, 이것은 내부적으로 DELETE + INSERT다.
INSERT .. ON DUPLICATE KEY UPDATE는 기존 레코드 삭제하지 않고, UPDATE 방식으로 작동한다.

최초 등록시 ON DUPL ...는 무시되고, 중복되는 경우가 있다면 INSERT 대신 ON DUPL ... 가 동작된다.
```

### 11.5.2 LOAD DATA 명령 주의 사항
```text
RDBMS 데이터 빠르게 적재하기 위해 LOAD DATA 사용하는데, 내부적으로 MySQL 엔진, 스토리지 엔진의 호출 횟수를 최소화하고,
스토리지 엔진이 직접 데이터 적재해서 일반적인 INSERT에 비교하여 매우 빠르다.

하지만 단점이 있다.
1. 단일 스레드 실행 - 적재 데이터가 많은 경우 시간이 매우 오래 걸릴 수 있다.
2. 단일 트랜잭션 실행 - 언두 로그가 삭제되지 못하고 유지돼야 한다. (언두 로그 -> 디스크 기록 해야하는 부하 + 필요 레코드를 찾는 데 더 많은 오버헤드 발생) 

적재 양이 아주 많지 않다면 단점은 크게 문제되지 않는다.
아주 많은 경우 OLTP 쿼리들의 성능에 영향을 받을 수 있다.

따라서 가능하다면 LOAD DATA 문장으로 적재할 데이터 파일을 하나보다는 여러 개 파일을 준비해서 
동시에 여러 트랜잭션으로 나뉘어 실행되게 하는 것이 좋다. 
```

### 11.5.3 성능을 위한 테이블 구조
```text
앞서 말했듯 INSERT 성능은 테이블 구조에 의해 많이 결정된다.
```

#### 11.5.3.1 대량 INSERT 성능
```text
INSERT 한 문장으로 데이터 수백, 수천 건을 등록할 때 PK 값 기준으로 미리 정렬 후 INSERT 문장 구성하는 것이 성능에 도움이 된다.
ex) A 테이블 데이터 CSV 덤프 -> B 테이블에 적재
- CSV 파일에 정렬 후 적재한 것이 정렬되지 않은 상태에서 적재하는 것 보다 2배 이상의 시간을 절약할 수 있다.
  - 랜덤 정렬의 경우 각 PK 값이 너무 달라 B-TREE 이곳저곳 랜덤 위치한 페이지를 메모리로 읽어와야 해서 처리가 더 느리다.

즉 INSERT 성능은 PK 정렬 여부에 따라 결정되지만, 이게 전부는 아니다. 
테이블의 세컨더리 인덱스는 SELECT 성능을 높이지만 INSERT 성능은 떨어진다.
그래서 INSERT 할 때 세컨더리 인덱스가 많고 레코드가 많을수록 성능이 떨어진다.
세컨더리 인덱스도 정렬만 되면 빠른 성능을 보이지만, 세컨더리 인덱스 순으로 정렬 저장은 보장이 어렵다.
InnoDB의 경우 세컨더리 인덱스의 변경은 일시적으로 체인지 버퍼에 버퍼링됐다가 백그라운드 스레드에 의해 일괄 처리될 수 있찌만 작업 부하를 유발하므로 전체적인 성능은 떨어진다.
```

#### 11.5.3.2 프라이머리 키 선정
```text
PK의 B-Tree 전체가 메모리에 적재돼 있어야 빠른 INSERT를 보장한다.
테이블 크기가 클수록 더 많은 메모리가 필요하고, 메모리는 유한한 자원이므로 어느 순간 저장될 위치를 찾기 위해 디스크 읽기가 필요하다.

InnoDB 테이블 PK는 클러스터링 키인데, 세컨더리 인덱스보다 PK 이용 쿼리 성능이 훨씬 빨라지는 효과를 낸다.
따라서 대립되는 SELECT, INSERT 요소 중 하나를 선택해 설계해야 한다. 
두 경우를 만족하는 경우도 있겠지만 드물다.
그리고 등록 위주 테이블은 인덱스 개수를 최소화하는 것이 좋다. 반대로 조회 테이블은 인덱스 개수가 시스템 전반적으로 영향을 미치지 않는다. 

OLTP에서는 쓰기(등록, 수정, 삭제)보다 읽기 비율이 압도적이다.
SELECT보다 INSERT가 매우 많이 실행되는 테이블은 PK를 단조 증가 또는 단조 감소 패턴의 값을 선택하는 것이 좋다. ex) 로그 저장 테이블
 
테이블 설계시 100~200만건 이하의 레코드를 가지는 테이블 설계에 너무 많은 시간을 소모하지 않아도 된다. 
테이블이 이미 작아서 튜닝으로 얻을 수 있는 성능 효과는 크지 않다. 
하지만 레코드 건수가 많지 않더라도 쿼리가 빈번하게 실행되는 경우 튜닝에 신중해야 한다.  
```

#### 11.5.3.3 Auto-Increment 칼럼
```text
등록에 최적하된 테이블 생성시 다음 두 가지 요소를 갖춰 테이블을 준비하면 된다.
1. 단조 증가 또는 단조 감소되는 값으로 PK 선정
2. 세컨더리 인덱스 최소화

InnoDB는 자동으로 PK로 클러스터링된다. 클러스터링되지 않게 할 수 없다.
하지만 Auto-Increment 칼럼을 이용하면 클러스터링되지 않는 테이블 효과를 얻을 수 있다.

Auto-Increment 칼럼을 PK로 하면 MySQL에서 가장 빠른 INSERT를 보장하는 방법이다. 
거기다가 세컨더리 인덳스가 하나도 없다면 등록을 위한 좋은 테이블 설계이다.
MySQL에서 Auto-Increment 값의 채번을 위해 AUTO-INC 잠금이 필요하다.
이 잠금을 사용하는 방식은 시스템 변수를 통해 변경이 가능하다. P.158 참고
간단하게, MySQL 8.0부터 이 시스템 변수의 디폴트가 변경됐으며, 자동 증가 값을 적당히 미리 할당 받아 처리할 수 있으므로 가장 빠른 방식이다.

자동 증가 값이 반드시 연속이어야 한다면 시스템 변수를 설정 할 수 있지만, insert 성능이 저하 될 수 있다.
그러나 설정을 하더라도 자동 증가 값의 빈 공간이 생길 가능성이 높기 때문에 반드시 순차적으로 연속적일 필요는 없다. 
```

## 11.6 UPDATE와 DELETE

### 11.6.1 UPDATE ... ORDER BY ... LIMIT n
```text
한 번에 너무 많은 변경, 삭제는 과부하 유발로 다른 커넥션 쿼리 처리를 방해 할 수 있다.
MySQL에서 UPDATE나 DELETE 문장에 ORDER BY 절과 LIMIT 절을 사용해 변경 및 삭제가 가능하다.
```






















































