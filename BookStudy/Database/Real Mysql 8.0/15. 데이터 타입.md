# 15. 데이터 타입
```text
칼럼의 데이터 타입과 길이를 정할 때 주의 사항
1. 저장되는 값의 성격에 맞는 최적 타입
2. 가변 길이 칼럼은 최적 길이 지정
3. 조인 조건 사용 칼럼은 똑같은 데이터 타입 선정

무분별하게 칼럼의 길이나 타입을 지정하면 디스크 공간과 CPU 자원도 함께 낭비된다. 
그로 인해 SQL 성능이 저하되는 것은 당연한 결과다.

서비스 도중 스키마 변경은 서비스 중지나 읽기 전용 모드로 전환 작업이 필요 할 수 있다. 
따라서 특히 칼럼의 변경은 신중하게 선택하자.
너무 넉넉해도, 부족해도 문제가 된다.
칼럼의 타입과 길이는 저장되는 값의 성격을 정확히 분석하고 최적의 타입을 선정하는 것이 중요하다.
```

## 15.1 문자열 (CHAR와 VARCHAR)
```text
CHAR와 VARCHAR는 무슨 차이가 있을까? 모든 DBMS에서 두 타입을 사용하는 것을 보면,
각 타입의 장단점이 명확할 것으로 보인다.
저장 공간과 비교 방식의 관점에서 비교해보고, 내부적으로 어떤 차이가 있는지 살펴봅쒸다.
```

### 15.1.1 저장 공간
```text
공통점은 문자열을 저장할 수 있는 데이터 타입이다.
가장 큰 차이점은 고정 길이(CHAR), 가변 길이(VARCHAR)다.

고정 길이 
- 실제 입력되는 칼럼 값의 길이에 따라 저장 공간의 크기가 변하지 않는다. 
- CHAR 타입의 경우 저장 공간의 크기는 고정이다. 따라서 추가적인 공간이 필요하지 않다.

가변 길이
- 최대 길이의 제한은 있으나, 최대 이하 크기의 값이 저장될 때 그만큼 저장 공간이 줄어든다.
- 저장된 값의 유효 크기가 얼마인지 별도 저장해 둬야 한다. -> 1 ~ 2 바이트의 추가 저장 공간 필요
    - 문자열 길이 관리를 위한 1 ~ 2 바이트의 추가 공간이 필요하다. 
    - 문자열이 255 바이트 이하면 1바이트, 초과하는 경우 2바이트의 추가 공간이 더 필요하다.
    
MySQL에서 TEXT, BLOB 타입을 제외한 칼럼의 전체 크기가 64KB 초과할 수 없다.
테이블에 VARCHAR 타입 하나가 있다면 64KB 크기의 데이트 저장 가능하다. 초과시 에러가 발생하거나 초과되는 타입이 VARCHAR 타입이라면 TEXT 타입으로 대체된다.
그래서 VARCHAR 타입 추가시 TEXT 타입으로 대체되는지 확인이 필요하다.
Q) 어떻게 확인? 물리적으로 TEXT 타입으로 보여지나?

문자열 값 고정 -> CHAR, 가변 -> VARCHAR가 일반적이다.
VARCHAR를 사용해도 기껏해야 1 ~ 2 바이트의 추가 공간이 필요한데, 신중하게 타입을 정해야 하는 이유가 있을까?
그리고 실제 문자열의 값의 길이가 정적인지, 가변적인지만을 기준으로 타입을 결정하는 것은 올바르지 않다.
Q) CHAR, VARCHAR의 가장 큰 차이가 길이인데, 그럼 어떤 추가적인 기준으로 타입을 지정할까?

CHAR & VARCHAR 타입을 지정하는 판단 기준
1. 저장 문자열 길이가 대개 비슷한가?
2. 칼럼의 값이 자주 변경되는가?

칼럼의 길이도 중요하지만, 그 값이 얼마나 자주 변경되느냐도 중요하다. 
무슨 차이가 발생하길래 값이 자주 변경하는거에 따라 영향을 미칠까?
char(10) 데이터 타입이 있다고 할 경우 'abcd'를 입력했다고 가정하자.
10바이트 중 문자열은 4바이트만 채워지고 나머지는 공백으로 채워진다.

varchar(10)으로 했더라면, 동일 데이터를 abcd 4바이트를 저장하고 길이 저장용 1바이트를 사용해서 총 5바이트가 저장된다. (길이는 문자가 아니라 숫자로 표현)
이제 실제로 자주 변경됐을 때 문제를 알아보자.
char(10) 타입의 경우 10바이트 공간이 그대로 있으므로 값만 업데이트 시켜주면 된다.
varchar(10)의 경우 길이가 더 큰 값으로 변경될 때 레코드 자체를 다른 공간으로 옮겨 저장해야 한다.
고정 길이 값, 값이 2 ~ 3 바이트 차이가 나더라도 자주 변경되는 Seq나 상태 값 등은 CHAR 타입을 사용하는 것이 좋다.

MySQL에서 문자열 데이터 타입 소괄호 안 숫자는 바이트 크기를 나타내는 것이 아니라, 글자 수가 저장되는 공간을 의미한다.
서구권 언어(영어, ...): 1바이트 -> 10바이트 사용 가능
아시아권 언어(한국, ...): 최대 2바이트 -> 최대 20바이트 사용 가능
유니코드(UTF-8): 최대 4바이트 -> 최대 40바이트 사용 가능
즉, 동일한 데이터 공간이더라도, 실제 저장되는 물리 공간은 어떤 언어가 저장되느냐에 따라 크기가 다르다.
```

### 15.1.2 저장 공간과 스키마 변경(Online DDL)
```text
데이터 변경 도중 스키마 변경이 가능한 기능을 제공한다. 
모든 스키마 변경이 가능한 것은 아니고, 특성에 따라 허용되고 안 되고가 있을 수 있다.

VARCHAR 데이터 타입의 길이를 조정하는 경우, 
길이에 따라 매우 빠르게 처리도 되지만, 어떤 경우 테이블 읽기 잠금을 걸고 레코드 복사 작업이 필요할 수 있다.
Q) 데이터 타입의 길이가 많이 작아지거나 많이 커지거나인가??? 아닌듯

VARCHAR(60) 생성
1. 60 -> VARCHAR(63) 변경 -> 잠금 없이 매우 빠르게 변경
2. 60 -> VARCHAR(64) 변경 -> COPY 알고리즘으로 스키마 변경 -> 변경 시간 오래 걸리고, 읽기 잠금 필요, 즉 스키마 변경동안 CUD 실행 불가

왜 60을 63, 64로 변경하느냐에 따라 차이가 발생할까?
VARCHAR 타입 특성상 저장 공간의 크기 때문이다.
VARCHAR 4 byte * 문자열 크기: 1번의 경우 길이 저장 공간은 1바이트면 되지만, 2번의 경우 문자열 크기가 최대 256바이트 까지 가능하기 떄문에 문자열 길이 저장 공간 크기가 2바이트로 바뀌어야 한다.
문자열 길이 저장 공간 크기가 바뀌면 MySQL 서버는 스키마 변경을 하는 동안 읽기 잠금을 걸어 데이터 변경을 모두 막고 테이블 레코드 복사 방식으로 처리한다.
Q) 레코드 단위로 문자열 길이가 1, 2가 될텐데, 모든 레코드가 길이가 1이었다가, 1, 2가 될 수 있어서 그런가????

결론: VARCHAR 타입의 길이가 크게 변경된다면 저장 공간 크기가 변경되지 않도록 미리 조금씩 크게 설계해야 한다.
```

### 15.1.3 문자 집합(캐릭터 셋)
```text
문자열 저장 타입은 여러 개가 있다. (CHAR, VARCHAR, TEXT, ...)

```






























