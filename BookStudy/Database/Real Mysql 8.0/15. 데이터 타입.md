# 15. 데이터 타입
```text
칼럼의 데이터 타입과 길이를 정할 때 주의 사항
1. 저장되는 값의 성격에 맞는 최적 타입
2. 가변 길이 칼럼은 최적 길이 지정
3. 조인 조건 사용 칼럼은 똑같은 데이터 타입 선정

무분별하게 칼럼의 길이나 타입을 지정하면 디스크 공간과 CPU 자원도 함께 낭비된다. 
그로 인해 SQL 성능이 저하되는 것은 당연한 결과다.

서비스 도중 스키마 변경은 서비스 중지나 읽기 전용 모드로 전환 작업이 필요 할 수 있다. 
따라서 특히 칼럼의 변경은 신중하게 선택하자.
너무 넉넉해도, 부족해도 문제가 된다.
칼럼의 타입과 길이는 저장되는 값의 성격을 정확히 분석하고 최적의 타입을 선정하는 것이 중요하다.
```

## 15.1 문자열 (CHAR와 VARCHAR)
```text
CHAR와 VARCHAR는 무슨 차이가 있을까? 모든 DBMS에서 두 타입을 사용하는 것을 보면,
각 타입의 장단점이 명확할 것으로 보인다.
저장 공간과 비교 방식의 관점에서 비교해보고, 내부적으로 어떤 차이가 있는지 살펴봅쒸다.
```

### 15.1.1 저장 공간
```text
공통점은 문자열을 저장할 수 있는 데이터 타입이다.
가장 큰 차이점은 고정 길이(CHAR), 가변 길이(VARCHAR)다.

고정 길이 
- 실제 입력되는 칼럼 값의 길이에 따라 저장 공간의 크기가 변하지 않는다. 
- CHAR 타입의 경우 저장 공간의 크기는 고정이다. 따라서 추가적인 공간이 필요하지 않다.

가변 길이
- 최대 길이의 제한은 있으나, 최대 이하 크기의 값이 저장될 때 그만큼 저장 공간이 줄어든다.
- 저장된 값의 유효 크기가 얼마인지 별도 저장해 둬야 한다. -> 1 ~ 2 바이트의 추가 저장 공간 필요
    - 문자열 길이 관리를 위한 1 ~ 2 바이트의 추가 공간이 필요하다. 
    - 문자열이 255 바이트 이하면 1바이트, 초과하는 경우 2바이트의 추가 공간이 더 필요하다.
    
MySQL에서 TEXT, BLOB 타입을 제외한 칼럼의 전체 크기가 64KB 초과할 수 없다.
테이블에 VARCHAR 타입 하나가 있다면 64KB 크기의 데이트 저장 가능하다. 초과시 에러가 발생하거나 초과되는 타입이 VARCHAR 타입이라면 TEXT 타입으로 대체된다.
그래서 VARCHAR 타입 추가시 TEXT 타입으로 대체되는지 확인이 필요하다.
Q) 어떻게 확인? 물리적으로 TEXT 타입으로 보여지나?

문자열 값 고정 -> CHAR, 가변 -> VARCHAR가 일반적이다.
VARCHAR를 사용해도 기껏해야 1 ~ 2 바이트의 추가 공간이 필요한데, 신중하게 타입을 정해야 하는 이유가 있을까?
그리고 실제 문자열의 값의 길이가 정적인지, 가변적인지만을 기준으로 타입을 결정하는 것은 올바르지 않다.
Q) CHAR, VARCHAR의 가장 큰 차이가 길이인데, 그럼 어떤 추가적인 기준으로 타입을 지정할까?

CHAR & VARCHAR 타입을 지정하는 판단 기준
1. 저장 문자열 길이가 대개 비슷한가?
2. 칼럼의 값이 자주 변경되는가?

칼럼의 길이도 중요하지만, 그 값이 얼마나 자주 변경되느냐도 중요하다. 
무슨 차이가 발생하길래 값이 자주 변경하는거에 따라 영향을 미칠까?
char(10) 데이터 타입이 있다고 할 경우 'abcd'를 입력했다고 가정하자.
10바이트 중 문자열은 4바이트만 채워지고 나머지는 공백으로 채워진다.

varchar(10)으로 했더라면, 동일 데이터를 abcd 4바이트를 저장하고 길이 저장용 1바이트를 사용해서 총 5바이트가 저장된다. (길이는 문자가 아니라 숫자로 표현)
이제 실제로 자주 변경됐을 때 문제를 알아보자.
char(10) 타입의 경우 10바이트 공간이 그대로 있으므로 값만 업데이트 시켜주면 된다.
varchar(10)의 경우 길이가 더 큰 값으로 변경될 때 레코드 자체를 다른 공간으로 옮겨 저장해야 한다.
고정 길이 값, 값이 2 ~ 3 바이트 차이가 나더라도 자주 변경되는 Seq나 상태 값 등은 CHAR 타입을 사용하는 것이 좋다.

MySQL에서 문자열 데이터 타입 소괄호 안 숫자는 바이트 크기를 나타내는 것이 아니라, 글자 수가 저장되는 공간을 의미한다.
서구권 언어(영어, ...): 1바이트 -> 10바이트 사용 가능
아시아권 언어(한국, ...): 최대 2바이트 -> 최대 20바이트 사용 가능
유니코드(UTF-8): 최대 4바이트 -> 최대 40바이트 사용 가능
즉, 동일한 데이터 공간이더라도, 실제 저장되는 물리 공간은 어떤 언어가 저장되느냐에 따라 크기가 다르다.
```

### 15.1.2 저장 공간과 스키마 변경(Online DDL)
```text
데이터 변경 도중 스키마 변경이 가능한 기능을 제공한다. 
모든 스키마 변경이 가능한 것은 아니고, 특성에 따라 허용되고 안 되고가 있을 수 있다.

VARCHAR 데이터 타입의 길이를 조정하는 경우, 
길이에 따라 매우 빠르게 처리도 되지만, 어떤 경우 테이블 읽기 잠금을 걸고 레코드 복사 작업이 필요할 수 있다.
Q) 데이터 타입의 길이가 많이 작아지거나 많이 커지거나인가??? 아닌듯

VARCHAR(60) 생성
1. 60 -> VARCHAR(63) 변경 -> 잠금 없이 매우 빠르게 변경
2. 60 -> VARCHAR(64) 변경 -> COPY 알고리즘으로 스키마 변경 -> 변경 시간 오래 걸리고, 읽기 잠금 필요, 즉 스키마 변경동안 CUD 실행 불가

왜 60을 63, 64로 변경하느냐에 따라 차이가 발생할까?
VARCHAR 타입 특성상 저장 공간의 크기 때문이다.
VARCHAR 4 byte * 문자열 크기: 1번의 경우 길이 저장 공간은 1바이트면 되지만, 2번의 경우 문자열 크기가 최대 256바이트 까지 가능하기 떄문에 문자열 길이 저장 공간 크기가 2바이트로 바뀌어야 한다.
문자열 길이 저장 공간 크기가 바뀌면 MySQL 서버는 스키마 변경을 하는 동안 읽기 잠금을 걸어 데이터 변경을 모두 막고 테이블 레코드 복사 방식으로 처리한다.
Q) 레코드 단위로 문자열 길이가 1, 2가 될텐데, 모든 레코드가 길이가 1이었다가, 1, 2가 될 수 있어서 그런가????

결론: VARCHAR 타입의 길이가 크게 변경된다면 저장 공간 크기가 변경되지 않도록 미리 조금씩 크게 설계해야 한다.
```

### 15.1.3 문자 집합(캐릭터 셋)
```text
문자열 저장 타입은 여러 개가 있다. (CHAR, VARCHAR, TEXT, ...)
MySQL에서는 칼럼 단위로 문자 집합을 관리한다. 
설정에 따라 MySQL서버, DB, 테이블 단위 기본 문자 집합 기능 제공한다.
문자 집합은 "SHOW CHARACTER SET" 명령으로 확인 가능하다.

- character_set_system: MySQL 서버가 식별자(Identifier, 테이블 이름, 칼럼 명 등)를 저장할 때 사용 - 기본 utf8
- character_set_server: MySQL 기본 문자 집합이다. DB, Table, Column 등에 문자 집합이 설정되지 않은 경우 이 설정이 기본 사용 - 기본 utf8mb4
- character_set_database: 특정 실행 문장에서 인자로 지정된 파일의 이름을 해석할 때 사용된다. 
- character_set_client: 클라이언트가 보낸 SQL 문장은 이 설정에 지정된 값으로 인코딩 후 MySQL 서버로 전송한다. 기본 utf8mb4
- character_set_connection: 클라이언트로 전달 받은 SQL 문장을 처리하기 위해 이 설정에 지정된 값으로 변환한다. 기본 utf8mb4
- character_set_results: 쿼리 처리 결과를 클라이언트에게 보낼 때 사용하는 문자 집합 - utf8mb4
Q) client, connection, results가 각각 문자집합 설정을 나눈 이유가 뭘까...



```

#### 15.1.3.1 클라이언트로부터 쿼리를 요청했을 때의 문자 집합 변환
```text
MySQL은 쿼리 메시지 (쿼리 문장과 변수 값)가 character_set_client에 지정 문자 집합으로 인코딩돼 있다고 판단하고,
character_set_connection에 정의된 문자집합으로 변환한다.
하지만 별도 문자 집합이 지정된 리터럴은 변환 대상에 포함되지 않는다. ex) _ 등등등 (latin1 문자 집합)
```

#### 15.1.3.2 처리 결과를 클라이언트로 전송할 때의 문자 집합 변환

### 15.1.4 콜레이션(Collation)
```text
문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미한다.
즉, 비교시 영문 대/소문자를 구별하여 처리할지, 크거나 작게 판단할지에 대한 규칙을 정의한다.
문자열 타입의 칼럼은 독립적 문자 집합과 콜레이션을 가진다.
문자열 칼럼 비교나 정렬시 문자 집합 뿐 아니라 콜레이션의 일치 여부에 따라 결과도 달라지고 쿼리 성능에 상당한 영향을 받는다.
```

#### 15.1.4.1 콜레이션 이해
```text
문자 집합은 두 개 이상의 콜레이션을 갖는다. 
하나의 문자 집합에 속한 콜레이션은 다른 문자 집합과 공유해서 사용 불가능하다.
"SHOW COLLCATION" 명령을 통해 확인 사용 가능 콜레이션 목록을 확인할 수 있다.
Q) 문자열 데이터 타입이 어떤 콜레이션들을 사용하는지 어떻게 확인할까?
Q) 데이터 타입 마다 문자 집합을 지정하고, 문자 집합은 두 개 이상의 콜레이션을 지정한다. 여기서 차이가 발생하면 문자열 비교나 정렬을 하면서 성능에 상당한 영향을 줄 수 있나? 그래서 client, connection, results를 같인 값으로 지정하는 것이 중요한가??? 흠

MySQL 문자열 칼럼은 콜레이션 없이 문자 집합만 가질 수 없다. 
MySQL에서는 동일한 타입이라고 말할 때는, 타입의 이름, 문자열의 길이, 문자 집합과 콜레이션이 일치해야한다.
이 네가지 조건이 일치해야 WHERE 조건 인덱스를 효율적으로 사용 가능하다. 
인덱스의 효율적인 사용을 위해 주의할 필요가 있다.

만약 WHERE 조건 검색은 대/소문자를 구분하지 않고, 정렬은 구분해야 하는 경우 둘 중 하나는 인덱스 이용을 포기해야 한다.
```

#### 15.1.4.2 utf8mb4 문자 집합의 콜레이션
```text
최근 응용 프로그램의 다국어 지원은 필수적이라, 대부분 utf8mb4 문자 집합을 사용한다.
```

### 15.1.5 비교 방식
```text
MySQL 문자열 칼럼 비교 방식은 CHAR와 VARCHAR가 거의 같다.
CHAR 타입 SELECT시 다른 DBMS와 다르게 공백 문자가 채워져서 오지 않는다.
MySQL에서 지원하는 대부분의 문자 집합과 콜레이션은 CHAR나 VARCHAR 타입을 비교할 때 공백 문자를 뒤에 붙여 동일하게 만든 후 비교 수행
```
```sql
-- 예제 1
SELECT 'ABC' = 'ABC     ' AS is_equal; -- TRUE
-- 예제 2
SELECT 'ABC' = '    ABC' AS is_equal; -- FALSE
```
```text
예제1은 뒤에 붙은 공백은 있어도 없는 것 처럼 비교,
예제2는 앞에 위치한 공백을 유효하게 비교했다. 
이는 비교 함수를 사용해도 동일 결과가 나온다.

특정 문자 집합에 따라 예제1이 FALSE가 나올 수도 있다.
```

### 15.1.6 문자열 이스케이프 처리
```text
"\"를 이용한 이스케이프 처리가 가능하다.
```

## 15.2 숫자
```text
숫자 저장 타입은 값의 정확도에 따라 참값(Exact value)과 근삿값 타입으로 나눈다.
그리고 저장되는 포맷에 따라 십진 표기법(DECIMAL)과 이진 표기법으로 나눈다.

DBMS에서 근삿값은 저장, 조회시 값이 정확히 일치하지 않고 유효 자릿수 넘어서는 소수점 이하 값은 계속 바뀔 수 있다. 
결론: 매우 큰 숫자 값이나 고정 소수점을 필요로 하지 않는다면 일반적으로 INTEGER나 BIGINT 타입을 자주 사용한다.
```

### 15.2.1 정수
```text
DECIMAL 타입을 제외하고 정수 타입은 다섯 가지가 있다.
저장 가능 숫자의 범위만 다를 뿐 다른 차이가 거의 없다.
따라서 간단히 저장되는 값의 범위 내에 최선의 저장 공간을 선택해서 타입을 지정하면 된다.

정수 타입 옵션 UNSIGNED가 있는데, 이를 명시하지 않는다면 음수 양수 동시 저장 가능 타입이 된다.
지정할 시 최대 값은 SIGNED 타입보다 2배가 더 커진다.
인덱스 활용 여부는 UNSIGNED와 상관없다 하지만 SIGNED와 저장 값의 범위가 다르기 때문에 조인 조건의 칼럼은 일치시키는게 좋다.
```

### 15.2.2 부동 소수점
```text
부동은 소수점의 위치가 고정적이지 않다는 의미다. 
따라서 정확한 유효 소수점 값을 식별하기 어렵고 크다 작다 비교가 어렵다.
equals 동등 비교는 사용할 수 없다.
```

### 15.2.3 DECIMAL
```text
결론적으로 정수값 관리를 위해 DECIMAL 타입 사용은 성능, 공간상 좋지 않다.
```

### 15.2.4 정수 타입의 칼럼을 생성할 때의 주의사항
```text
BIGINT(10)을 정수 값의 길이가 10자리 제한이라고 생각하는 사람들이 있다.
하지만 모든 정수 타입은 이미 고정형 데이터 타입이다. 
소괄호 안에 숫자는 화면에 표시할 자릿수를 의미하고, 저장 가능 값을 제한하는 용도가 아니다.
8.0부터 소괄호 자릿수는 비권장 됐다.
```

### 15.2.5 자동 증가 (AUTO_INCREMENT) 옵션 사용
```text
PK 칼럼의 크기가 크거나, 딱히 PK로 지정할 칼럼이 없는 경우 숫자 타입의 칼럼에 자동 증가 옵션을 사용해 인조 키(Artificial Key)를
생성할 수 있다.
MySQL에서는 시스템 변수를 통해 자동 증가 값의 범위?가 달라질 수 있다. (성능 상 1씩이 아닌 1 ~  2 이상)
설정 값을 기준으로 자동 증가 값이 오를 수도 있다. (5, 10, 15 또는 3, 6, 9)

자동 증가 값을 설정한 칼럼은 무조건 PK이거나 유니크 키의 일부여야 한다.
테이블당 하나만 설정 가능하고, 자동 증가 값은 테이블의 메타 정보에 저장돼 있다. 
자동 증가 값은 스키마 복사 (개발 서버 -> 스테이징 서버 등) 시 값이 다를 수 있으니 주의하자.
```

## 15.3 날짜와 시간
```text
MySQL에서 NOW() 함수를 사용할 때 밀리초의 자릿수를 명시해야 한다. 안 그러면 자동으로 NOW(0);으로 
실행되어 밀리초 단위는 0으로 반환된다.
```

### 15.3.1 자동 업데이트

## 15.4 ENUM과 SET
```text
ENUM과 SET은 문자열 값을 MySQL 내부적으로 숫자 값으로 매핑해서 관리하는 타입이다.
```

### 15.4.1 ENUM
```text
테이블의 구조(메타 데이터)에 나열된 목록 중 하나의 값을 가질 수 있다.
코드화된 값을 관리한다.

쿼리에서 CHAR 또는 VARCHAR 타입과 같이 문자열처럼 비교하거나 저장 가능하다.
하지만 실제 값을 디스크나 메모리에 저장할 때 문자열이 아니라, 그 값에 매핑된 정수 값을 사용한다.

정수 값은 일반적으로 테이블 정의 순서대로 1부터 할당되고 빈 문자열은 0으로 매핑된다.
저장 타입의 문자열이 길면 길수록 저장 공간을 더 많이 절약 가능 -> 정수 값을 사용하기 때문에

ENUM 타입의 새로운 값이 추가되는 경우
MySQL 5.6 전에는 항상 테이블을 리빌드 해야 했지만, 5.6부터 제일 마지막에 추가되는 형태라면 메타데이터 변경만으로 즉시 완료된다.
하지만 순서가 변경된다면 COPY 알고리즘에 읽기 잠금까지 필요!
따라서 테이블이 매우 크다면, 가독성이 떨어지더라도 새로운 값을 마지막에 나열!
```







































