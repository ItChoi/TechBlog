# 05 트랜잭션과 잠금
```text
1. 잠금
2. 트랜잭션
3. 트랜잭션의 격리 수준
세 가지는 모두 Mysql의 동시성에 영향을 미친다.

 트랜잭션은 작업의 완전성을 보장해준다. 즉 작업을 모두 완료하거나 모두 완료하지 않은 상태를 보장해주는 것이다.
작업의 일부만 적용되는 현상을 Partial update라고 한다. InnoDB 스토리지 엔진은 트랜잭션을 사용하기 때문에 작업의 완전성을
보장해주지만, MyISAM 또는 Memory 스토리지 엔진의 경우 Partial update가 발생 할 수 있다.   

 잠금(Lock)은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.
즉 잠금은 여러 트랜잭션에서 하나의 데이터에 변경을 가할 경우 하나의 트랜잭션이 접근 했을 때 이 데이터에 대해 잠금을 걸어 다른 
트랜잭션이 접근하지 못하게 해서 여러 커넥션에서 동시에 변경할 수 없게 해준다.
 
 트랜잭션의 격리 수준은 MVCC(Multi-Version Concurrency Control)를 통해, 설정한 격리 수준에 따라 어느 저장 영역에서 
여러 트랜 잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨을 의미한다.
```

## 5.1 트랜잭션
```text
개발자들은 트랜잭션의 원리나 설정을 직접 하지 않고도 적용된 환경에서 개발을 하기 때문에 트랜잭션이 얼마나 큰 혜택을 제공하는지 모를 수 있다.
예를 들면 MyISAM 또는 Memory 스토리지 엔진처럼 트랜잭션을 지원하지 않는다면 테이블 생성 및 쿼리에 대해 더 많은 고민을 하게 된다. 
```

### 5.1.1 MySQL에서의 트랜잭션
```text
트랜잭션은 단순히 여러 변경 쿼리가 조합됐을 때만 의미 있는 개념이 아니다.
결론적으로 작업이 100%센트 적용이 되거나 적용되지 않는 것을 보장해주는 것이다.
```
- InnoDB와 MyISAM 테이블의 차이점 (Memory 스토리지 엔진도 동일)
```sql
-- myisam의 경우 아래 두 개의 쿼리를 실행 했을 때 조회 하면 1, 2, 3이 저장되어 있다.
INSERT INTO myisam (id) VALUES (3);
INSERT INTO myisam (id) VALUES (1), (2), (3);
-- innodb 경우 아래 두 개의 쿼리를 실행 했을 때 조회 하면 미리 저장한 3만 저장되어 있다.
INSERT INTO innodb (id) VALUES (3);
INSERT INTO innodb (id) VALUES (1), (2), (3);
```
```text
 위에 예제를 보면 MyISAM과 Memory 스토리지 엔진은 중복이 되는 기본 키를 만났을 때 그 이전 까지 저장된 데이터를 그대로 두는 반면,
InnoDB는 하나의 트랜잭션에서 수행된 쿼리에서 오류가 발생했을 때 전부 되돌리기 때문에 기존에 있던 3만 저장되어 있는 상태를 볼 수 있다.
 따라서 MyISAM과 Memory 스토리지 엔진은 트랜잭션이 적용되는 스토리지 엔진과 다르게 별도의 쿼리 조건을 추가하여 작업의 완전성을 보장해야 한다.
뿐만 아니라 데이터의 정합성을 맞추는 데 상당히 어려운 문제가 생기게 된다.
 트랜잭션은 결국 애플리케이션을 개발하는 데 있어서 고민해야 할 문제를 줄여주는 필수적인 DBMS의 기능이다.
```
### 5.1.2 주의사항
```text
트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 것이다.
ex) 예제
1. 처리 시작 (Controller)
    -> DB Connection 생성 (Service)
    -> 트랜잭션 시작
2. 사용자 로그인 여부 확인
3. 사용자 글쓰기 내용 오류 여부 확인
4. 첨부된 업로드 파일 확인 및 저장
5. 사용자 입력 내용 DBMS 저장
6. 첨부 파일 정보 DBMS 저장
7. 저장된 내용 또는 기타 정보 DBMS에서 조회
8. 게시물 등록 완료 알림 메일 발송
9. 알림 메일 발송 이력 DBMS 저장
    <- 트랜잭션 종료
    <- DB Connection 반납
    
 실제로 많은 개발자들이 위에 예제처럼 DB 커넥션을 생성하고 동시에 시작한다.
실제 DBMS 저장하는 작업은 5번 부터 시작되는 것을 알 수 있다. 1.2.3.4가 아무리 빨리 처리 된다고 하더라도 트랜잭션에 포함시킬 필요는 없다.
왜냐하면 DB의 커넥션은 개수가 제한적이고 커넥션을 소유하는 기간이 길어질수록 여유 커넥션의 개수는 줄어들어 대기 상태가 길어지는 상황이 발생 할 수 있다.

 더 큰 위험은 8번의 메일 발송이다. 메일 전송 또는 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신 등의 작업은 
어떻게 해서든 트랜잭션 내에서 제거하는 것이 좋다. 통신이 이루어지지 않을 때 웹 서버 뿐만 아니라 DBMS 서버까지 위험해질 수 있다.

 위에 처리 절차는 크게 세 가지로 나눌 수 있다.
1. 사용자 입력 정보 저장 (5, 6) // 반드시 하나의 트랜잭션으로 묶어야 한다.
2. DBMS 단순 조회 (7)
3. 이력 저장 (9) // 5, 6번과 성격이 다르기 때문에 함께 묶어 처리하지 않아도 무방하다.

Q) 커넥션 생성과 트랜잭션 시작
개인 생각)
1. 비즈니스 로직을 처리하기 위해서는 서비스 레이어를 호출 
2. JPA의 경우 서비스에서 트랜잭션을 시작하는 것이 일반적
3. 메일 발송의 경우도 트랜잭션에 포함 -> 새로운 트랜잭션 생성 후 작업 또는 하나의 트랜잭션 실행 후 오류시 롤백
```
- 위에 예제를 보완한 처리 절차
```text
1. 처리시작
2. 사용자 로그인 여부 확인
3. 사용자 글쓰기 내용 오류 여부 확인
4. 첨부된 업로드 파일 확인 및 저장
    -> DB Connection 생성 (또는 커넥션 풀에서 가져오기)
    -> 트랜잭션 시작
5. 사용자 입력 내용 DBMS 저장
6. 첨부 파일 정보 DBMS 저장
    <- 트랜잭션 종류 (COMMIT)
7. 저장된 내용 또는 기타 정보 DBMS에서 조회
8. 게시물 등록 완료 알림 메일 발송
    -> 트랜잭션 시작
9. 알림 메일 발송 이력 DBMS 저장
    <- 트랜잭션 종료 (COMMIT)
    <- DB CONNECTION 종료 (또는 커넥션 풀에서 반납)
10. 처리 완료

 최적의 설계는 아닐 수 있고 업무 특성에 따라 크게 달라질 수 있다.
결론적으로는 프로그램의 코드가 DB 커넥션을 가지고 있는 범위와 활성화 상태를 최소화 범위를 유지하며 사용해야 한다.
프로그램 코드가 한 두줄이라도 네트워크 작업이 있는 경우는 반드시 트랜잭션에서 배제하자. 뜻하지 않은 높은 부하 상태로 빠지거나 위험한
상태로 빠질 수 있기 떄문이다.
```

## 5.2 MySQL 엔진의 잠금
```text
크게 스토리지 엔진 레벨의 잠금과 MySQL 엔진 레벨의 잠금으로 나눌 수 있다.
MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.
```
### 5.2.1 글로벌 락
```text
- FLUSH TABLES WITH READ LOCK 명령으로 획득 가능
- MySQL 제공 잠금 중 가장 범위가 크다. -> MySQL 서버 전체, 테이블 또는 DB가 다르더라도 동일하게 영향을 미친다.
- 글로벌 락을 획득하면 해제 될 때 까지 다른 세션에서 SELECT 제외한 DDL, DML 실행 문장이 대기 상태가 된다.
    - MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 건다. 
    - 글로벌 락 획득 전에 테이블이나 레코드에 쓰기 잠금이 존재한다면 먼저 실행된 SQL과 그 트랜잭션이 완료될 때 까지 기다려야 된다.
        - 글로벌 락을 획득 하기 전에 먼저 테이블을 플러시 해야 하기 때문이다.
        - 장시간 실행 쿼리와 글로벌 락 획득 명령이 최악의 케이스로 실행되면 아주 오랜 시간 대기 상태에 빠질 수 있다.
- MyISAM 또는 Memory 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때 글로벌 락을 사용해야 한다.
```
```text
 MySQL 서버가 업그레이드 되면서 InnoDB 스토리지 엔진의 사용이 일반화 됐다.
InnoDB는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요 없다.

 8.0 부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생겼다.
그래서 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다. 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자 인증 관련 정보를 변경할 수 없다.
    # 인증 관련 정보
    - 데이터베이스, 테이블 등 모든 객체 생성 및 변경, 삭제
    - 사용자 관리 및 비번 변경

 하지만 백업 락은 일반적인 테이블의 데이터 변경은 허용된다. 
일반적인 MySQL 서버의 구성 두 가지로 구성된다.
    - 소스 서버
    - 레플리카 서버 -> 주로 백업 실행
        - 백업이 글로벌 락을 획득하면 복제는 백업 시간만큼 지연 -> 소스 서버 문제 발생시에도 마찬가지로 지연된다.
 백업 락은 이러한 문제들을 위해 도입됐다 즉 정상적인 복제는 실행되면서, DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.
```
### 5.2.2 테이블 락
```text
- LOCK TABLES table_name [ READ | WRITE ] 명령으로 획득 가능
- UNLOCK TABLES 명령으로 잠금 반납(해제) 가능
- MyISAM & InnoDB 스토리지 엔진 둘 다 사용 가능
- 명시적인 명령은 특별한 상황이 아니면 애플리케이션에서 사용할 필요 없다. 왜냐하면 온라인 작업에 상당한 영향을 미친다.
 개별 테이블 단위로 설정되는 잠금이며 명시적 또는 묵시적으로 획득 가능, 
묵시적인 락은 테이블에 데이터 변경 쿼리 실행 시 발생 ex) 변경 전 테이블 잠금 -> 변경 -> 잠금 해제
 하지만 InnoDB 테이블의 경우 **레코드 기반의 잠금을 제공하기 때문에 묵시적인 테이블 락 설정되지 않는다.**
정확히는 테이블에도 테이블 락이 설정되지만, 대부분의 DML은 무시되고 **DDL의 경우에만 영향을 미친다.**
Q) 트랜잭션 지원의 차이인가?
```
### 5.2.3 네임드 락
```text
- GET_LOCK() 함수를 이용하여 설정 
    ex) SELECT GET_LOCK('str', 2); // str 문자열 잠금 획득, 이미 잠금 중이면 2초 동안만 대기
    ex) SELECT GET_LOCK('str'); // str 문자열 잠금 설정 유무 확인
    ex) SELECT RELEASE_LOCK('str'); // str 문자열 잠금 반납 
    - 정상적인 락 획득 또는 해제 시 1 반환, 비정상은 NULL 또는 0 반환
    
- 단순히 사용자가 지정한 문자열을 획득하고 반납하는 잠금 (자주 사용 X)

 웹 서버 5대가 DB 서버 1대를 접속해서 서비스 중일 때 5대 웹 서버가 어떤 정보를 동기화해야할 때 네임드 락 이용시 쉽게 해결 가능
또한 많은 레도크를 복잡한 요건으로 변경할 때 트랜잭션에서 유용하게 사용할 수 있다. 배치 프로그램처럼 한 번에 많은 레도크를 변경하는 쿼리는
빈번히 데드락의 원인이 된다. 이럴 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해 네임드 락을 걸고 쿼리 실행 시 해결 가능하다.

 8.0 부터는 네임드 락 중첩 사용 가능하고 현재 세션에서 획득한 네임드 락 한 번에 해제하는 기능 추가
    ex) SELECT RELEASE_ALL_LOCKS() // 네임드 락 모두 해제
```
### 5.2.4 메타데이터 락
```text
 DB 객체의 이름이나 구조를 변경 할 때 획득하는 잠금이다. DB 객체라면 대표적으로 테이블이나 뷰 등을 들 수 있다.
테이블 이름 변경 시 자동 획득하고 원본 이름과 변경될 이름 모두 잠금

 InnoDB의 경우 메타데이터 잠금과 트랜잭션을 동시에 사용해야 하는 경우가 있다. 예를 들어 Insert만 실행되는 로그 테이블에서 테이블 구조를
변경해야 된다고 가정했을 때, DDL의 경우 단일 스레드로 동작하기에 너무 오래 걸리는 경우 언두 로그 증가와 Online DDL 버퍼 크기 등 고민 거리가 많다.
 이럴 땐 새로운 테이블을 생성하고 데이터를 덤프하는게 더 좋을 수 있는데, 여러 개의 스레드(insert문)를 조건으로 분기 처리해 
 최근 데이터(1시간 전 또는 하루 전) 빠르게 복사한다. 나머지는 트랜잭션과 테이블 잠금을 통해 데이터를 복사하는 동안 테이블에 Insert를 할 수 없게 된다.
따라서 아주 최근 데이터의 범위를 줄여 복사해 둬야 잠금 시간을 최소화해 서비스에 영향을 최소화 할 수 있다.
```
- 메타데이터 락 예제
```sql
INSERT INTO temp_log_new SELECT * FROM temp_log WHERE id >= 0 AND id < 10000;  
INSERT INTO temp_log_new SELECT * FROM temp_log WHERE id >= 10000 AND id < 20000;  
INSERT INTO temp_log_new SELECT * FROM temp_log WHERE id >= 20000 AND id < 30000;  
INSERT INTO temp_log_new SELECT * FROM temp_log WHERE id >= 30000 AND id < 40000;  

-- 트랜 잭션을 autocommit으로 실행 (BEGIN 이나 START TRANSACTION으로 실행 X)
SET autocommit = 0;

-- 작업 대상 테이블 2개에 대해 테이블 쓰기 락 획득
LOCK TABLES temp_log WRITE, temp_log_new WRITE;

-- 남은 데이터 복사
SELECT MAX(id) as @MAX_ID FROM temp_log;
INSERT INTO temp_log_new SELECT * FROM temp_log WHERE pk > @MAX_ID;
COMMIT;

-- 불필요 테이블 삭제
DROP TABLE temp_log;
```
## 5.3 InnoDB 스토리지 엔진 잠금
```text
 InnoDB 스토리지 엔진은 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 레도크 기반 잠금은 상대적으로 뛰어난 동시성 처리를 제공한다.
하지만 이원화된 잠금(Mysql 엔진, 스토리지 엔진) 처리 탓에 MySQL 명령을 통한 접근히 상당히 까다롭다. 
 하지만 최근 버전에서는 트랜잭션과 잠금, 잠금 대기 중 트랜잭션 목록 조회, 장시간 잠금 클라이언트 종료, Performance Schema를 이용한
InnoDB 스토리지 엔진 내부 잠금에 대한 모니터링 방법 등이 추가 됐다.
```
### 5.3.1 InnoDB 스토리지 엔진의 잠금
```text
- 레코드 기반의 잠금 기능을 제공
- 잠금 정보는 상당히 작은 공간으로 관리
 
 일반 상용 DBMS와는 다르게 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭락 존재
```
#### 5.3.1.1 레코드 락
```text
레코드 자체만을 잠금한다. 다른 상용 DBMS와 동일한 역할을 하지만 InnoDB 스토리지 엔진은 레코드 자체가 아니라 **인덱스의 레코드**를 잠근다.
인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스가 존재하기 때문에 이를 통해 잠금을 설정한다.
참고로 자동 생성된 클러스터 인덱스는 사용자가 제어 할 수 없다.
 레코드 자체를 잠금 하는지 인덱스의 레코드를 잠금하는지에 따라 차이가 발생한다. (뒤에서 다룰 예정)
```
#### 5.3.1.2 갭 락
```text
 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠금하여 새로운 레코드가 생성되는 것을 제어한다.
갭락 자체보다는 넥스트 키 락의 일부로 자주 사용된다.
```
#### 5.3.1.3 넥스트 키 락
```text
 레코드 락과 갭 락을 합쳐 놓은 형태이다. 
```
#### 5.3.1.4 자동 증가 락
```text
 MySQL에서는 AUTO_INCREMENT 컬럼 속성을 제공하는데, 이 테이블에 여러 레코드가 INSERT되는 경우 중복되지 않은 순서대로 증가한 저장된 
값을 가져야 한다. 이를 위해 **내부적으로 테이불 수준의 잠금인 자동 증가 락**을 사용한다.
 자동 증가 락이기 때문에 당연히 INSERT와 REPLACE와 같이 새로운 레코드를 저장하는 쿼리에서만 걸리고,
값을 가져오는 순간 락기 걸렸다가 즉시 해제된다. 명시적으로 획득 및 해제 할 수 없다.
두 개의 쿼리가 동시에 실행되는 경우 하나의 쿼리가 락을 걸고 다른 하나는 기다려야 한다.

 위에 설명은 전부 5.0 이하 버전에서 사용하던 방식이다. 5.1 이상부터는 innodb_autoinc_lock_mode 시스템 변수를 이용하여 
자동 증가 락의 작동 방식 변경 가능하다.
    - innodb_autoinc_lock_mode=0 : mysql 5.0과 동일한 잠금 방식으로 모든 INSERT 문장은 자동 증가 락 사용
    - innodb_autoinc_lock_mode=1 : 여러 건의 레코드 중 INSERT되는 건 수를 정확히 예측 할 수 있을 때 락을 사용하지 않고 래치(뮤텍스)를
        이용하여 처리한다. insert ... select의 경우 건 수를 예측 할 수 없다. 이 때는 mode=0을 사용한다.
    - innodb_autoinc_lock_mode=2 : 절대 자동 증가 락 사용하지 않고 경량화된 래치(뮤텍스)를 사용한다. 연속된 자동 증가 값을 보장하지 않고,
        insert ... select 문장 실행 중에도 다른 커넥션에서 INSERT가 가능하여 동시 처리 성능이 높아진다. 이 설정의 자동 증가는 유니크한 값이
        생성된다는 것만 보장한다. (?)

 5.7 버전까지는 기본 값이 1이었지만, 8.0부터는 2로 바뀌었다. Row 포맷이 아니라 Statement 포맷의 바이너리 로그 사용시 1로 사용할 것을 권장한다. (?)
```
### 5.3.2 인덱스와 잠금
```text
 InnoDB의 잠금과 인덱스는 상당히 중요한 연관관계가 있다.
InnoDB의 잠금은 레코드 자체가 아니라 인덱스의 레코드를 잠그는 방식으로 처리가 된다. 즉 변경해야할 레코드를 찾기 위해 검색한 인덱스의 레코드를
모두 락을 걸어야 한다.
 예를 들어 a에 인덱스가 존재하고, b 컬럼에 인덱스가 없을 때a = 'abc'는 253명, a = 123 and b = 456은 1명이라 했을 때 a, b 조건으로 
UPDATE 했을 때 253 건의 레코드에 락을 걸어야 한다. 만일 a 컬럼에도 인덱스가 존재하지 않는다면 테이블 풀 스캔 하면서 모든 레코드를 잠근다.
따라서 InnoDB에서 인덱스 설계가 중요하다.
```
### 5.3.3 레코드 수준의 잠금 확인 및 해제
```text
 InnoDB 스토리지 엔진의 테이블 레코드 잠금은 테이블 잠금보다 복잡하다. 테이블 잠금은 대상이 테이블 자체이므로 쉽게 원인 발견 후 해결이 가능하지만,
레코드 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 자주 사용되지 않는다면 오랜 시간 잠금 상태로 남아 있어도 잘 발견되지 않는다.
 5.1 부터는 레코드 잠금과 대기에 대한 조회가 가능하고 강제로 잠금 해제 시 KILL 명령을 사용하면 된다.
5.1부터는 information_schema DB의 INNODB_TRX, INNODB_LOCKS, INNODB_WAITS 통해 확인 가능하고,
8.0부터는 performance_schema의 data_locks, data_lock_watis 테이블로 대체됐다. 
```
## 5.4 MySQL의 격리 수준
```text
 여러 트랜잭션이 동시에 변경 또는 조회하고자 하는 특정 데이터를 읽을 수 있게 허용 & 비허용을 결정하는 것이다.
격리 수준은 네 가지로 나뉜다.
    1. READ UNCOMMITED
    2. READ COMMITED
    3. REPEATABLE READ
    4. SERIALIZABLE

 오름차순 순으로 갈수록 트랜잭셔ㄴ 간 데이터 격립 정도가 높아지고 동시 처리 성능도 떨어지는 것이 일반적이다.
격리 수준이 높아질수록 MySQL 서버 처리 성능이 많이 떨어질 것이라고 생각하는데, 사실 SERIALIZABLE가 아니라면 크게 성능 개선, 저하가 발생하지 않는다. 
 
 DB 격리 수준에서는 세 가지 부정합의 문제점이 있다. 
    1. DIRTY READ
        - READ UNCOMMITED
    2. NON-REPEATABLE READ
        - READ UNCOMMITED
        - READ COMMITED
    3. PHANTOM READ
        - READ UNCOMMITED
        - READ UNCOMMITED
        - REPEATABLE READ (InnoDB는 없음)
    - DIRTY READ : commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 말하며 커밋하지 않고 종료시 꼬일 수 있다.
    - NON-REPEATABLE READ : 한 트랜잭션 안에서 같은 쿼리를 두 번 실행 했을 때 다른 값이 나오는 Read 현상으로 특정 데이터에 대한 수정이
        발생하여 나타나는 Read현상을 말한다.
    - PHANTOM READ : 한 트랜잭션 안에서 첫 번 째 쿼리 결과와 두 번째가 다른 것을 말하며, Insert 작업에 의해 결과 범위에 속하지 않는
        레코드가 외부 작업에 의해 존재 유무가 다른 것을 말한다.

 일반적인 온라인 서비스 용도의 DB는 2번, 3번 중 하나를 사용한다. (오라클: 2번, MySQL: 3번)
```
### 5.4.1 READ UNCOMMITED 
```text
 하나의 트랜잭션에서 데이터 변경 후 commit이나 rollback을 하지 않은 상태에서 다른 트랜잭션에서 읽을 수 있다.
그리고 변경한 트랜잭션이 오류로 인해 롤백을 하면 이미 데이터를 읽은 트랜잭션은 이 데이터를 정상적으로 처리하고 유지하는 문제가 생긴다.
이를 더티 리드(Dirty read)라고 한다. 
```
### 5.4.2 READ COMMITED
```text
 오라클에서 기본으로 사용되는 격리수준이며, 온라인 서비스에서 가장 많이 선택된다.
변경 트랜잭션에서 데이터 변경 후 commit이 완료 되어야 다른 트랜잭션에서 조회가 가능하다.
커밋 전에 트랜잭션이 변경을 하면 즉시 테이블에 기록되고, 이전 값은 언두 영역에 백업된다.
그리고 커밋 전에 조회 트랜잭션이 데이터를 읽을 땐 언두 영역을 조회하고 커밋 후 테이블에서 조회하게 된다.

 조회 트랜잭션이 첫 번 째 a = aa 조회 시 결과가 없고, 두 번 째 a = aa 조회 시 결과가 존재 할 수 있다.
즉 하나의 트랜잭션 안에서 첫 번 째와 두 번 째 사이에 다른 사용자가 변경 트랜잭션으로 데이터를 변경하고 커밋하게 되면 하나의 조회 트랜잭션
안에서 조회 결과가 달라질 수 있다.
 이는 하나의 트랜잭션 내에서 똑같은 조회 쿼리 실행 시 항상 같은 결과를 가져야 한다는 "REPEATABLE READ" 정합성에 어긋난다.

 이 격리 수준은 일반적은 서비스에서는 크게 문제되지 않을 수 있지만, 금전적인 처리와 연결 될 때 문제가 될 수 있다. 
예를 들면 입금, 출금이 반복 될 때 총 입금 금액 조회 시 데이터의 정합성이 어긋날 수 있다.
 이러한 문제로 데이터의 정합성이 깨지고 버그가 생기면 버그 발생을 발견하기 쉽지 않다. 
```
### 5.4.3 REPEATABLE READ
```text
 MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 
바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.
여기서는 "NON-REPEATABLE READ" 부정합이 발생하지 않는다. MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는
동일한 결과를 보여줄 수 있게 보장한다. 
 READ COMMITED도 MVCC를 이용하지만, 언두 영역에 백업된 레코드의 "여러 버전 가운데 몇 번 째 이전 버전까지 찾아 들아가야 하느냐" 
하는 차이가 있다. 

 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차 증가 값)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함
돼 있다. 언두 영역의 백업된 데이터는 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
 REPEATABLE READ에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 중 가장 오래된 트랜잭션 번호보다 앞선 언두 영역의 데이터는 삭제 할 수 없다.
따라서 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터는 보존되어야 한다. 
 
 REPEATABLE READ에서도 부정합이 발생할 수 있다. 위에 설명은 특정 조건 지정해서 조회했을 때고, 만약에 5000 > a 등의 조건을 하게 되면
데이터 부정합이 발생 할 수 있다. 이런 경우를 PHANTOM READ라고 한다. SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는
잠금을 걸 수 없다. 
```
### 5.4.4 SERIALIZABLE
```text
 가장 단순하고 엄격한 격리수준이다. 엄격한만큼 동시 처리 성능도 떨어진다. "잠금이 필요없는 일관된 읽기"가 어긋난다.
즉 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 한다. 즉 읽기와 쓰기 모두 데이터를 잠금하여 다른 트랜잭션이 모든 작업을 하지 못하고
대기해야 한다. 따라서 PHANTOM READ가 발생하지 않지만, InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리수준
에서도 이미 PHANTOM READ는 발생하지 않기 때문에 이 격리 수준을 사용 할 필요가 없다.
```






































