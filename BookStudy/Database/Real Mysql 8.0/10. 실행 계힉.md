# 10. 실행 계획
```text
 옵티마이저가 쿼리 최적 처리를 위해 실행 계획을 수립 할 수 있어야 한다. 
EXPLAIN 명령으로 옵티마이저 수립 실행 계획을 확인 할 수 있다.

 MYSQL 서버가 보여주는 실행 계획을 읽는 순서, 실행 계획 출력되는 키워드, 알고리즘에 대해 살펴보자.
```

## 10.1 통계 정보
```text
 5.7까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
하지만 테이블 값들의 실제 분포된 정보가 없기 떄문에 정확도가 떨어지는 경우가 많았다.
 8.0부터 인덱스되지 않은 컬럼들에 대해 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.
```

### 10.1.1 테이블 및 인덱스 통계 정보
```text
 비용 기반 최적화에서 가장 중요한 것은 통계정보다. 엉뚱한 쿼리 실행 가능성이 높아지기 떄문이다.
1억 건 레코드 통계 정보가 갱싱되지 않아 10건 미만으로 돼 있다면 옵티마이저는 인덱스 레인지 스캔이 아니라 풀 테이블 스캔으로 실행 할 것이다.
부정확한 통계 정보로 0.1초 쿼리가 1시간이 소요될 수 있다.
```

#### 10.1.1.1 MYSQL 서버의 통계 정보
```text
 5.6 부터 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구 관리할 수 있게 개선됐다.
5.5 까지 메모리에만 관리되고 테이블의 인덱스 컬럼 분포도도 명령어를 통해 확인 가능했다.
메모리에 관리 될 경우 MYSQL 서버 재시작시 통계 정보가 모두 사라진다.
 5.6 부터 통계 정보를 mysql 디비의 테이블로 관리 할 수 있게 개선됐다.
테이블 생성시 옵션 설정으로 영구적 통계로 저장할지 결정 할 수 있다. 

 통계 정보에는 인덱스에 관련된 정보, 스토리지 엔진 관련 정보가 담겨져 있다.  
통계 정보는 MYSQL 버전에 따라 다른 시점에 갱신 됐는데, 중요한 것은 너무 자주 갱신된다면, 인덱스 레인지 스캔이 풀 테이블 스캔으로 읽힐 수 있다.
 그러나 영구적인 통계 정보를 도입하면서 의도 하지 않은 통계 정보 갱신을 막을 수 있고 자동으로 갱싱되는 설정 값을 통해 제어가 가능하다.
영구적인 통계 정보는 보통 서버 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수 있다.
정보 수집 시간을 설정 할 수 있는데, 통계 정보가 곧 쿼리 성능과 연관되기에 유의미하지만 통계 정보 수집 시간이 너무 길어지지 않게 주의 해야 한다. 
```

### 10.1.2 히스토그램
```text
 5.7 까지는 옵티마이저가 최적 실행 계획을 수립하기에 통계 정보가 부족했다. 따라서 부족한 정보를 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조했다.
8.0 부터 컬럼의 데이터 분포도를 참조 할 수 있는 히스토그램 정보 활용 가능!
```

#### 10.1.2.1 히스토그램 정보 수집 및 삭제
```text
 8.0 히스토그램 정보는 컬럼 단위로 관리되는데 수동으로 명령을 실행해 수집 및 관리된다.
수집된 정보는 시스템 딕셔너리에 함께 저장되고 서버가 시작될 때 특정 DB의 특정 테이블로 로드한다. (information_schema.column_statics)

- 히스토그램 두 가지 타입 
  1. Singleton 
    - 컬럼 값 개별로 레코드 건수를 관리 -> 값 별로 버킷 할당
  2. Equi-Heigh: 컬럼 값 범위를 균등한 개수로 구분해서 관리 -> 균등 개수가 하나의 버킷 할당

 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 컬럼 값의 범위가 관리된다.   
```

#### 10.1.2.2 히스토그램의 용도
```text
 테이블 레코드가 1,000건이고 유니크한 값이 100개라면 MYSQL 서버는 유니크 컬럼에 대해 동등 비교 검색시 대략 10개 레코드가 일치할 것이라 예측한다.
하지만 실제 응용프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다. 예를 들어 사용자마다 주문 정보 개수가 다를 수 있다. 히스토그램 사용 전에는 
이런 부분을 기존 통계 정보를 통해 고려하지 못했다. 
 히스토그램을 통해 각 버킷 별 레코드 건수와 유니크 값 개수 정보를 가지기에 훨씬 정확한 예측이 가능하다. 
 간단 예제에서는 특정 쿼리 실행 계획을 히스토그램 있을 때 없을 때 비교한 결과 11% 비율과 60% 비율로 훨씬 더 정확해진 것을 알 수 있었다.
 
 히스토그램이 존재하지 않는다면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다. 
존재한다면 특정 범위의 데이터가 많고 적음을 식별 할 수 있다. 이는 쿼리 성능에 상당한 영향을 미친다. (힌트를 통해 JOIN_ORDER 순서를 변경하면 성능을 금방 알 수 있다.)
즉 조인 순서를 변경함으로써 옵티마이저가 데이터 분포도를 알 수 없는 상태에서 실행 계획을 세우는 경우 성능 차이가 나게 된다. 
```

#### 10.1.2.3 히스토그램과 인덱스
```text
 인덱스와 히스토그램은 완전히 다른 객체로 비교 대상은 아니지만, 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느정도 공통점이 있다.

 쿼리 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건 절에 일치하는 레코드 건수를 대략 파악하고 여러 실행 계획 중 가장 나은 것을 선택한다.
조건 일치 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링으로 살펴본다. (인덱스 다이브 (Index Dive))

 특정 컬럼이 인덱스로도 있고 히스토그램으로도 수집되어 있다면 옵티마이저는 히스토그램을 쓰지 않고 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
실제 검색 조건의 대상 값에 대한 샘플링을 실행하므로 히스토그램보다 정확한 결과를 기대 할 수 있다.
결론적으로 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 히스토그램을 사용한다고 보면 된다.
 아직은 히스토그램 활용 최적화 기능은 없지만 언젠간 추가되지 않을까 싶다.
```

### 10.1.3 코스트 모델 (Cost Model)
```
- 전체 쿼리 비용 계산 필요 작업 단위들의 비용을 코스트 모델이라고 한다.

- MYSQL 쿼리 처리시 다음과 같은 작업이 필요하다. 
  1. 디스크로부터 데이터 페이지 읽기
  2. 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
  3. 인덱스 키 비교
  4. 레코드 평가
  5. 메모리 임시 테이블 작업
  6. 디스크 임시 테이블 작업
  - MYSQL 서버는 사용자 쿼리에 대해 위에 작업들의 필요량을 예측하고 전체 작업 비용 계산 결과를 바탕으로 최적 실행 계획을 찾는다.
  
 작업 비용은 MYSQL 서버가 사용하는 하드웨어에 따라 달라지기에 예전 버전처럼 고정 비용을 일률적으로 적용하는 최적 실행 계획 수립에 방해요소 였다.
5.7 부터 단점을 보완하기 위해 상수화 돼 있던 각 단위 작업 비용을 DBMS 관리자가 조정 가능하도록 개선됐다.
 코스트 모델은 테이블로 존재한다. server_cost, engine_cost
두 테이블은 공통으로 관리되는 5개 컬럼이 있는데, 단순 정보성 관리 컬럼이다. 그리고 스토리지 엔진 별로 각 단위 비용 설정 가능하다.
정렬, 풀 스캔, 디스크 임시 테이블 또는 메모리 생성 여부, 인덱스 사용 등등의 선택 가능성을 조절 가능하다.  
 그러나 깊이 있는 지식이 있지 않는 이상 디폴트를 그대로 사용하는 것이 좋다.
```

## 10.2 실행 계획 확인
```text
 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인 가능하다.
EXPLAIN는 8.0부터 사용할 수 있는 새로운 옵션이 추가 됐다. 관련되서 기능들을 살펴보자. 
```

### 10.2.1 실행 계획 출력 포맷
```text
 FORMAT 옵션을 사용해 실행 계획 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택 가능하다.
- ex) EXPLAIN FORMAT=TREE 또는 JSON
- 표시되는 정보의 차이는 있으나 실행 계획 수립의 큰 흐름의 차이는 없다.
```

### 10.2.2 쿼리의 실행 시간 확인
```text
- ex) EXPLAIN ANALYZE
    - actual time: 단계별 실제 소요 시간
    - rows: 처리 레코드 건수
    - loops: 반복 횟수
    - 소요시간 등의 정보를 가지고 있기 때문에 쿼리가 완료된 후 볼 수 있다. 따라서 성능이 안 좋은 쿼리는 EXPLAIN으로 먼저 튜닝 후 EXPLAIN ANALYZE를 사용해도 좋다. 
- 쿼리 실행 계획과 단계별 소요된 시간 정보 확인 가능
  - 들여쓰기 같은 레벨 -> 상단 위치 라인 먼저 실행
  - 들여쓰기 다른 레벨 -> 가장 안쪽 위치 라인 먼저 실행

```

## 10.3 실행 계획 분석
```text
 8.0 부터 EXPLAIN 출력 포맷의 형태를 고를 수 있고 디폴트는 테이블이다. 
포맷도 중요하지만, 실제로 실행 계획이 어떻게 접근하고 최적화를 수행하는지 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요하다.

 EXPLAIN의 경우 쿼리 문장에서 사용된 테이블, 임시 테이블(서브 쿼리로 생성 등)을 포함해서 보여준다.
실행 계획의 위에 레코드일수록 쿼리 바깥 (Outer) 부분이거나 먼저 접근한 테이블이고, 아래는 그 반대라고 보면 된다.
```

### 10.3.1 id 컬럼
```text
 SELECT 쿼리 별로 부여되는 식별자 값이다. SELECT 문장 안에 서브 쿼리가 있다면 id는 1,2로 구분되어 보여진다.
단순히 조인의 경우 조인 수 만큼 레도크가 보여지지만, id 컬럼의 값이 달라지진 않는다.
 주의할 점은 id 컬럼 값의 순서가 테이블 접근 순서를 의미하지 않는다. 
```

### 10.3.2 select_type 컬럼
```text
- SELECT 쿼리 별 타입을 표시해주는데, 여러 값이 있다. 간단하게 살펴보자.
  1. SIMPLE
    - UNION, 서브쿼리를 사용하지 않는 단순 쿼리시 표시 된다. 조인만 사용된 경우에도 SIMPLE로 표시된다.
    일반적으로 제일 바깥 쿼리의 타입이 SIMPLE로 표시된다.
    
  2. PRIMARY
    - UNION, 서브쿼리를 가지는 쿼리 가장 바깥 SELECT 쿼리는 PRIMARY로 표시된다. 
    PRIMARY 타입의 쿼리는 전체 쿼리에서 하나만 존재한다. 
   
  3. UNION
    - UNION 대상 두 SELECT 쿼리 중 두 번 째 SELECT 쿼리의 타입은 UNION으로 표시된다. 
    그렇다면 첫 번째 쿼리는 어떤 타입일까? 일반 타입일까? 아니다. 
    UNION 타입 쿼리 결과를 모아 저장하는 임시 테이블(DERIVED) 타입으로 표시된다.   
    FROM () 안에서 UNION ALL을 두 번 쓰는 경우(총 테이블 3개) PRIMARY - DERIVED - UNION - UNION이 된다.
     UNION ALL을 결합해 임시 테이블을 만들어 사용하므로 이런 타입을 가지게 된다.
    일반 쿼리에 UNION을 붙여 사용한 경우 PRIMARY - UNION 타입으로 나온다.
     
  4. DEPENDENT UNION
    - UNION, UNION ALL로 집합을 결합하는 쿼리에 표시되고, 결합된 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
    일반 SELECT 쿼리에서 아이디를 IN을 사용하고 IN절 안에 서브 쿼리 두 개를 UNION으로 사용한 경우, 
    옵티마이저는 IN절 안에 서브쿼리를 먼저 읽지 않고 일반 쿼리를 먼저 읽은 후 IN절 서브 쿼리들을 실행하게 되는데,
    이 때 일반 서브 쿼리 컬럼 값이 서브 쿼리에 영향을 주고, 내부 쿼리가 외부 값을 참조해서 처리 되는 경우 DEPENDENT가 표시된다.
     IN절 안에 외부 값을 연결하는 값이 없더라도, 일반쿼리.id = 내부쿼리.id 조건이 자동으로 추가되어 실행된다.
     
  5. UNION RESULT
    - UNION 결과를 담아두는 테이블을 의미한다.
    8.0 전에는 UNION ALL, UNION 쿼리 모두 UNION 결과를 임시 테이블로 생성했다.
    8.0부터는 UNION ALL은 임시 테이블을 사용하지 않도록 개선됐다. 
    따라서 UNION에 대한 결과를 임시 테이블에 버퍼하고, 실제 SELECT 쿼리가 아니기 때문에 별도 id 컬럼 값은 부여되지 않는다.

  6. SUBQUERY
    - FROM절 외에 사용되는 쿼리만을 의미한다. (FROM절 서브쿼리는 DERIVED 표시)
    - 서브쿼리 사용 위치에 따른 명칭
      - SELECT절 사용 -> 중첩된 쿼리(Nested Query)
      - WHERE절 사용 -> 그냥 서브쿼리
      - FROM절 사용 -> 파생 테이블
      - 스칼라 서브쿼리: 하나의 값 반환 (컬럼이 단 하나인 레코드 1건)
      - 로우 서브쿼리: 컬럼 개수와 관계없이 하나의 레코드만 반환
      
  7. DEPENDENT SUBQUERY
    - 서브쿼리가 바깥 쿼리에 의존적이기 때문에 DEPENDENT 키워드가 붙는다. 
    DEPENDENT UNION처럼 외부 쿼리 먼저 수행 후 내부쿼리가 실행돼야 하므로 일반 서브쿼리보ㅌ다 속도가 느릴 때가 많다.
    
  8. DERIVED
    - SELECT 쿼리 실행 결과로 메모리나 디스크에 임시테이블을 생성하는 것을 의미한다. 
    5.5까지 파생 테이블에 인덱스가 전혀 없어서 조인시 성능 이슈가 있었지만, 
    5.6부터 옵티마이저 옵션에 따라 쿼리 특성에 맞게 임시 테이블에도 인덱스 추가해서 만들 수 있게 최적화 됐다.
    파생 테이블에 대한 최적화가 되어 있지 않은 버전은 조인으로 쿼리를 바꿔주는 것이 좋다. 
    그러나 옵티마이저의 최적화는 한계가 있으므로 최적화 쿼리를 작성하는 것이 중요하다.
     쿼리 튜닝시 실행계획에서 가장 먼저 select_type 값이 DERIVED인 것이 있는지부터 확인한다. 
    그리고 조인으로 해결 할 수 있는 경우 조인으로 사용할 것을 강력 권장한다.
    개발하면서 점점 붙는 쿼리는, 개발은 쉽지만 조인이 아니라 서브쿼리 형태로 작성될 수 있다.
      
  9. DEPENDENT DERIVED
    - 8.0 이전 버전에서 FROM 절 서브쿼리는 외부 컬럼 사용할 수 없었다.
    8.0부터 레터럴 조인(Lateral Join) 기능 추가로 참조 가능하게 됐다.
    사용하는 경우 LEFT JOIN LATERAL 처럼 LATERAL를 같이 입력해줘야 한다.
    따라서 DEPENDENT DERIVED는 레터럴 조인 사용을 의미한다.
    
  10. UNCACHEABLE SUBQUERY
    - 전체 쿼리에서 서브 쿼리 하나만 있더라도 그 서브쿼리가 한 번만 실행되는 것은 아니다. 
    다만 조건이 같은 경우 다시 실행하지 않고 이전 실행 결과를 그대로 사용 할 수 있게 서브쿼리 결과를 내부적인 캐시 공간에 담아둔다.
    SUBQUERY와 DEPENDENT SUBQUERY의 캐시 사용 방법은 다르다. 외부에 영향을 받냐 안받냐의 차이가 그대로 담겨 있다.
    SUBQUERY: 처음 한 번 실행
    DEPENDENT SUBQUERY: 외부 쿼리 값 단위로 캐시가 만들어진다.
    SUBQUERY와 UNCACHEABLE SUBQUERY의 차이는 이 캐시를 사용 할 수 있느냐 없느냐 차이다.
    서브쿼리에 사용자 변수, 호출마다 달라지는 결과 값 함수 사용 등에 의해 캐시 사용 자체가 불가능 할 수 있다.
    이런 경우 표시가 된다.
    
  11. UNCACHEABLE UNION
    - UNION과 UNCACHEABLE 속성이 혼합된 타입
    
  12. MATERIALIZED
    - 주로 FROM(subquery)절 또는 IN(subquery) 형태에서 서브쿼리 최적화를 위해 사용된다.
    5.6 까지 FROM table의 레코드마다 서브쿼리 실행되는 형태로 처리됐다.
    5.7부터 서브쿼리 내용을 임시 테이블로 구체화(Materialization) 후 임시 테이블과 FROM table을 조인하는 형태로 최적화 처리
     서브쿼리 부분이 먼저 처리 되어 임시 테이블로 구체화 후 조인이 된 것을 실행 계획으로 확인 가능하다.
```

### 10.3.3 table 컬럼
```text
TODO 429
```
















### Q
1. EXPLAIN ANALYZE 실 사용 사례 많을까? P.615
2. 

























