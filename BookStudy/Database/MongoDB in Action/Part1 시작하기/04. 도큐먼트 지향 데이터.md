# 4장 주요 내용
- 스키마 설계
- 전자상거래 데이터 모델
- 데이터베이스, 컬렉션, 도큐먼트의 실제적 세부사항들

---

- 몽고DB -> 데이터베이스, 컬렉션, 도큐먼트 단위 구성 살펴보기.
  - 스키마를 강제하진 않지만, 기본적인 내부 기준 정도는 존재해야 한다.
  - 1:N, N:M 관계 표현 방식 이해 필요
  - 전자상 거래 예시 -> 뒷 장에 쿼리, 집계, 업데이트 등 기초가 된다.
  
## 4.1 스키마 설계 원리
- DB 시스템 모델링시 제기할 수 있는 질문
  1. 애플리케이션의 액세스 패턴은 무엇인가?
     - 앱의 요구사항
     - 읽기/쓰기 비율
     - 쿼리 복잡성 수준
     - 집계 데이터 사용 여부
     - 데이터 저장 수치
  2. 데이터베이스에 어떤 기능이 있는가?
     - RDBMS
       - 애드혹 쿼리 및 조인 특징
       - 정교한 데이터 수정 가능
     - 몽고DB
       - 애드혹 쿼리 허용, 조인 지원 X
       - 기존 방식 트랜잭션 지원은 없지만, 다양한 업데이트 지원
     - unique key, pk를 무엇으로 만드는가?

## 4.2 전자상거래 데이터 모델 설계
- 전자상거래는 전적으로 RDBMS에 속한 도메인이었다.
  - 이유
    1. 일반적으로 트랜잭션이 필요 (현재는 몽고DB도 트랜잭션 지원이라 내용 체크 필요)
    2. 다양한 데이터 모델, 동적 쿼리

## 4.2.1 스키마 기본
- RDBMS -> 테이블 정규화가 일반적이지만, 몽고DB는 하나의 컬렉션으로 대체 가능
- 고유한 슬러그
- 중첩 도큐먼트
  - 상품에 대한 자세한 정보를 갖는 서브도큐먼트
- 일대다 관계
  - 상품, 카테고리 관계
- 다대다 관계
  - 상품, 카테고리(주요, 서브) 관계
- 관계 구조

### 4.2.2 사용자와 주문
- db.orders.find({user_id: user['_id']})
- 도큐먼트에 대한 생각

### 4.2.3 상품평
- 상품평 도큐먼트에 추천수 저장

## 4.3 실제적 세부사항: 데이터베이스, 컬렉션, 도큐먼트

### 4.3.1 데이터베이스
- 데이터베이스는 컬렉션, 인덱스의 물리적인 모음 -> 네임스페이스
- 데이터베이스 관리
  - 데이터베이스 -> 첫 컬렉션 쓰기 -> 자동 생성
    - use garden
      - 컬렉션이 없다면 아직 데이터베이스 생성 상태 X
  - products.find({}).delete_many
    - 컬렉션 내 모든 데이터 삭제
  - products.drop
    - 컬렉션 삭제
  - db.drop
    - 모든 컬렉션 삭제
  - 데이터베이스 삭제 -> 디스크로부터 삭제 -> 복구 불가
- 데이터 파일과 할당
  - MongoDB -> 데이터베이스 생성 -> 데이터 파일 디스크에 할당 (모든 컬렉션, 인덱스, DB 메타데이터, ...)
    - /data/db 경로에 저장
    - mongod.lock: 서버의 프로세스 ID 저장
    - choisinsa 데이터베이스 생성 -> choisinsa.ns (namespace) 파일이 만들어짐
      - ns 파일은 16MB 고정, 26000개 엔트리 저장 가능 -> 인덱스와 컬렉션 개수 26000 이하만 생성 가능 - 조절 가능
      
### 4.3.2 컬렉션
- 컬렉션
  - 비슷한 도큐먼트를 담고 있는 컨테이너
- 컬렉션 관리
  - db.createCollection("users", {size: 20000})
    - 크기를 미리 할당!
- 캡드 컬렉션
  - 높은 성능의 로깅 기능을 위해 설계
  - 일반 컬렉션과 다르게 고정 크기를 갖는다.
    - 크기 초과시 가장 오래된 도큐먼트를 덮어쓴다.
  - 예시 -> 유저 행위 기록
```mongodb-json
db.createCollection("users.actions",
 {capped: true, size: 16384, max: 100})
```
- 일반 컬렉션의 모든 연산이 허용되지 않는다.
  - 개별 도큐먼트 삭제 불가
  - 로깅을 위해 만들어진 것! -> 삭제, 업데이트 구현 필요 X
- TTL 컬렉션
  - 특정 시간 경과 도큐먼트 만료(expire) 기능 제공
  - 특별한 인덱스를 사용해 구현
```mongodb-json
db.reviews.createIndex(
    { time_field: 1 },
    { expireAfterSeconds: 3600 }
)
```
- time_field 인덱스 생성 -> 주기적으로 타임스탬프 값 체크 -> 자동 삭제
  - 3600 -> 1시간 뒤 삭제
  - TTL 인덱스는 여러 제약사항 존재
    - 이미 인덱스인 필드는 TTL 인덱스 불가
    - 캡드 컬렉션에선 생성 불가
    - 사용 가능성은 매우 낮지만, 몇몇 사례에 유용하다
- 시스템 컬렉션
  - 몽고디비 내부 -> 컬렉션 부분적 사용
    - system.namespaces: DB 내 모든 네임스페이스 조회 
    - system.indexes: 인덱스 정의 저장

### 4.3.3 도큐먼트와 인서트
- 도큐먼트 시리얼라이제이션, 타입 그리고 한계
- 도큐먼트 -> 몽고 저장 전 BSON 시리얼라이즈 -> 디시리얼라이즈
  - 드라이버가 해당 과정 처리
- 문자열
  - 모두 UTF-8 형식이어야 한다. -> 안 되면 BSON 저장
- 숫자
  - double, int, long 
- 날짜와 시간
- 가상 타입
- 도큐먼트 크기에 대한 제약
  - 도큐먼트 최대 크기는 16MB
- 대량 삽입 연산
  - 성능 측면에서 유용하다.
  - 100만 건 도큐먼트 삽입 -> 여러 개의 대량 삽입 도큐먼트 그룹으로 분리
  - 이상적인 크기 -> 10 ~ 200
    - 어떠한 삽입 연산도 16MB 이상 허용 X

## 4.4 요약
