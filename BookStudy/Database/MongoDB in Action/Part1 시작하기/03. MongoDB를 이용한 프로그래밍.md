# 3장 주요 내용
- MongoDB 루비 API 소개
- 드라이버 작동 방식의 이해
- BSON 포맷과 MongoDB 네트워크 프로토콜의 이용
- 샘플 애플리케이션 작성

---

## 3.1 루비를 통해 보는 MongoDB

### 3.1.1 설치와 연결

### 3.1.3 쿼리와 커서

### 3.1.4 업데이트와 삭제

### 3.1.5 데이터베이스 명령어

## 3.2 드라이버 작동 원리
- 셸을 이용해 명령 실행시 내부에서 어떤 일이 일어날까?
  - 드라이버가 어떻게 데이터를 직렬화하고 데이터베이스와 통신하는지 알아보자
- MongoDB 드라이버 세 가지 주요 기능 수행
  1. MongoDB 객체 ID 생성 -> 모든 도큐먼트의 _id 
  2. 도큐먼트 <-> BSON (이진 데이터 포맷)
  3. 와이어 프로토콜 사용 -> 네트워크 소켓을 통해 DB와 통신

### 3.2.1 객체 ID 생성
- 수동 입력 제외 MongoDB 객체 ID 생성
  - 도큐먼트를 코어 서버에 전송 전 Driver -> _id 필드 존재 체크 -> 없는 경우 객체 ID 생성 후 _id 필드에 저장
- MongoDB 객체 ID -> 전역적으로 고유하도록 설계
  - 어떻게 고유할까?
    - 일련의 임의의 문자열 -> 12바이트의 16진수 표현 -> 실제 유용한 정보 저장!
      - 4c291856 238d3b 19b2 000001
        - 4c291856: 4바이트 타임스탬프 -> 유닉스 표준 timestamp
        - 238d3b: 3바이트 서버 ID -> 
        - 19b2: 2바이트 프로세스 ID
        - 000001: 3바이트 카운터 -> 객체 ID 생성시마다 하나씩 증가하는 프로세스의 로컬 카운터
  - 몽고 DB 객체 ID는 왜 이러한 형태일까?
    - ID가 서버가 아닌 드라이버에서 생성된다! 
      - RDBMS -> 서버에서 PK 증가 -> 서버 병목 현상 발생 가능
      - 하나의 드라이버에서 ID 생성 -> 드라이버간 통신 없이 유니크한 식별자
        - 유니크한 식별자가 겹치지 않도록 구성된 것!
    - 부수적 장점 -> 타임 스탬프 포함! -> 도큐먼트 생성 시간 쉽게 알 수 있다.
```mongodb-json
db.users.find(
    { username: "choi" },
    {
        _id: 1
    }
).generation_time

db.users.aggregate([
  { $match: { username: "choi" } },
  {
    $project: {
      _id: 1,
      createdAt: { $toDate: "$_id" }  
    }
  }
])
```
- MongoDB shell에서 직접 속성 접근 방식 불가 -> .generation_time -> 동작 안함
- aggregate 사용해 createdAt: { $toDate: "$_id" } 사용 (ObjectId → ISODate)

## 3.3 트위터 모니터링 애플리케이션 구축
- 트위터 API 호출 -> 응답 JSON -> MongoDB 도큐먼트 저장
  - 몽고는 간단! 
  - RDBMS는 여러 개 테이블로 정규화 필요

### 3.3.1 설정
- 이 앱은 네 개의 루비 라이브러리 필요 

### 3.3.2 데이터 수집
- index 정렬
  - field: 1 -> 오름차순 
  - field: -1 -> 내림차순 

### 3.3.3 아카이브 열람

## 3.4 요약
