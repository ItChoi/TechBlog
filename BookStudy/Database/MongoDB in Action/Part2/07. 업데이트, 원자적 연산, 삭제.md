# 도큐먼트 업데이트
- 도큐먼트 업데이트 두 가지 방식
  - 도큐먼트 전체 대치 (덮어쓰기)
    - 도큐먼트 크기만큼 덮어써야 한다.
  - 도큐먼트 내 특정 필드 수정 (타깃 수정)
    - 업데이트 연산자 활용 $set (그 외 다양)
## 7.1.1 대치에 의한 수정
- 먼저 find로 찾은 후 필드 수정 후 업데이트 -> find, update 두 방의 쿼리
- 전체 도큐먼트 대치 -> 업데이트 연산이 가장 먼저 페치되야 하는 이유
- 더 일반적인 방법이다.
## 7.1.2 연산자에 의한 수정
- update에 조건을 주어 바로 변경한다.
- 더 나은 성능을 갖는다.
- 도큐먼트의 원자적 업데이트에 더 적합
## 7.1.3 두 방법 비교
- 예시: 상품의 리뷰수 증가
  - 대치 방식 사용 -> 좋은 방식이 아니다.
    - 도큐먼트를 읽을 때 변경 발생 -> 낙관적 잠금 수행해야 한다.
      - A가 읽음 -> 3
      - B가 수정 -> 4
      - A가 수정 -> 4 (5가 되야 정상)
# 7.2 전자상거래 업데이트
## 7.2.1 상품과 카테고리
- 상품의 평점 평균
  - 대치 방식: 전체 조회 -> 루프 -> 계산 -> 업데이트
  - 타깃 방식: 총합 보관 필드 추가/조회 -> 계산 -> 업데이트
- 상품 리뷰
  - 읽기/쓰기 비율 -> 많은 유저는 리뷰를 작성 보다 읽기 비중이 높다. -> 쓰기에 대해 집계
- 카테고리 계층 구조
  - 도큐먼트 -> 카테고리가 각 조상 카테고리 리스트를 갖는다 -> 읽기에 최적화 됌
    - 카테고리 조상 리스트 업데이트
      - 조상 리스트를 순회하여 업데이트
      - 조상 Level 변경 -> 해당 카테고리 및 해당 카테고리를 조상으로 둔 데이터를 루프 -> 업데이트
        - 조상 리스트 계산 없이도 업데이트 수행 가능 -> 대치 방식
### 7.2.2 리뷰
- 예시
  - 추천수, 추천자 아이디 리스트를 갖는다.
  - $int를 통해 추천수 증가, $push를 통해 아이디 추가
    - 추천은 원자적이고 효율적으로 가능
  - 대치 방식으로 할 경우 레이드 컨디션 제어 필요 -> 낙관적 잠금
    - A가 읽음 -> 3
    - B가 수정 -> 4
    - A가 수정 -> 4 (5가 되야 정상)
### 7.2.3 주문
- 타깃 방식을 이용해 add_to_cart 함수 구현 (카트)
  - 이미 들어간 카트는 도큐먼트 생성은 되지 않지만, 수량을 수정돼야 한다.
# 7.3 원자적 도큐먼트 프로세싱
- findAndModify: 자동 업데이트, 도큐먼트 반환
- 원자적 업데이트가 완료되어야 다른 모든 조작이 가능하다.
  - 몽고DB의 모든 업데이트는 원자적이다.
## 7.3.1 주문 상태 전이
- 유저가 구매를 승인 하기 전이라고 가정
  - 동기적 승인을 위한 체크 리스트
    - 유저가 보고 있는 액수를 승인해야 한다.
    - 승인 과정에서 카트 내용이 변경되면 안 된다.
    - 승인 실패시 카트는 이전 상태로 돌아가야 한다.
    - 신용카드 결제 -> 지불 정보 주문에 저장 -> 주문 상태 변경(PRE-SHIPPING)
- 체크아웃을 위한 주문 준비
- 주문 확인 및 승인
- 주문 완료하기
### 7.3.2 재고 관리
- A가 물을 하나 사면, B가 살 수 있는 재고가 하나 줄어든다.
- 재고 컬렉션 존재
  - 10개의 물 도큐먼트 존재
  - 상태 (AVAILABLE, IN_CART, PRE_ORDER, PURCHASED)
## 7.4 실제적인 세부사항: MongoDB 업데이트와 삭제
### 7.4.1 업데이트 타입과 옵션
### 7.4.2 업데이트 연산자
- $inc
  - 도큐먼트 크기 변경 거의 X, 지정된 값만 영향
- $set, $unset
  - 어떤 타입도 지정 가능
  - unset을 통해 도큐먼트 해당 키 삭제
- $setOnInsert
  - 도큐먼트 수정이 아닌 삽입시 필드 수정
- 배열 업데이트 연산자
  - $push
    - 배열에 값 추가, 기본적으로 배열 끝에 단일 요소 추가
  - $pushAll
    - 여러 개의 값을 배열에 추가 가능 (사용 안 하는 것이 좋다.)
  - $each
    - 여러 값 추가시 $push와 함께 사용 가능
  - $slice
    - 값 배열을 보다 쉽게 관리 가능
    - 결과 배열을 특정 크기로 잘라 이전 버전 제거하는 등에 사용
  - $sort
    - 정렬
  - $addToSet
    - 배열에 존재하지 않을 경우 값 추가
  - $pop
    - 배열 삭제 기본적인 방법
    - 마지막으로 추가된 값 제거
  - $bit
  - $pull & $pullAll
    - 정교한 $pop이라 볼 수 있다.
    - 원소 위치 대신 값을 지정해 삭제!
  - 위치 업데이트
    - 서브 도큐먼트 우치를 모를 때, 또는 존재 여부 자체를 모를 때 -> 쿼리 셀렉터, 위치 연산자를 사용해 업데이트 가능
      - line_items.$.quantity
        - $가 위치 연산자
          - 도큐먼트 발견시 $가 도큐먼트 값으로 대치된다.
### 7.4.3 findAndModify 명령
- query
  - 도큐먼트 쿼리 셀렉터
- update
- remove
- new
- sort
- fields
- upsert
### 7.4.4 삭제
### 7.4.5 동시성, 원자성, 고립
- 몽고DB에서 동시성 수행을 이해하는 것은 중요하다.
  - v2.2 전 까진 잠금(locking)이 정교하지 못했다. -> 1개의 글로벌 읽기/쓰기 잠금이 mongod 인스턴스 전ㅊ를 관장한다.
    - 하나의 쓰기 || 다수의 읽기 -> 둘 중 하나만 허용
  - v2.2에서 데이터베이스 레벨 잠금으로 변경
    - 인스턴스 전체가 아니라, 데이트베이스 레벨로 적용
  - v3.0에서 WiredTiger 스토리지 엔진 -> 컬렉션 레벨에서 작동, 도큐먼트 수준의 잠금 기능 제공
- 최적화에도 불구하고 몽고DB 잠금은 읽기/쓰기가 많은 작업 부하가 성능에 영향을 미칠 수 있다.
  - 가장 좋은 방법은 MMAPv1 스토리지 엔진 사용시 트래픽 대량 발생 컬렉션 -> 별도 데이터베이스 저장
  - v3.0 WiredTiger -> 데이터베이스 레벨이 아닌 컬렉션 레벨 작동이라 부하가 더 적다.
- 도큐먼트 업데이트 & 삭제 -> 장단점 존재
  - 모든 도큐먼트 업데이트, 삭제 상황 -> 해당 연산이 양보되지 않게 $isolated 옵션 사용
### 7.4.6 업데이트 성능
- 현재 기본 스토리지 엔진인 MMAPv1에만 적용되는 얘기
- 디스크의 도큐먼트 업데이트 시 본직적으로 세 가지 종류
  - 가장 효율, 하나의 값만 수정, 전체 BSON 도큐먼트 크기가 변하지 않을 때, 즉 $inc 사용은 디스크 차지 크기에 변함이 없다.
  - 도큐먼트 크기 또는 구조를 바꾸는 업데이트, 즉 전체 도큐먼트를 디스크에 다시 쓰기를 해야 한다. 많은 업데이트 발생시 도큐먼트를 작게 유지하는 것이 가장 좋다.
  - 도큐먼트를 다시 쓰기 할 때 업데이트, 도큐먼트 확장으로 디스크 내 할당 공간이 없다면 다시 쓰기 뿐만 아니라 새로운 공간으로 이동해야 한다. -> 리소스 많이 필요
## 7.5 업데이트 연산자 리뷰
## 7.6 요약