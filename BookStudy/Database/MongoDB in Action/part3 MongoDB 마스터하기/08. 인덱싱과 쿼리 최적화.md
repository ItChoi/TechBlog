# 8장 주요 내용
- 인덱싱의 기본 개념과 이론
- 인덱스 관리를 위한 실용적인 조언
- 복잡한 쿼리에 대한 복합 인덱스 사용
- 쿼리 최적화
- 모든 MongoDB 인덱싱 옵션
---
질문이 어렴풋 기억났슴니당
MongoDB WiredTiger 스토리지 엔진은 모든 도큐먼트, 컬렉션, 인덱스를 포함한 데이터 파일을 4KB 페이지 청크 단위로 램에 올라가는데
Q. MySQL도 동일한 개념으로 4KB 페이지 청크 단위로 램에 올라가는지

위의 질문이 맞다면
MySQL은 인덱스를 생성하면 루프 - 브랜치 - 리프 노드 구조에서 리프노드에는 PK만 가지고 있는 반면, 몽고DB 같은 경우에 PK가 아닌 데이터 자체를 갖고 있다고 알고 있는데,
Q. 4KB 페이지 청크 단위를 저장함에 있어서 몽고 DB가 더 많은 용량을 필요로 하는지

- WiredTiger 스토리지 엔진
  - 모든 도큐먼트, 컬렉션, 인덱스를 포함한 데이터 파일 -> 4KB 페이지 청크로 OS에 의해 램으로 스왑된다.
    - 해당 페이지 데이터 요청시 - OS는 페이지가 램에 있는지 체크해야한다.
      - OS -> 페이지 못찾음 -> 페이티 폴트 예외 발생 -> 디스크로부터 램으로 불러들인다.
    - 램 충분 -> 모든 데이터 파일이 메모리에 로드
      - 불충분 -> 페이지 폴트 발생 가능성이 높아진다. -> OS가 디스크에 빈번히 접근 -> I/O연산 느려진다.
      - 데이터 크기 > 가용 램 크기 두 개가 매우 차이날 경우 스래싱이 발생 
    - 메모리 데이터 수정 -> OS에 의해 비동기적으로 디스크에 반영
    - 페이지 폴트가 자주 발생하지 않게 최소한 인덱스만큼은 램에 들어가야 한다.
      - 필요없는 인덱스를 만들지 말아야 할 이유
      - 인덱스 생성마다 유지를 위한 더 많은 램이 필요해진다.
      - 복합 인덱스는 단일 키 보다 더 많은 공간을 필요로 한다는 점을 알아야 한다.
- 인덱스
  - 인덱스에 있는 데이터와 램에 별도로 저장, 클러스터되지 않는다.
    - 인덱스 순서와 기본 데이터 순서와 관계 없다.

- 몽고는 내부적으로 B-트리 인덱스 생성
  - 두 가지 특징
    - 정확한 일치, 범위 조건, 정렬, 프리픽스 일치, 인덱스만의 쿼리 등 다양한 쿼리 처리 가능
    - 키 추가/삭제 -> 밸런스 상태 유지
- 인덱스 타입
  - 고유 인덱스
    - 도큐먼트 필드가 고유 값 -> unique 옵션 지정
  - 희소 인덱스
    - 컬렉션 내 도큐먼트가 인덱스 키를 가지고 있지 않아도 인덱스에 해당 엔트리가 존재!
    - 상품 -> cateogry_id(인덱스) -> 카테고리 지정되지 않은 상품 -> cateogry_id null 인덱스 엔트리!
  - 다중키 인덱스
  - 해시 인덱스
    - 동등 쿼리 -> 거의 동일하게 작동, 범위 쿼리는 지원 X
    - 다중 키 해시 인덱스 X
    - 부동 소수점 -> 해시되기 전 정수로 변환
  - 지리공간적 인덱스
- 인덱스 구축 두 단계
  - 인덱스할 값 정렬
    - 정렬된 데이터는 B-트리에 매우 효율적으로 추가 가능!
  - 정렬된 값들이 인덱스로 삽입
  - currentOp() 메서드를 통해 인덱스 생성 진척 상화 확인 가능
- 백업
  - 인덱스 구축은 어렵기 때문에 백업을 해놓아야 한다.
  - 모든 백업이 인덱스를 포함하지 않는다.
  - mongodump, mongorestore, MongoDB 데이터 파일 자체 백업 (인덱스 포함 백업)
- 쿼리 최적화
  - 슬로우 쿼리 이유는 다양하다.
    - 애플리케이션 설계
    - 데이터 모델
    - 부족한 하드웨어 
    - 등등등
  - 슬로우 쿼리 탐지
    - 대부분 앱 내 쿼리가 100밀리초 이내 실행- > 안전!
      - MongoDB logger를 통해 연산이 100밀리초 넘어서면 경고 메시지 프린트! -> 가장 먼저 로그를 보면 된다.
        - grep -E '[0-0]+ms' mongod.log
- 느린 쿼리 분석
  - EXPLAIN() 사용과 이해
    - millis -> 쿼리 실행 소요 시간
    - nscanned -> 몇 건의 도큐먼트를 스캔했는지