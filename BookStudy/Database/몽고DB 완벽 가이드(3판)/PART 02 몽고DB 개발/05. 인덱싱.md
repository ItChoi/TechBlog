몽고 DB에서도 인덱스 사용시 효율적인 쿼리가 가능하다.  
컬렉션에 적합한 인덱스 선택시 성능에 큰 영향을 미친다.  

# 5.1 인덱싱 소개
책의 인덱스와 유사하다.  
전체를 살피는 대신, 특정 내용을 가리키는 정렬된 리스트를 확인한다.  
  
인덱스를 사용하지 않는 쿼리를 '컬렉션 스캔'이라 한다.  
쿼리 결과를 위해 전체 훑어야 한다. (책을 1페이지부터 끝까지 읽는 것과 같다.)  
당연하게 컬렉션이 클수록 컬렉션 스캔이 느려진다.  
  
```mongodb-json
for (i=0; i < 1000000; i++) {
    db.users.insertOne(
        {
            "i" : i,
            "username" : "user" + i,
            "age" : Math.floor(Math.random() * 120),
            "created" : new Date()
        }
    );
}
```
- 인덱스 사용/미사용 쿼리 성능 차이 확인
- 몽고 DB에서도 explain - 실행 계획 확인 가능하다.
  - db.users.find({"username" : "user101"}).explain("executionStats")
- 출력 필드는 5장에서 살펴본다.
- totalDocsExamined는 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트 개수
- millis는 쿼리 실행 시간을 밀리초 단위로 보여준다.

## 5.1.1 인덱스 생성
- createIndex 컬렉션 메서드 사용
  - db.users.createIndex({"username" : 1})
    - 컬렉션에 인덱스 생성
  - 큰 인덱스 생성시 시간이 좀 걸릴 수 있다. 인덱스 구축 진행률 체크 명령어
    - db.currentOp()
    - mongod
  
인덱스는 쿼리 시간에 놀라운 차이를 만든다. (NoSql에서도...)  
RDBMS와 마찬가지로 단점이 존재한다.  
인덱싱된 필드를 삽입, 갱신, 삭제 세 가지 작업은 더 오래 걸린다.  
  
몽고DB 인덱스는 RDBMS 인덱스와 거의 동일하게 작동한다.  
인덱스 생성 대상을 찾을 땐, 자주 쓰는 쿼리와 빨리 수행해야 하는 쿼리를 조사해야 한다.  
해당 쿼리가 특히 자주 쓰이거나 병목된다면, username 인덱싱이 좋지만,  
소요 시간에 구애받지 않는다면 인덱싱하기 적합하지 않다.  
  
## 5.1.2 복합 인덱스 소개
두 개 이상의 키를 기반으로 인덱스를 작성해야 하는 경우가 많다.  
인덱스는 모든 값을 정렬된 순서로 보관하는데,  
인덱스가 큰 도움이 되지 않는 경우도 있다.  
- db.users.find().sort({"age", 1, "username" : 1)
  - age로 정렬 후 username 정렬
    - username 인덱스는 정렬에 큰 도움이 되지 않는다.
  - 정렬 최적화 할 때, age/username 인덱스를 만든다.
    - db.users.createIndex({"age" : 1, "username" : 1})
      - 복합 인덱스라 불린다. -> 2개 이상 필드로 구성된 인덱스
      - 쿼리 정렬 방향 여러 개, 검색 조건에 여러 개 키가 있을 경우 유용하다.
      - 두 인덱스 항목은 내부 스토리지 엔진에 의해 사용되어 도큐먼트 데이터를 찾는다.
  
- db.users.find({}, {"_id" : 0, "i": 0, "created" : 0})
  
몽고 DB는 실행 쿼리 종류에 따라 인덱스 사용 방법이 다르다.  
- 가장 많이 사용하는 세 가지 방식
  1. db.users.find({"age" : 21}).sort({"username" : -1})
     - 단일 값 찾는 동등 쿼리
     - 곧바로 정확한 나이로 갈 수 있어 매우 효율적인 쿼리
  2. db.users.find({"age" : {"$gte" : 21, "$lte" : 30}})
     - 범위 쿼리, 21 ~ 30
     - 첫 번 째 인덱스 age를 통해 일치하는 도큐먼트를 먼저 찾는다.
  3. db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})
     - 일반적으로 1, 2 쿼리보다 비효율적이다.
     - 결과 반환 전 메모리에서 username 정렬을 해야 한다.
     - 결과가 32MB 이상이면 데이터가 너무 많아 정렬 거부하는 오류를 낸다.
       - 정렬 작업 지원 인덱스 생성하고 sort, limit 함께 사용하여 32MB 이하를 유지하자. -> 적을수록 좋다.
- 3번의 인덱스를 (username, age) 복합 인덱스 사용시 모든 인덱스 항목을 탐색하긴 한다.
  - age 부분 이용해 일치 도큐먼트를 가져오고, 인메모리 정렬을 하진 않는다.
  - 즉 정렬 키를 컷 번 째에 놓으면 좋다. -> 동등, 다중 값 쿼리와 정렬을 고려한 복합 인덱스 구성시 모범 사례다.

## 5.1.3 몽고 DB가 인덱스를 선택하는 방법
먼저 쿼리 모양을 체크한다.  
검색 필드, 정렬 여부 등 추가 정보 체크하고 이를 기반으로 사용 할 인덱스 후보 집합을 식별한다.  
인덱스 5개가 있다고 했을 때, 3개의 인덱스가 후보로 식별됐다고 가정해보자.  
몽고 DB는 세 개의 인덱스를 통해 세 개의 쿼리 플랜을 만든다.  
그 후 병렬 스레드로 쿼리를 실행한다. -> 가장 빠른 결과 반환 체크 용도  
  
즉 레이스와 같다. 인덱스 후보들은 가장 빨리 레이스에 도착해야 선택받을 수 있다.  
- 쿼리 체크 -> 검색, 정렬 여부 등 체크 -> 인덱스 후보 식별 -> 인덱스별 쿼리 플랜 생성 -> 병렬 스레드로 쿼리 실행 -> 가장 빠른 인덱스 선택  
- 레이스 결과로 전체 승리 플랜을 산출한다.
- 서버는 쿼리 플랜의 캐시를 유지하고, 이후 모양이 같은 쿼리에 인덱스를 사용한다.  
- 컬렉션, 인덱스 변경시 쿼리 플랜이 캐시에서 제거된다.
- 쿼리 플랜 캐시는 명시적 삭제도 가능하고, 몽고DB 프로세스를 다시 시작할 때도 삭제된다.

## 5.1.4 복합 인덱스 사용
복합 인덱스는 단일 인덱스보다 복잡하지만, 매우 강력하다.  
읽기와 쓰기가 모두 효율적으로 수행할 수 있도록 인덱스를 설계해야 한다.  
인덱스를 잘 설계 하려면, 실제 워크로드에서 실질적인 테스트와 조정을 거쳐야 한다. 머리로만 생각해서 설계하고 확정짓지 말자.  
  
먼저 인덱스의 '선택성'을 고려한다.  
즉 전체 데이터 중 인덱스를 통해 데이터를 25% 이내로 줄일 수 있는지, 정렬 처리 방식 여부를 고려해야 한다.  
  
예를 들어 학생 데이터 백만 개가 있다고 가정하자.  
도큐먼트는 다음과 같다.  
```mongodb-json
{
    "_id" : ObjectId("2131dsfdsf23r2fsdf"),
    "student_id": 0,
    "scores" : [
        {
            "type" : "exam",
            "score" : 38.023912391239
        },
        ...    
    ],
    "class_id" : 127
}
```
- 인덱스 두 개를 생성하고, 몽고DB는 이 인덱스를 사용하는지, 사용한다면 어떻게 사용하는지 살펴보자.
  - db.students.createIndex({"class_id" : 1})
  - db.students.createIndex({"student_id" : 1, "class_id" : 1})
  
- 예제 쿼리
```mongodb-json
db.students.find({"student_id" : {"$gt":500000}, "class_id": 54)
    .sort({"student_id" :  1})
    .explain("executionStats")
```
- 쿼리 설명
  - ID가 500000 보다 큰 모든 레코드를 요청 (100만 건이면 절반)
  - ID가 54인 레코드 요청 (데이터에는 500개라고 가정)
  - student_id를 기준으로 오름차순 정렬
  - explain를 통해 인덱스 사용해서 쿼리 흐름 파악
    - json으로 출력된다.
    - executionStats 필드는 선정된 쿼리 플랜에 대해 설명하는 통계도 포함된다.
- 실행 계획 출력 설명
  - executionStats - totalKeysExamined
    - 몽고DB가 결과 셋 생성을 위해 인덱스 내에서 몇 개의 키를 통과했는지 나타낸다.
    - 몽고 DB가 쿼리 일치 도큐먼트 찾기 위해 얼마나 많은 인덱스 통과 했는지 알 수 있다.
      - 예제에선 일치 도큐먼트 9903개 찾기 위해 인덱스 키 85만 477개 검사 함
        - 인덱스가 선택되지 않았다. -> 실행 계획 'executionTimeMillis' 필드를 통해 4.3초가 걸린 것을 알 수 있다.
        - '선택성'은 인덱스 설계 시 핵심 목표
  - 쿼리 플랜에 "SORT" 단계 표시 -> 정렬시 인덱스 사용 X, 인메모리 정렬 했다는 의미
- 인덱스 선택의 문제
  - 전체 조회 쿼리는 student_id가 50만 보다 큰 레코드, 즉 절반을 요청했다.  
  - 다중 값 조건(50만 이상)과 동등 조건(class_id = 54)를 포함한다.
  - 동등 조건(class_id = 54)은 데이터 85만 개가 아니라 1만 개 미만 레코드로 제한 할 수 있다.
    - 다시말해 범위 조건이 아닌, 'class_id'만 인덱스로 사용하는 것이 좋다.
- 몽고 DB, 특정 인덱스 사용 강제하는 방법 두 가지
  - 그러나 쿼리 플래너 재정의는 매우 신중해야 한다.
  1. 커서 hint 메서드 사용
- 인덱스를 다음과 같은 순서로 구성한다.
  - class_id, student_id
    - 동등 조건을 앞에, 범위 조건을 뒤에 가도록 복합 인덱스를 설계해야 한다.
- 복합 인덱스 설계시 고려 사항
  1. 동등 필터
  2. 다중 값 필터
  3. 정렬 구성 요소
  4. 동등 필터는 맨 앞에 위치
  5. 정렬 필터는 다중 값 필터 앞에 위치
  6. 다중 값 필터는 마지막에 위치
  - 1, 2번을 만족 하더라도, 정렬 조건을 인덱스 구성 요소가 아니게 하는 경우 인메모리 정렬이 일어나 훨씬 비효율적이 된다.
- 복합 인덱스 설계시 트레이드 오프가 있다.
  - 인메모리 정렬을 피하기 위해, 반환하는 도큐먼트 개수보다 더 많은 키 검사 필요
    - 복합 인덱스 사이에 정렬 필드를 포함해야 한다.
      - class_id, final_grade, student_id
        - 'final_grade'는 정렬 조건
        - 결과 셋에 포함될 도큐먼트보다 더 많은 도큐먼트 키 검사하지만, 인메모리 정렬이 필요 없어 시간 절약 가능하다.
  
- 키 방향 선택하기
  - 복합 인덱스 사용시, 검색 조건의 정렬 방향이 다르다고 생각해보자.
    - age는 오름차순, 사용자명은 내림차순
      - 이 전에 만들었던 복합 인덱스는 효율적인 사용을 할 수 없다.
        - {"age" : 1, "username" : -1}
          - 이 방향으로 두 번 째 인덱스를 생성해야 한다.
      - 복합 인덱스 사용시 적절한 방향의 인덱스를 사용해야 한다.
    - 다중 조건에 따른 정렬 시 문제가 발생, 단일 키 정렬시 굳이 인덱스 생성 없이 정렬을 자유롭게 가능하다.
      - 단일 키 일 시 {"age" : 1}, {"age" : -1} 두 개의 인덱스 생성이 필요하지 않다.
  
- 커버드 쿼리 사용하기
  - 인덱스에 쿼리 결과가 모두 포함되면 쿼리가 커버드 된다고 한다. (커버드 쿼리)
  - 커버드 쿼리를 위해 "_id" 필드는 반환 받지 않도록 키를 지정한다. (?)
  - 쿼리하지 않는 필드에 인덱스를 만들어야 할 수 있다. - 늘어날 부하, 쿼리 속도 잘 조율 필요
  - 커버드 쿼리 실행 계획 결과에 'IXSCAN' 단계가 있다. "executionStats.totalDocsExamined"의 값은 0이 된다.
  
- 암시적 인덱스
  - 복합 인덱스는 '이중 임무' 수행 가능, 쿼리마다 다른 인덱스처럼 동작 할 수도 있다.
    - {"age" : 1, "username" :1}
      - age 필드는 {"age" : 1}일 때랑 동일하게 정렬
    - {"a" : 1, "b" : 1, "c" : 1, ..., "z" : 1}
      - 위에 인덱스는 사실상 아래와 같은 인덱스를 갖는다.
      - {"a" : 1}
      - {"a" : 1, "b" : 1}
      - {"a" : 1, "b" : 1, "c" : 1, ...}
      - 따라서 {"b" : 1}, {"a" : 1, "c" : 1} 인덱스 필요시 최적화되지 않는다.
  
## 5.1.5 $ 연산자의 인덱스 사용법
- 쿼리마다 인덱스를 효율적으로, 아니면 전혀 사용 못 할 수도 있다.
  
- 비효율적인 연산자
  - 일반적으로 부정 조건은 비효율적이다.
    - 기본적으로 전체 인덱스를 살펴야 한다.
    - ex) $ne : 3 -> 3 미만, 3 초과 인덱스 항목 모두 조사 필요
  - $not 사용시 대부분 테이블 스캔 수행, $not in은 항상 테이블 스캔 수행
  
- 범위
  - 복합 인덱스는 다중 절 쿼리를 더 효율적으로 실행하도록 돕는다.
  - 인덱스 설계시 동등 조건을 앞에, 범위 조건을 후순위에 두는 것이 좋다.
    - 동등 조건 일치 후 범위 안에서 검색하도록 해준다.
  - 하나의 쿼리에 두 개의 범위 사용시 비효율적인 쿼리 플랜이 된다.
  
- OR 쿼리
  - 현재 몽고 DB는 쿼리당 하나의 인덱스만 사용 가능하다.
  - $or 사용시 각 쿼리 수행 후 결과를 합치므로, $or절 마다 하나씩 인덱스 사용 가능
    - 일반적으로 두 번 쿼리 후 결과 병합은 한 번 쿼리보다 훨씬 비효율적이다. 그러니 가능하면 $or보단, $in을 사용
- db.foo.find({"$or" : [{"x" : 123}, {"y" : 456}]}).explain()
- "$or" -> 두 쿼리 조사 후 중복을 모두 제거 -> 비효율, $in을 사용하자!
  
## 5.1.6 객체 및 배열 인덱싱
- 도큐먼트 내부 내장 필드, 배열 인덱스 생성을 허용한다.
  - 특수한 경우 제외하고 일반적인 인덱스 필드와 같은 방식 동작
  
- 내장 도큐먼트 인덱싱하기
  - 컬렉션에서 도큐먼트가 한 명의 사용자를 나타내고, 도큐먼트 필드에 사용자 위치가 있다고 가정하자.
  ```mongodb-json
  {
    "username" : "sid",
    "loc" : {
        "ip" : "1.2.3.4",
        "city" : "Springfield",
        "state" : "NY"  
    }
  }
  ```
  - db.users.createIndex({"loc.city" : 1})
    - city 이용 쿼리 속도를 높일 수 있다.
  - 내장 도큐먼트 loc 자체를 인덱싱 할 땐, loc.city를 인덱싱 할 때와 매우 다르게 동작한다.
    - 서브 도큐먼트 전체(loc) 인덱싱 할 땐, 서브 도큐먼트 전체 쿼리만 도움 된다.
  
- 배열 인덱싱하기
  - 배열도 인덱싱 가능하다.
  - 특정 요소 효율적 찾기 가능
  - 블로그 게시물 컬렉션이 있고, 하나의 도큐먼트가 하나의 게시물이라고 가정하자.
    - 도큐먼트는 comments 서브 도규먼트들로 구성된 배열이다.
      - 가장 최근 댓글이 달린 블로그 게시물 찾으려면, comments 도큐먼트 내 'date' 키에 인덱싱 한다.
        - db.blog.createIndex({"comments.date" : 1})
          - 배열 인덱싱 시 배열 각 요소에 인덱스 항목을 생성
            - 20개 게시물 -> 20개 인덱스 항목을 갖는다.
              - CUD 작업 -> 모든 배열 요소 갱신 -> 단일 인덱스보다 부담스럽다.
    - 배열 전체를 단일 개체로 인덱싱 불가능
      - 배열 자체가 아니라, 배열 각 요소에 인덱싱
        - 특정 배열 요소 찾는 쿼리 인덱스 사용 불가능
  - 인덱스 {"x" : 1, "y" :1}
    - db.multi.insert({"x" : [1,2,3], "y" : 1}) -> 정상
    - db.multi.insert({"x" : 1, "y" : [4,5,6]}) -> 정상
    - db.multi.insert({"x" : [1,2,3], "y" : [4,5,6]}) -> 비정상
  
- 다중키 인덱스가 미치는 영향
  
## 5.1.7 인덱스 카디널리티
- 컬렉션의 한 필드에 고유값이 얼마나 많은지 나타낸다.
- 일반적으로 카디널리티가 높을수록 인덱싱에 도움된다.
  - 이름, 성별이 있을 경우 이름으로 찾기 전 성별을 통해 50%로 좁힐 수 있다.
  - 인덱스 설계시 높은 카디널리티 키를 앞에 놓자.
  
# 5.2 explain 출력
- 쿼리의 많은 정보 제공
- 느린 쿼리를 위한 중요한 진단 도구
- COLLSCAN 사용시 인덱스를 사용하지 않음을 알 수 있다.
- db.users.find({"age" : 42}).explain("executionStats")
- db.users.find({"age" : {$gt : 10}, "username" : "user2134"}).explain()

# 5.3 인덱스를 생성하지 않는 경우
- 인덱스는 데이터 일부 조회시 가장 효율적이다. 즉 인덱스가 없는 것이 더 빠를 수도 있다.
- 인덱스를 통해 가져올 도큐먼트가 컬렉션에서 많다면 비효율적이다.
  - 인덱스 하나 사용시 두 번 조회가 일어난다.
    1. 인덱스 항목 살피기
    2. 도큐먼트를 가리키는 인덱스 포인트
- 컬렉션의 30% 이상 반환시 인덱스는 점차 비효율적이 된다.
- 인덱스가 적합한 경우
  - 큰 걸렉션
  - 큰 도큐먼트
  - 선택적 쿼리
- 컬렉션 스캔이 적합한 경우
  - 작은 컬렉션
  - 작은 도큐먼트
  - 비선택적 쿼리
- db.entries.find({"created_at" : {"$lt" : hourAgo}})
  - created_at 인덱스 생성시, 점진적으로 쿼리는 느려진다. 
  
# 5.4 인덱스 종류
- 인덱스 구축시 옵션 지정을 통해 동작 방식 변경 가능

## 5.4.1 고유 인덱스
- key 필드의 값으로 중복된 값을 가질 수 없도록 한다.
  - 두 번 저장해도, 첫 번 째 값만 저장된다.
- _id의 인덱스는 삭제 할 수 없다는 점만 제외하면 고유 인덱스다.
- null을 값으로 취급  
  
## 5.4.2 부분 인덱스

# 5.5 인덱스 관리
- createIndex를 통해 인덱스 생성 가능
- 인덱스 정보는 모두 system.indexes 컬렉션에 저장된다.
- db.students.getIndexes()

## 5.5.1 인덱스 식별
- 컬렉션 내 고유 인덱스 식별자가 있다.

## 5.5.2 인덱스 변경























