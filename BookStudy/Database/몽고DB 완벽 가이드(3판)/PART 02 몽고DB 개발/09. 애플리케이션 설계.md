# 서론
APP과 몽고 DB의 효율적인 작동을 위한 설계 방법을 다룬다.  
- 스키마 설계 고려 사항
- 데이터 내장, 참조 방식 중 결정
- 최적화 팁
- 일관성 고려 사항
- 스키마 관리, 마이그레이션 방법
- 몽고 DB가 데이터 스토리지로 적합하지 않은 경우

# 9.1 스키마 설계 고려 사항
스키마 설계는 핵심 요소다.  
가장 좋은 설계 접근 방식은 APP에서 원하는 방식으로 데이터 표현하는 방식이다.  
따라서 스키마 모델링 전, 쿼리 및 데이터 접근 패턴을 이해해야 한다.  
  
- 스키마 설계 주요 고려 사항
  - 제약 사항
    - DB와 HW 제약 사항을 이해해야 한다.
    - 몽고 DB 특성 고려 
      - 도큐먼트 최대 크기 16MB
      - 디스크에서 전체 도큐먼트를 읽고 쓴다.
      - 갱신은 전체 도큐먼트를 다시 쓴다.
      - 원자성 갱신은 도큐먼트 단위 실행
  - 쿼리 및 쓰기의 접근 패턴
    - 쿼리의 실행 시기, 빈도를 알면 가장 일반적인 쿼리 식별 가능 -> 스키마 설계에 필요한 쿼리
    - 쿼리 식별 후 쿼리 수 최소화, 함께 쿼리되는 도큐먼트는 동일 도큐먼트에 저장되도록 설계
    - 동적, 정적 데이터 분리 고려
    - 스키마 설계 우선 순위는 가장 일반적인 쿼리에 지정 -> 결과 최상의 성능을 갖는다.
  - 관계 유형
    - APP 요구사항과 도큐먼트 관계에서 데이터 관련성 고려 후 데이터, 도큐먼트 내장 또는 참조 방법 결정
    - 관계 변경시 갱신 도큐먼트 개수를 알아야 한다.
    - 데이터가 쿼리하기 쉬운 구조인지 고려
  - 카디널리티
    - 도큐먼트와 데이터 관련성 확인 후 관계의 카디널리티 고려 (1:1, 1:N, N:N, ...) 
    - 개별 접근 혹은 상위 개체 컨텍스트에만 접근되는지 고려
    - 해당 데이터 필드 읽기 갱신 비율 고려 (도큐먼트간 데이터 비정규화 여부, 도큐먼트 내장 또는 참조 결정에 도움)
  
## 9.1.1 스키마 설계 패턴
스키마 설계는 APP 성능에 직접적인 영향을 미치기 때문에 중요하다.  
스키마 설계시 발생하는 문제는 보통 '패턴' 또는 '빌딩 블록'으로 해결할 수 있다.  
설계에 하나 이상의 패턴을 사용하면 좋다.  
  
- 스키마 설계 패턴
  - 다형성 패턴
    - 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조일 때 적합
  - 속성 패턴
    - 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우 적합 
  - 버킷 패턴
    - 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합
  - 이상치 패턴
    - 도큐먼트 쿼리가 APP의 정상 패턴을 벗어날 때 사용
  - 계산된 패턴
    - 데이터 자주 계산이 필요할 때 등 
  - 서브셋 패턴
    - 장비 램 용량 초과 작업 셋 있을 때 사용
  - 확장된 참조 패턴
  - 근사 패턴
    - 리소스가 많이 드는 계산 필요하지만, 정확도가 중요하지 않은 상황에서 사용
  - 트리 패턴
    - 쿼리가 많고 계층 구조 데이터가 있을 때 사용
  
# 9.2 정규화 vs. 비정규화
정규화는 컬렉션 간 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업이다.  
비정규화는 모든 데이터를 하나의 도큐먼트에 내장한다. 즉 하나의 쿼리로 모든 데이터를 가져올 수 있다.  
일반적으로 정규화는 '쓰기', 비정규화는 '읽기'를 빠르게 한다. 따라서 적합한 방식을 선택하면 된다.  
  
## 9.2.1 데이터 표현 예제
학생1, 학생2가 수강 중 과목에 대한 정보 저장한다고 가정  
students 컬렉션, classes 컬렉션, studentClasses 컬렉션으로 표현 가능하다. (각 학생은 하나의 도큐먼트)  
studentClasses 컬렉션은 학생과 수강 과목 참조를 포함한다.  
```mongodb-json
db.studentClasses.findOne({"studentId" : id})
{
    "_id" : ObjectId("512512c1d80313123123"),
    "studentId" : ObjectId("51213123aavds332"),
    "classes" : [
        ObjectId("51213124141414aa"),
        ObjectId("51213159299299bb"),
        ObjectId("512131ajj3j33323"),
        ObjectId("512131nnkddkk999")
    ]
}
```
- 일반적으로 데이터를 이런 방식으로 보관하지 않는다.

```mongodb-json
db.studentClasses.findOne({"studentId" : id})
{
    "_id" : ObjectId("512512c1d80313123123"),
    "name" : "John Doe",
    "classes" : [
        ObjectId("51213124141414aa"),
        ObjectId("51213159299299bb"),
        ObjectId("512131ajj3j33323"),
        ObjectId("512131nnkddkk999")
    ]
}
```
```mongodb-json
db.studentClasses.findOne({"studentId" : id})
{
    "_id" : ObjectId("512512c1d80313123123"),
    "name" : "John Doe",
    "classes" : [
        {
            "class" : "Trigonometry",
            "credits" : 3,
            "room" : 204
        },
    ]
}
```
- 읽기를 좀 더 최적화 -> 비정규화
```mongodb-json
db.studentClasses.findOne({"studentId" : id})
{
    "_id" : ObjectId("512512c1d80313123123"),
    "name" : "John Doe",
    "classes" : [
        {
            "_id" : ObjectId("51223123123123aaabbb"),
            "class" : "Trigonometry"
        }
    ]
}
```
- 내장과 참조가 혼합된 확장 참조
  
교과서적인 정규화 사용 사례는 회원과 주소를 별도 컬력션에 저장한다.  
주소지는 변경이 잦지 않은데, 이사를 대비해 모든 읽기를 느리게 만들면 안 된다.  
내장 필드의 내용, 개수가 제한없이 늘어날 여지가 있다면 내장이 아니라 참조돼야 한다.  
  
계정 설정 -> 해당 이용자 도큐먼트에만 관련, 일반적으로 내장  
최근 활동 -> 증가량, 변화량에 따라 다르다. 크기가 고정됐다면(최근 10개) 내장하는 것이 유용하다.  
친구 -> 절대 내장 X  
유저가 생성한 모든 내용 -> 내장하지 않는다.  

## 9.2.2 카디널리티
카디널리티는 컬렉션이 다른 컬렉션을 얼마나 참조하는지 나타내는 개념이다.  
일반적인 관계는 1:1, 1:N, N:M이다.  
- 예시
  - 게시물, 제목 -> 1:1
  - 작성자, 게시물 -> 1:N
  - 게시물, 태그 -> N:M 
    - 1:N 아닌가?
      - 게시물은 여러 태그를 갖고, 태그는 여러 게시물 참조한다. -> 태그를 공통으로 사용하나?
  
몽고 DB 사용시 '다수'라는 개념을 많음과 적음으로 나누면 도움이 된다.  
예를 들면 1:소, 다대소, 일대다 등으로 말이다.  
많고 적음 관계에 따라 무엇을 내장하고, 내장할지 결정에 도움이 된다.  
일반적으로 적음 -> 내장, 많음 -> 참조가 적합하다.  
  
## 9.2.3 친구, 팔로워 그리고 불편한 관계
소셜 그래프 데이터 고려 사항을 다뤄보자.  
다양한 앱들에서 사람, 내용, 팔로워, 친구 등을 연결한다.  
긴밀한 연결을 내장과 참조를 결정하는 것은 까다로울 수 있다.  
  
일반적으로 팔로우, 친구 추가, 찜하는 행위들은 이용자 한명이 다른 사람의 알림을 구독하는 발행-구독 시스템으로 단순화 가능하다.  
- 구독을 구현하는 전형적인 세 가지 방법
  1. 구독자(subscriber) 도큐먼트에 게시자(producer)를 넣는다.
     - 이용자가 관심있는 게시물을 쉽게 모두 찾을 수 있다.
     - 새로운 게시물을 찾으려면, 모든 이용자의 팔로우 필드를 쿼리해야 한다.
  2. 자주 반환되지 않는 자주 변하는 필드는 정규화 -> followers
     - 도큐먼트는 간단한 형태 유지, 팔로워 정보를 얻기 위해선 추가 쿼리 필요
  
**유명인 사용자로 인한 영향에 대처하기**  
내장, 참조 수는 제한된다.  
유명인의 경우 팔로워 저장 도큐먼트가 넘칠 수 있다.  
9.1.1 스키마 설계 패턴에서 '이상치 패턴'을 사용하고 필요에 따라 연속 도큐먼트를 사용해 해결 가능하다.  
  
# 9.3 데이터 조작을 위한 최적화
앱 최적화를 위해 읽기와 쓰기 성능을 분석해 어느 것이 병목 현상을 일으키는지 우선적으로 알아야 한다.  
쓰기 최적화는 보통 인덱스 최소화, 읽기는 올바른 인덱스 사용을 통해 데이터 반환  
빠른 읽기와 쓰기는 스키마 사이에 트레이드 오프가 존재한다.  
어느 것이 중요한지 결정해야 한다.  
  
## 9.3.1 오래된 데이터 제거
데이터 마다 쓰임새 기간이 다르다. 짧은 시간 동안만 필요한 데이터는 시간이 지날수록 저장 공간만 낭비한다.  
- 오래된 데이터 제거 세 가지 방법
  1. 제한 컬렉션
     - 가장 쉽다.
     - 크기 설정 -> 오래된 데이터가 끝으로 밀려난다.
     - 급격히 증가한 트래픽에 취약하다.
  2. TTL 컬렉션
  3. 일정 주기마다 컬렉션 삭제
     - 여러 개 컬렉션 사용
     - 달 기준, 6개월 이후 데이터 삭제
     - 구현이 조금 더 복잡하다.
  
## 9.4 데이터베이스와 컬렉션 구상
도큐먼트 형태 구상 후 저장 위치를 결정해야 한다.  
- 몇 가지 지침 염두
  1. 스키마 유사 도큐먼트는 같은 컬렉션에 보관
  2. 보통 서로 다른 컬렉션에 있는 데이터의 결합을 허용하지 않는다. -> 함께 쿼리, 집계 도큐먼트는 하나의 큰 컬렉션에 넣어야 한다.
     - 다른 컬렉션, 데이터베이스에 있으면 $merge 단계 사용 필요
  3. 컬렉션에서 Lock과 저장을 중요하게 고려해야 한다.
  
구성 요소 중요도에 따라 세 개의 데이터베이스로 나눌 수 있다.
1. logs
2. activities
3. users
  
# 9.5 일관성 관리

# 9.6 스키마 마이그레이션

# 9.7 스키마 관리

# 9.8 몽고 DB를 사용하지 않는 경우
- 다양한 유형 데이터의 다중 조인 작업 -> RDBMS 적합




































