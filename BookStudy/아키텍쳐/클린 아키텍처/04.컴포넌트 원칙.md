SOLID 원칙이 벽과 벽돌을 배치하는 방법을 알려준다면,
컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.
대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

# 12장 컴포넌트
컴포넌트는 배포 단위다.
즉 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.
자바의 경우 jar 파일이 컴포넌트다.

여러 컴포넌트를 서로 링크하여 단일 파일로 생성하거나 
또는 여러 컴포넌트를 서로 묶어 .war 파일과 같은 단일 아카이브로 만들 수 있다.

잘 설계된 컴포넌트는 반드시 독립적으로 배포 가능하고 개발 가능한 능력을 갖춰야 한다.

개발 초창기에는 메모리의 프로그램 위치와 레이아웃을 개발자가 직접 제어했다.
따라서 코드에도 이와 관련된 코드를 명시해야 했다.
라이브러리 코드도 쓰기 위해서는 복붙해서 가져와 직접 코드를 포함시켰다.
메모리 공간에 있어서도 할당된 공간이 넘어서는 경우 앱을 두 개의 주소로 분리하여 동작하게 했다.

해결책은 재배치가 가능한 바이너리였다.
지능적인 로더를 사용하여 재배치 가능 형태의 바이너리를 생성해 컴파일러를 수정하는 것이다.
개발자는 앱 로드 위치와 함수 라이브러리 로드 위치를 로더에게 지시 가능했다.

앱과 함수 공간을 링크 가능하게 하여 링킹 로더가 탄생했다.

링킹 로더는 프로그램을 개별적으로 컴파일, 로드 할 수 있는 단위로 분할 가능했다.
작은 프로그램과 비교적 작은 라이브러리를 링크할 때 대체로 잘 동작했다.

하지만 프로그램이 점점 커지면서 링킹 로더가 너무 느려지는 상황이 오게 됐다.
더욱 이 시절에는 디스크 조차 상당히 느렸다.

마침내 로드와 링킹 두 단계로 분리되었다.
개발자는 링크 과정을 맡고, 링커라는 별도 앱으로 이 작업을 처리했다.
링커는 링크가 완료된 재배치 코드를 만들어 주었고, 덕분이 로더의 로딩 과정이 빨라졌다.

이후 1980년도 이후 프로그램 코드가 수십만 라인을 넘어서는 게 별 일 아닌 상황이 됐다.
자연스럽게 링커에서 지연되는 일이 생기게 되고, 결국 프로그램이 커지면서 링커가 느려지는 상황을 또 맞닥뜨렸다.

1960,70,80년도 모두 프로그래밍이 느려지는 상황을 막기 위해 온갖 노력을 했지만, 
프로그램이 커지면서 자연스럽게 동일한 현상을 다시 막아야하는 상황이 오게 된다.

그러나 디스크가 발전했다. 즉 크기가 작아지고 속도는 빨라졌다.
디스크에 저장된 많은 데이터를 램에 캐싱할 수 있을 정도였다.

즉, 프로그램이 커지면서 링커가 느려져서 다시 한 번 소프트웨어 시스템적인 분리가 필요해졌지만,
하드웨어의 발전으로 링커의 속도가 개선이 됐다.

런타임에 플러그인 형태로 결합 가능한 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.
이렇게 자리 잡는데 50년이 걸렸다. 


```text
느낀점 

소프트웨어는 실제로 작업을 하면서 발생하는 여러 이슈를 점진적으로 발전시켜 오늘날의 소프트웨어가 되었다.
오늘날 개발자는 편리한 개발 환경에서 개발 할 수 있다.
예를 들면 트랜잭션이 무엇인지, 어떤걸 방지하기 위해 사용하는지, 무슨 역할을 하는지 몰라도,
스프링 부트 JPA를 사용한다면 @Transaction 애노테이션을 적용하면 자동으로 트랜잭션 단위로 묶어줘서 사용할 수 있다.
그러면서 개발 속도와 안정성이 늘어났지만, 컴포넌트의 발전 역사, 더 나아가 소프트 웨어의 역사에 대해 알고 있는 것도 중요한 것 같다.
왜 폰 노이만 구조가 나왔고, 나올 수 밖에 없었는지, 과거를 한 번 들여다 보는 것도, 소프트웨어 개발자로서 성장이 될 수 있는 것 같다.
 
또한 소프트웨어의 발전 뿐만 아니라, 하드웨어의 발전을 통해서도 무언가가 해결되는데,
비단 소프트웨어 뿐만 아니라, 개발을 하는 입장에서도 생각을 넓혀 활용 가능한 방식을 고루 아는 것도 중요한 것 같다.
그리고 적합한 기술 스택을 사용하여 서비스를 안전하고 빠르게 배포하는 것이 필요하다고 느끼는 장이었다.

solid 원칙과 component 원칙을 아예 별개로 생각하고 병행하는 것이 아닌 줄 알았다.
솔리드 원칙은 벽돌과 벽, 컴포넌트 원칙을 빌딩과 방이라는 관점에서 두 원칙을 같이 고민해볼 필요가 있을 것 같다.
솔리드 원칙이 더 작은 단위, 컴포넌트 원칙이 더 큰 단위 같다.
솔리드 원칙을 통해 작은 구조로 작은 단위의 아키텍트를 설계하면, 그 기반으로 하나의 방을 설계하고, 이 방이 모여 빌딩이 세워지는 것 같다.
빌딩이라는 컴포넌트는 하나의 작은 배포 단위고, 여러 컴포넌들을 링크하여 파일을 생성하거나, 서로 묶어서 파일을 생성할 수 있다.
중요한 것은 역할과 책임을 세분화하고 명확하게 나누어 성공적인 솔리드 원칙과 컴포넌트를 통해 하나의 작은 배포 단위가 나온다는 것 같다.
큰 흐름을 컴포넌트 원칙을 적용하여 틀을 잡고, 솔리드 원칙 이용해 그 틀의 작은 세부사항들을 알맞게 적용해 나가면 될 것 같다.


```

# 13장 컴포넌트 응집도
```text
느낀점

```


# 14장 컴포넌트 결합
