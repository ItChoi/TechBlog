SOLID 원칙이 벽과 벽돌을 배치하는 방법을 알려준다면,
컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.
대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

# 12장 컴포넌트
컴포넌트는 배포 단위다.
즉 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.
자바의 경우 jar 파일이 컴포넌트다.

여러 컴포넌트를 서로 링크하여 단일 파일로 생성하거나 
또는 여러 컴포넌트를 서로 묶어 .war 파일과 같은 단일 아카이브로 만들 수 있다.

잘 설계된 컴포넌트는 반드시 독립적으로 배포 가능하고 개발 가능한 능력을 갖춰야 한다.

개발 초창기에는 메모리의 프로그램 위치와 레이아웃을 개발자가 직접 제어했다.
따라서 코드에도 이와 관련된 코드를 명시해야 했다.
라이브러리 코드도 쓰기 위해서는 복붙해서 가져와 직접 코드를 포함시켰다.
메모리 공간에 있어서도 할당된 공간이 넘어서는 경우 앱을 두 개의 주소로 분리하여 동작하게 했다.

해결책은 재배치가 가능한 바이너리였다.
지능적인 로더를 사용하여 재배치 가능 형태의 바이너리를 생성해 컴파일러를 수정하는 것이다.
개발자는 앱 로드 위치와 함수 라이브러리 로드 위치를 로더에게 지시 가능했다.

앱과 함수 공간을 링크 가능하게 하여 링킹 로더가 탄생했다.

링킹 로더는 프로그램을 개별적으로 컴파일, 로드 할 수 있는 단위로 분할 가능했다.
작은 프로그램과 비교적 작은 라이브러리를 링크할 때 대체로 잘 동작했다.

하지만 프로그램이 점점 커지면서 링킹 로더가 너무 느려지는 상황이 오게 됐다.
더욱 이 시절에는 디스크 조차 상당히 느렸다.

마침내 로드와 링킹 두 단계로 분리되었다.
개발자는 링크 과정을 맡고, 링커라는 별도 앱으로 이 작업을 처리했다.
링커는 링크가 완료된 재배치 코드를 만들어 주었고, 덕분이 로더의 로딩 과정이 빨라졌다.

이후 1980년도 이후 프로그램 코드가 수십만 라인을 넘어서는 게 별 일 아닌 상황이 됐다.
자연스럽게 링커에서 지연되는 일이 생기게 되고, 결국 프로그램이 커지면서 링커가 느려지는 상황을 또 맞닥뜨렸다.

1960,70,80년도 모두 프로그래밍이 느려지는 상황을 막기 위해 온갖 노력을 했지만, 
프로그램이 커지면서 자연스럽게 동일한 현상을 다시 막아야하는 상황이 오게 된다.

그러나 디스크가 발전했다. 즉 크기가 작아지고 속도는 빨라졌다.
디스크에 저장된 많은 데이터를 램에 캐싱할 수 있을 정도였다.

즉, 프로그램이 커지면서 링커가 느려져서 다시 한 번 소프트웨어 시스템적인 분리가 필요해졌지만,
하드웨어의 발전으로 링커의 속도가 개선이 됐다.

런타임에 플러그인 형태로 결합 가능한 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.
이렇게 자리 잡는데 50년이 걸렸다. 


```text
느낀점 

소프트웨어는 실제로 작업을 하면서 발생하는 여러 이슈를 점진적으로 발전시켜 오늘날의 소프트웨어가 되었다.
오늘날 개발자는 편리한 개발 환경에서 개발 할 수 있다.
예를 들면 트랜잭션이 무엇인지, 어떤걸 방지하기 위해 사용하는지, 무슨 역할을 하는지 몰라도,
스프링 부트 JPA를 사용한다면 @Transaction 애노테이션을 적용하면 자동으로 트랜잭션 단위로 묶어줘서 사용할 수 있다.
그러면서 개발 속도와 안정성이 늘어났지만, 컴포넌트의 발전 역사, 더 나아가 소프트 웨어의 역사에 대해 알고 있는 것도 중요한 것 같다.
왜 폰 노이만 구조가 나왔고, 나올 수 밖에 없었는지, 과거를 한 번 들여다 보는 것도, 소프트웨어 개발자로서 성장이 될 수 있는 것 같다.
 
또한 소프트웨어의 발전 뿐만 아니라, 하드웨어의 발전을 통해서도 무언가가 해결되는데,
비단 소프트웨어 뿐만 아니라, 개발을 하는 입장에서도 생각을 넓혀 활용 가능한 방식을 고루 아는 것도 중요한 것 같다.
그리고 적합한 기술 스택을 사용하여 서비스를 안전하고 빠르게 배포하는 것이 필요하다고 느끼는 장이었다.

solid 원칙과 component 원칙을 아예 별개로 생각하고 병행하는 것이 아닌 줄 알았다.
솔리드 원칙은 벽돌과 벽, 컴포넌트 원칙을 빌딩과 방이라는 관점에서 두 원칙을 같이 고민해볼 필요가 있을 것 같다.
솔리드 원칙이 더 작은 단위, 컴포넌트 원칙이 더 큰 단위 같다.
솔리드 원칙을 통해 작은 구조로 작은 단위의 아키텍트를 설계하면, 그 기반으로 하나의 방을 설계하고, 이 방이 모여 빌딩이 세워지는 것 같다.
빌딩이라는 컴포넌트는 하나의 작은 배포 단위고, 여러 컴포넌들을 링크하여 파일을 생성하거나, 서로 묶어서 파일을 생성할 수 있다.
중요한 것은 역할과 책임을 세분화하고 명확하게 나누어 성공적인 솔리드 원칙과 컴포넌트를 통해 하나의 작은 배포 단위가 나온다는 것 같다.
큰 흐름을 컴포넌트 원칙을 적용하여 틀을 잡고, 솔리드 원칙 이용해 그 틀의 작은 세부사항들을 알맞게 적용해 나가면 될 것 같다.
```

# 13장 컴포넌트 응집도
어떤 클래스를 어떤 컴포넌트에 포함시켜야 할까?
이런 중요한 결정은 제대로된 소프트웨어 원칙의 도움을 받아야 한다.

세 가지 원칙을 논의해보자.
1. REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
2. CCP: 공통 폐쇄 원칙 (Common Closure Principle)
3. CRP: 공통 재사용 원칙 (Common Reuse Principle)

## REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
"재사용 단위는 릴리스 단위와 같다."

지난 십 년, 모듈 관리 도구가 많이 등장했다.
덩달아 이 기간에 재사용 가능한 컴포넌트나 컴포넌트 라이브러리가 많이 등장했다. 

우리는 소프트웨어 재사용의 시대에 살고 있다. -> 객체 지향 오랜 약속 중 하나가 실현
소프트웨어 컴포넌트가 릴리스 절차를 통해 추적, 관리되면 릴리즈 번호가 부여되고, 컴포넌트를 재사용할 수 있다.
Q) 릴리즈 번호를 통해 컴포넌트를 재사용한다는게 무슨말인지 모르겠다.
A) 인텔리제이 IDE update를 통해, 기존 코드는 유지하고 새로 추가된 코드를 가져와서 사용 가능하다는건가? 그리고 가져오는 방식이 하나의 컴포넌트를 가져온다?

릴리즈 번호를 통해 재사용 컴포넌트들이 서로 호환되는지 보증한다.

또한 새로운 버전이 언제 출시되고, 추가, 변경 항목을 개발자들도 인지하기 위해서 릴리스 번호는 필요하다.
따라서 릴리스 절차에 적절한 공지와 문서 작성도 포함돼야 한다.
그래야 새 릴리스로 통합할지, 언제할지를 개발자가 충분한 인지를 할 수 있다.

단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.
즉 상호 독립적인 클래스 또는 모듈들의 집합이다. 
컴포넌트를 구성하는 클래스 또는 모듈등른 공유하는 중요한 테마 또는 목적이 있어야 한다.
추상적인 느낌적인 느낌으로 컴포넌트를 구성하면 안된다.

컴포넌트로 묶였다면 반드시 함께 릴리스 할 수 있어야 한다.
묶인 클래스와 모듈들은 버전 번호가 같아야 하고, 동일 릴리스로 추적 가능해야 한다.

이 원칙을 지키지 않으면 이치에 맞지 않는다. 추상적인 멘트지만, 어기게 되면 쉽게 발견 가능하다. 어길기 그것은 당신의 평가가 매겨진다.
이 원칙의 약점은 CCP, CRP로 보완 가능하다.

## CCP: 공통 폐쇄 원칙 (Common Closure Principle)
동일 이유, 동일 시점 변경 클래스를 같은 컴포넌트로 묶어라.
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해라.

이 원칙은 SRP를 컴포넌트 관점에서 다시 쓴 것이다.
즉 변경의 이유가 여러 개 있어서는 안 된다. 
따라서 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다.

대다수 앱의 유지보수성은 재사용성보다 훨씬 중요하다. (유지보수성 > 재사용성)
Q) 유지보수성과 재사용성은 포람되는 개념이 아닌가? 
A) 요구 사항이 모두가 같지 않은 경우를 말하는듯, 재사용이 가능했지만, 호출 부 몇 곳에서 요구사항이 같지 않은 경우
앱의 코드 변경이 불가피한 경우 여러 컴포넌트에 분산되어 발생하기 보단, 단일 컴포넌트에서 발생하는 편이 낫다.

CCP는 변경될 가능성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다.
물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.
이는 릴리스, 재검증, 배포와 같은 작업량을 최소화 할 수 있다.

이 원칙은 OCP와도 밀접하게 관련있다.
CCP는 동일 유형의 변경에 닫혀 있는 클래스들을 하나의 컴포넌트로 묶는다.
요구사항 변경시 변경이 주는 컴포넌트들이 최소한으로 한정될 가능성을 높인다.


## CRP: 공통 재사용 원칙 (Common Reuse Principle)
"컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라."

CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 도움되는 원칙이다.
같이 재사용되는 클래스 또는 모듈을 같은 컴포넌트에 포함해야 한다.

서로 다른 컴포넌트에서 동일 클래스 또는 모듈을 같이 사용하게 되면, 의존성이 생기게 된다.
따라서 변경시 함께 변경되는 가능성이 높아진다.
변경이 동시에 일어나지 않더라도 전혀 관련없는 컴포넌트의 변경으로 인해 재컴파일, 재검증, 재배포 가능성은 여전히 있다.

CRP는 어떤 클래스를 같이 묶어도 되는 지가 아니라, 묶어서는 안 되는지에 대해 더 많은 것을 야기한다.

CRP는 ISP의 포괄적인 버전이다. "필요하지 않은 것에 의존하지 말라"

응집도에 관한 세 원칙은 서로 상충된다.
REP, COP는 컴포넌트를 더욱 크게 만든다.
CRP는 컴포넌트를 더욱 작게 만든다.
세 원칙의 균형을 이루는 방법을 고민하고 찾아서 적용해야 한다.

컴포넌트 응집도에 대한 균형 다이어그램은 세 원칙간 트레이드 오프를 나타낸다.
변경으로 인한 너무 많은 컴포넌트에 영향을 미치는지, 불필요한 릴리스가 너무 빈번해지는지 고려하여 
컴포넌트를 구성해야한다.

시간이 지나면서 주의를 기울이는 부분도 변할 수 있다.
트레이드 오프를 통해 컴포넌트를 구성했지만, 시간이 지나면서 중점을 둬야하는 부분이 바뀌어 변경을 요할 수 있다.

프로젝트 초기 CCP가 중요하다. 개발 가능성이 중요하기 때문이다.

과거 결합도에 대한 인식은 컴포넌트 원칙 세가지가 의미하는 것 보단 단순했다.

```text
느낀점

솔리드 원칙과 컴포넌트 원칙의 결이 조금 다른 것 같다.
확실히 컴포넌트 원칙이 조금 더 큰 흐름을 제어하는 느낌이고,

솔리드는 코드적인 관점에서 클린 코드를 지향하는 것 처럼 느껴지는 한 편,
컴포넌트 원칙 세가지는 클래스 또는 모듈 간 재빌드, 재사용 등 코드보다 더 큰 것을 포괄하는 느낌이다.

컴포넌트 원칙을 통해 프로젝트 설계부터, 점차 프로젝트가 커지면서 중요도가 바뀌었을 때,
적절한 트레이드 오프를 통해 현재 어떤 것이 더 중요한지를 파악하고 선택해 성공적인 프로젝트를 유지하는게 중요한 것 같다.
```

# 14장 컴포넌트 결합
개발 가능성과 논리적 설계 사이의 균형을 다룬다.
ADP: 의존성 비순환 원칙 , SDP: 안정된 의존성 원칙 , SAP: 안정된 추상화 원칙

## ADP: 의존성 비순환 원칙
"컴포넌트 의존성 그래프에 순환이 있어서는 안 된다."
여러 사람이 개발하는 환경에서 의도치 않게 순환이 되는 경우가 발생해서 동작하지 않는 경우가 생길 수 있다.
이러한 해결 책으루 두 가지 방법이 발전되어 왔다.
1. 주 단위 빌드
2. 의존성 비순환 원칙

5일 중 4일은 서로 신경쓰지 않고 개발을 하며, 마지막 근무 요일에 변경된 코드를 모두 통합하고 시스템을 빌드한다.
하지만 통합이 생각보다 길어져, 기간을 수정하게 되고, 팀의 효율성도 서서히 나빠진다.
빌드 격주로 하자는 의견이 나오게 되고, 빌드 시간이 되면 고통은 다시 돌아온다.

이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리한다.

의존성 그래프 순환이 생기면 어떤 순서로 컴포넌트를 빌드해야 하는지 파악하기 힘들다.

컴포넌트 구조는 하향식으로 설계될 수 없다.

## SDP: 안정된 의존성 원칙
"안정성의 방향으로(더 안정된 쪽애) 의존하라"
설계는 결코 정적일 수 없다. 변경은 불가피하다.
즉 일부는 변동성을 지니도록 설계된다. 그리고 언젠가 변경되리라 예상 가능하게 둔다.

변경 가능성이 있는 컴포넌트와 변경 가능성이 없는 컴포넌트는 의존하면 안된다.
변경이 어려워진다.
그러나 여러 사람이 관리하는 프로젝트는 의도치 않게 의존하게 될 수도 있다.

A가 B,C,D를 의존하는 것과 A,B,C가 각각 D를 의존하는 것은 다르다.
전자는 불안정 컴포넌트, 후자는 안정 컴포넌트다.
직접 컴포넌트를 의존하고 있는 걸 체크해서 안정성을 체크할 수 있다.

그렇다고 모든 컴포넌트가 안정적이어야 되는 것은 아니다.

## SAP: 안정된 추상화 원칙
"컴포넌트는 안정된 정도만큼만 추상화되어야 한다."

고수준 아키텍처, 정책은 자주 변경해서는 안 된다.
따라서 이런 경우 반드시 안정된 컴포넌트에 위치해야 한다.
불안정 컴포넌트에는 변동성이 큰 것을 위치시킨다.

고수준 컴포넌트는 유연성을 잃는다.
그렇다면 컴포넌트가 안정적이면서 변경에 유연하게 만들 수 있을까?
바로 OCP다. 
바로 추상화 클래스를 활용하는 것이다.

안정적인 컴포넌트라면 반드시 인터페이스와 구현체로 구성되어 가존 코드를 건들지 않고, 갈아끼울 수 있어야 한다.

