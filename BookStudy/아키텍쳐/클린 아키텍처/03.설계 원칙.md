아키텍처가 의미 있으려면 좋은 코드도 동반되어야 한다.
코드가 지저분하면, 좋은 아키텍처는 의미가 없어질 수도 있다.
그래서 좋은 코드로 좋은 아키텍처를 정의하는 원칙이 필요한데 바로 SOLID 원칙이다.
SOLID 원칙은 객체지향에서만 적용되는 것은 아니다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만든다.
- '중간 수준' 모듈 수준에서 적용 가능한 범위
1. 변경에 유연하다.
2. 이해하기 쉽다.
3. 재사용 가능한 컴포넌트 기반

잘 설계된 중간 수준의 컴포넌트를 이용해도, 시스템 전체가 엉망이 될 수도 있다. 
따라서 solid 원칙 뿐만 아니라, 책 뒷 부분 고수준의 아키텍처 원칙도 알아둬야 한다.

간단히 solid 원칙 살펴보기
1. SRP: 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다. (?)
2. OCP: 기존 코드의 수정보단, 반드시 새로운 코드를 추가하는 방식으로 시스템 행위 변경 가능하게 설계해야 SW 시스템 쉽게 변경 가능하다.
3. LSP: 상호 대체 가능한 구성요소를 이용해 시스템을 만들기 위해서, 구성 요소는 반드시 서로 치환 가능해야 한다.
4. ISP: 사용하지 않는 것에 의존하지 않아야 한다. (?)
5. DIP: 고수준의 정책을 정의하는 코드는 저수준의 세부사항 코드에 절대 의존해서는 안된다. 대신 저수준이, 고수준에 의존해야 한다.

# 7장 SRP: 단일 책임 원칙
가장 와닿지 않은 원칙이다.
모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉬운데, 헷갈리지 말라.
'단일 모듈은 변경의 이유가 반드시 하나여야만 한다.'

SRP가 말하는 '변경의 이유'는 이용자와 이해관계자를 가리킨다.
다시 해석하면, '하나의 모듈은 반드시 하나의 이용자 또는 이해관계자에 대해서만 책임져야 한다.' (?) 더 이해 안된다.
그러나 이용자와 이해관계자는 두 명 이상일 수도 있다. 따라서 한명의 기준보단 집단으로 바라보아야 한다.

최종 버전은 '하나의 모듈은 반드시 하나의 집단에 대해서만 책임져야 한다.'
모듈? 바로 소스 파일이다. 그러나 일부 언어는 소스 파일을 저장하지 않는다. 
따라서 모듈 = 소스 또는 함수와 데이터 구조로 구성된 응집 결과

SRP 위반 징후를 살펴보자.
1. 우발적 중복
```text
급여 애플리케이션의 Employee 클래스
Employee는 세 가지 메서드를 가진다.
1. calculatePay()
2. reportHours()
3. save()

Employee 클래스는 SRP를 위반한다.
세 가지 메서드가 세 유형의 CFO, CTO, COO을 책임진다.
1. calculatePay()는 회계 팀에 기능 정의 - CFO 보고를 위해 사용
2. reportHours()는 인사 팀에 기능 정의 - COO 보고를 위해 사용
3. save()는 DBA가 기능 정의 - CTO 보고를 위해 사용

세 메서드가 Employee 클래스에 정의되면서, 세 직군이 서로 결합되어 버렸다.
따라서 서로 의존하는 무언가에 영향을 줄 수 있다.
예를 들면 calculatePay, reportHours 메서드를 포함한 A 메서드가 있다고 했을 때, 각 직군에 맞춰 수정이 필요할 때 A 메서드를 찾아 수정하는데,
이 수정으로 인해 사이드이펙트가 발생할 수 있다.
중요한건, 사이드이펙트를 발견하기까지 시간이 걸릴 수 있단 것이다. 
심지어 에러가 나지않고, 원하지 않는 결과물을 이상이 있는지 체크 못하고 사용될 수도 있다.

이는 서로 다른 액터(집단)가 의존하는 코드를 너무 가까이 배치했기 떄문에 발생했다.
SRP는 서로 다른 액터(집단)가 의존하는 코드를 서로 분리하라고 말한다.
```

2. 병합
```text
소스 파일에 다양하고 많은 메서드 포함시 병합이 자주 발생할 수 있다.
특히 메서드가 다양한 액터를 책임지고 포함한다면 발생 가능성이 확실히 더 높아진다.

예를 들어 다른 직군에서 서로 각자의 메서드를 수정하고,
다른 직군의 개발자 두 명이 Employee 클래스를 체크아웃 받은 후 변경사항 적용하면 서로 충돌하여 병합이 필요해진다.

요즘은 병합 도구가 워낙 뛰어나지만, 모든 경우를 해결할 순 없다. 결국 병합에는 항상 위험이 따른다.

결론적으로 서로 다른 액터(집단)을 뒷받침하는 코드는 서로 분리해야 한다.
```

다른 액터(집단)의 메서드를 각각의 클래스를 생성하여 관리하면 된다.
데이터와 메서드를 분리하는 방식이 가장 확실하다.
세 개의 클래스가 만들어지면, 서로의 존재를 몰라야 우연한 중복을 피할 수 있다.

SRP는 메서드와 클래스 수준의 원칙이다.
```text
느낀점
SRP를 기존에 생각했던 개념은 하나의 책임이고, 이는 클래스와 메서드에 하나의 책임을 두는 것으로 생각했다.
즉 메서드를 기능 단위로 하나의 기능적인 책임, 이 공통된 책임이 모인 그룹을 클래스로 이 자체를 하나의 책임이라 생각했는데,

책에서 얘기해준 내용은 비슷하면서도 달랐다.
하나의 집단, 집단이라고 해서 큰 범위가 아닌 Employee를 예로 들었을 때, 서로 다른 직군의 책임을 모두 한 곳에 포함했을 때의 문제점을 살펴보니,
SRP라는 것이 왜 등장했는지 자세히 알게된 것 같다. 
```

# 8장 OCP: 개방-폐쇄 원칙
소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
확장을 위해서 변경이 일어나서도 안된다.

요구사항을 확장하는 데 있어서 소프트웨어의 수정의 범위가 너무 많으면 시스템 설계 아키텍트의 실패다.
OCP는 클래스와 모듈을 설계 할 때 도움을 얻기도 하지만, 아키텍트 컴포넌트 수준에서 OCP 고려시 더 중요한 의미를 갖는다.

요구사항 변경으로 소프트웨어의 이상적인 변경량은 0이다.
서로 다른 목적으로 변경되는 요소의 적절한 분리와(SRP), 요소 사이의 의존성 체계화(DIP)하여 변경량을 최소화한다.
또한 변경이 잦은 것과 변경이 잦지 않은 것의 분리를 통해서 최소화를 시킬 수 있다.

책임이 확실하게 분리되어 있다면, 요구사항 변경 또는 추가로 인해 책임이 할당된 범위에 적재적소의 수정을 일으키면 된다.
강하게 결합되어 있다면, 코드가 지저분해지겠지만, 적절하게 책임에 의해 분할하려고 노력했다면, 변경의 범위는 더 최소화가 될 것이다.

즉, 두 책임 중 요구사항 변경으로 하나의 책임의 수정이 필요할때, 나머지 한 책임은 수정이 일어나지 않도록 해야하고,
또한 새로운 책임이 확장될 때 기존의 코드의 변경없이 확장 가능해야 한다.

A 컴포넌트에서 변경이 일어날 때, B 컴포넌트를 보호하려면 A 컴포넌트가 B 컴포넌트를 의존해야한다.

OCP는 시스템 아키텍처를 떠받치는 원동력 중 하나다.
확장을 쉽게 하고, 변경으로 인한 수정의 범위가 너무 크지 않도록 한다.
따라서 컴포넌트의 분리, 고수준, 저수준의 분리와 의존 관계 등의 계층 구조를 신경써야 한다.

```text
느낀점
SRP, OCP 모두 변경으로 인한 공수의 범위가 크지 않게 하는데서 공통점이 있는 것 같다.
SRP의 경우 클래스, OCP, 컴포넌트간 세분화된 책임에 신경써야 하는 한편, 
OCP는 시스템 구조적으로 변경의 범위를 최소화하는 것 같다.

스프링 프레임워크에서 스프링 빈을 DI 할 때, 사용하는 구현체가 변경돼도 DI한 코드는 변경되지 않는다.
저수준의 구현체가 아닌 고수준의 인터페이스를 의존하고 있기 때문이다.
내가 생각했을 땐 이 다형성의 사례가 OCP를 설명하기 제일 좋은 것 같다.
```

# 9장 LSP: 리스코프 치환 원칙
- LSP 준수 사례
  - Billing
    - License
      - PersonalLicense
      - BusinessLicense

빌링은 라이센스 하위 타입 중 어느 것도 의존하지 않고 있고 있다.
또한 하위 타입은 모드 License로 치환할 수 있다.

- LSP 위반 사례
  - 직사각형
    - 정사각형

직사각형은 높이, 너비가 서로 다르다. 반면 정사각형은 같다.
직사각형을 호출해서 사용하는 입장에선, 직사각형의 높이, 너비라고 혼동할 수 있다.

초창기 LSP는 상속을 사용하도록 간주되었다.
하지만 현대에는 인터페이스와 구현체를 이용하면 더 광범위하게 소프트웨어 설계 원칙에 적용 할 수 있었다.
아키텍처 관점에서 현대 LSP를 이해하는 방법은 원칙을 어겼을 때 시스템 아키텍처에 무슨 일이 일어나는지 관찰하는 것이다.

- LSP 위배 사례
  - 다양한 택시 파견 서비스 통합 앱 개발
    - 고객은 자신에게 가장 빨리 올 수 있는 택시를 찾는다. -> 택시 업체 고려 X
    - 고객은 택시를 결정한다.
    - 택시에게 고객의 위치를 전송한다.

예제의 핵심은 각 업체마다 REST API의 형태를 맞춰야 하고, 업체마다 개발자들이 요청 데이터의 네이밍을 인지하지 않고,
다른 네이밍을 사용하여 받으려고 하는 경우, 에러가 발생하고 실질적인 손해를 끼친다.
LSP를 위반하면 로직상 if 문 등 조건문 등의 코드로 인해 지저분해지고, 안전하지 않은 상황에 노출된다.

또한 개별 업체 A,B 중 A가 B를 인수하고, 독립적으로 유지하되, 회사 시스템을 모두 통합한다면?
-> LSP 위반시 상황이 추가될 때 마다 추가 코드가 계속적으로 붙는다.

LSP는 아키텍처 수준까지 반드시 확장해야만 한다.
치환 가능성이 위배되면 시스템 아키텍처가 오염되어 불필요한 코드가 지속적으로 붙어 생산성 저하 및 인력 투입이 늘어난다.


```text
느낀점
LSP의 개념을 자세하게 이해하는 것 보다, LSP를 어느정도 이해한 후 이 원칙이 위배됐을 때 발생할 이슈 케이스들을 캐치하는 것이 중요한 것 같다.
요구사항 변경 또는 추가 되는 상황마다 기존 코드가 지저분해지거나 지속적으로 조건 들이 붙어야 한다면, LSP를 잘 지키고 있는지 체크하는 것이 필요할 것 같다.

고수준의 인터페이스와 저수준의 구현체들을 갈아 끼울 때, 예를 들면 고수준의 인터페이스에서 전진()이라는 메서드가 다른 구현체를 치환했다고 후진이 되는 상황이 오면 안 된다.
프로그래밍은 회피, 우회, 위배시 제약사항 등의 방식을 잘 이해하고 있는 것이 중요한 것 같다.
```

# 10장 ISP: 인터페이스 분리 원칙
인터페이스의 범위를 너무 크게 잡고 사용시, 이를 사용하는 곳에서 일부만 사용하더라도 이 인터페이스를 사용해야 하고,
사용하지 않는 것의 업데이트 빌드를 통해 덩달아 빌드를 같이 해야하는 상황에 놓일 수 있다.
따라서 하나의 인터페이스에서 필요 이상으로 모든 것을 담으려 하지 않고, 세분화하여 분리하는 것이 필요하다.

ISP와 아키텍처

System S -> Framework F -> Database D 
D의 의존성 추가 또는 변경으로 인해 F는 물론, S까지 재배포 해야 하는 상황이 올 수도 있다.

```text
느낀점
인터페이스를 필요이상으로 너무 크게 만들어버리면,
변경에 대응하기도 어렵다. 
책에서 나온것 처럼 소프트웨어 시스템 설계시에도 아예 관련없는 곳에서도 변경으로 인한 불필요한 재빌드가 일어날 수도 있다.

인터페이스를 대부분 비즈니스 로직을 담당하는 인터페이스와 구현체로 한정지어서 생각을 하곤 했는데,
시스템 설계는 더 막대한 영향을 끼치기 때문에, 인터페이스 설계와 이 인터페이스들끼리 어떻게 협력하고, 구현체를 어떻게 설정할 지
자세하게 고민하고 적용하는 것이 중요한 것 같다.
```

# 11장 DIP: 의존성 역전 원칙
유연성이 극대화된 시스템, 즉 인터페이스에 의존하고, 구현체에 의존하지 않는 시스템이다.

String은 인터페이스가 아닌 구체클래스이다.
스트링을 애써 추상 인터페이스로 만들려는 시도는 현실성이 없다.
스트링 클래스는 매우 안정적이다. 변경되는 일은 거의 없고, 개발자는 염려할 필요 없다.

따라서 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시해도 된다.
변경되지 않는다면, 의존 사실을 이미 알고 있기 때문이다.

주의해야하는 것은 결국 변동성이 큰 구현체이다.
즉 자주 변경될 수 밖에 없는 모듈들이다.

인터페이스 변경시, 구현체들도 덩달아 변경할 가능성이 높다.
구현체가 변경되더라도, 인터페이스는 변경될 필요가 없다.

소프트웨어 설계와 아키텍처 면에서 인터페이스 변동성을 낮추기 위한 노력을 해야한다.
따라서 변동성이 큰 구현체에 의존하지 않고, 인터페이스에 의존해야 한다.
1. 변동성이 큰 구체 클래스를 참조하지 말라 -> 추상 인터페이스 의존
2. 변동성이 큰 구체 클래스로부터 파생하지 말라 -> 
3. 구체 함수를 오버라이드 하지 말라 -> 대체로 구체 함수는 소스 코드 의존성을 필요로 한다.
4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라 

변동성이 큰 구체적인 객체를 생성시 주의해야 한다.
그러나 객체 생성에서 구체 클래스를 삽입하는 코드는 발생하는데,
객체 지향 언어에서 추상 팩토리를 사용하곤 한다.

제어 흐름은 소스 코드 의존성과 정반대 방향으로 곡선으로 가로지른다.
소스 코드 의존성은 제어 흐름과 반대로 역전된다는 뜻이다. (DI)

```text
느낀점
변경이 잦은 것과, 변경이 되지 않는 것을 분리한다.
이 문장이 인터페이스와 구현체도 설명되는 것 같다.

실제로 개발하다보면 무조건 인터페이스를 만드는 것이 좋지 않은 경우도 있다.
책에서 나온 것 처럼 String 클래스는 왜 인터페이스가 아닐까? 
변경이 되지 않고, 값에 대한 염려 없이 신뢰가 보장됐기 떄문이다.
설사 변경을 요하더라도, 예상 가능한 범위에서 안전하게 가능해서가 아닐까 싶다.

따라서 책에서 처럼, 안전성이 보장된 상황에서는 DIP를 무시하고,
구체 클래스 사용 장점이 인터페이스를 사용하면서 장점을 넘어서는 상황에서도 사용해도 될 것 같다.
물론 주관적인 장점이 아니라, 모두가 공감하는 객관적인 장정이어야 한다.  
```