아키텍처가 의미 있으려면 좋은 코드도 동반되어야 한다.
코드가 지저분하면, 좋은 아키텍처는 의미가 없어질 수도 있다.
그래서 좋은 코드로 좋은 아키텍처를 정의하는 원칙이 필요한데 바로 SOLID 원칙이다.
SOLID 원칙은 객체지향에서만 적용되는 것은 아니다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만든다.
- '중간 수준' 모듈 수준에서 적용 가능한 범위
1. 변경에 유연하다.
2. 이해하기 쉽다.
3. 재사용 가능한 컴포넌트 기반

잘 설계된 중간 수준의 컴포넌트를 이용해도, 시스템 전체가 엉망이 될 수도 있다. 
따라서 solid 원칙 뿐만 아니라, 책 뒷 부분 고수준의 아키텍처 원칙도 알아둬야 한다.

간단히 solid 원칙 살펴보기
1. SRP: 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다. (?)
2. OCP: 기존 코드의 수정보단, 반드시 새로운 코드를 추가하는 방식으로 시스템 행위 변경 가능하게 설계해야 SW 시스템 쉽게 변경 가능하다.
3. LSP: 상호 대체 가능한 구성요소를 이용해 시스템을 만들기 위해서, 구성 요소는 반드시 서로 치환 가능해야 한다.
4. ISP: 사용하지 않는 것에 의존하지 않아야 한다. (?)
5. DIP: 고수준의 정책을 정의하는 코드는 저수준의 세부사항 코드에 절대 의존해서는 안된다. 대신 저수준이, 고수준에 의존해야 한다.

# 7장 SRP: 단일 책임 원칙
가장 와닿지 않은 원칙이다.
모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉬운데, 헷갈리지 말라.
'단일 모듈은 변경의 이유가 반드시 하나여야만 한다.'

SRP가 말하는 '변경의 이유'는 이용자와 이해관계자를 가리킨다.
다시 해석하면, '하나의 모듈은 반드시 하나의 이용자 또는 이해관계자에 대해서만 책임져야 한다.' (?) 더 이해 안된다.
그러나 이용자와 이해관계자는 두 명 이상일 수도 있다. 따라서 한명의 기준보단 집단으로 바라보아야 한다.

최종 버전은 '하나의 모듈은 반드시 하나의 집단에 대해서만 책임져야 한다.'
모듈? 바로 소스 파일이다. 그러나 일부 언어는 소스 파일을 저장하지 않는다. 
따라서 모듈 = 소스 또는 함수와 데이터 구조로 구성된 응집 결과

SRP 위반 징후를 살펴보자.
1. 우발적 중복
```text
급여 애플리케이션의 Employee 클래스
Employee는 세 가지 메서드를 가진다.
1. calculatePay()
2. reportHours()
3. save()

Employee 클래스는 SRP를 위반한다.
세 가지 메서드가 세 유형의 CFO, CTO, COO을 책임진다.
1. calculatePay()는 회계 팀에 기능 정의 - CFO 보고를 위해 사용
2. reportHours()는 인사 팀에 기능 정의 - COO 보고를 위해 사용
3. save()는 DBA가 기능 정의 - CTO 보고를 위해 사용

세 메서드가 Employee 클래스에 정의되면서, 세 직군이 서로 결합되어 버렸다.
따라서 서로 의존하는 무언가에 영향을 줄 수 있다.
예를 들면 calculatePay, reportHours 메서드를 포함한 A 메서드가 있다고 했을 때, 각 직군에 맞춰 수정이 필요할 때 A 메서드를 찾아 수정하는데,
이 수정으로 인해 사이드이펙트가 발생할 수 있다.
중요한건, 사이드이펙트를 발견하기까지 시간이 걸릴 수 있단 것이다. 
심지어 에러가 나지않고, 원하지 않는 결과물을 이상이 있는지 체크 못하고 사용될 수도 있다.

이는 서로 다른 액터(집단)가 의존하는 코드를 너무 가까이 배치했기 떄문에 발생했다.
SRP는 서로 다른 액터(집단)가 의존하는 코드를 서로 분리하라고 말한다.
```

2. 병합
```text
소스 파일에 다양하고 많은 메서드 포함시 병합이 자주 발생할 수 있다.
특히 메서드가 다양한 액터를 책임지고 포함한다면 발생 가능성이 확실히 더 높아진다.

예를 들어 다른 직군에서 서로 각자의 메서드를 수정하고,
다른 직군의 개발자 두 명이 Employee 클래스를 체크아웃 받은 후 변경사항 적용하면 서로 충돌하여 병합이 필요해진다.

요즘은 병합 도구가 워낙 뛰어나지만, 모든 경우를 해결할 순 없다. 결국 병합에는 항상 위험이 따른다.

결론적으로 서로 다른 액터(집단)을 뒷받침하는 코드는 서로 분리해야 한다.
```

다른 액터(집단)의 메서드를 각각의 클래스를 생성하여 관리하면 된다.
데이터와 메서드를 분리하는 방식이 가장 확실하다.
세 개의 클래스가 만들어지면, 서로의 존재를 몰라야 우연한 중복을 피할 수 있다.

SRP는 메서드와 클래스 수준의 원칙이다.
```text
느낀점
SRP를 기존에 생각했던 개념은 하나의 책임이고, 이는 클래스와 메서드에 하나의 책임을 두는 것으로 생각했다.
즉 메서드를 기능 단위로 하나의 기능적인 책임, 이 공통된 책임이 모인 그룹을 클래스로 이 자체를 하나의 책임이라 생각했는데,

책에서 얘기해준 내용은 비슷하면서도 달랐다.
하나의 집단, 집단이라고 해서 큰 범위가 아닌 Employee를 예로 들었을 때, 서로 다른 직군의 책임을 모두 한 곳에 포함했을 때의 문제점을 살펴보니,
SRP라는 것이 왜 등장했는지 자세히 알게된 것 같다. 
```

# 8장 OCP: 개방-폐쇄 원칙
소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
확장을 위해서 변경이 일어나서도 안된다.

요구사항을 확장하는 데 있어서 소프트웨어의 수정의 범위가 너무 많으면 시스템 설계 아키텍트의 실패다.
OCP는 클래스와 모듈을 설계 할 때 도움을 얻기도 하지만, 아키텍트 컴포넌트 수준에서 OCP 고려시 더 중요한 의미를 갖는다.

요구사항 변경으로 소프트웨어의 이상적인 변경량은 0이다.
서로 다른 목적으로 변경되는 요소의 적절한 분리와(SRP), 요소 사이의 의존성 체계화(DIP)하여 변경량을 최소화한다.
또한 변경이 잦은 것과 변경이 잦지 않은 것의 분리를 통해서 최소화를 시킬 수 있다.

책임이 확실하게 분리되어 있다면, 요구사항 변경 또는 추가로 인해 책임이 할당된 범위에 적재적소의 수정을 일으키면 된다.
강하게 결합되어 있다면, 코드가 지저분해지겠지만, 적절하게 책임에 의해 분할하려고 노력했다면, 변경의 범위는 더 최소화가 될 것이다.

즉, 두 책임 중 요구사항 변경으로 하나의 책임의 수정이 필요할때, 나머지 한 책임은 수정이 일어나지 않도록 해야하고,
또한 새로운 책임이 확장될 때 기존의 코드의 변경없이 확장 가능해야 한다.

A 컴포넌트에서 변경이 일어날 때, B 컴포넌트를 보호하려면 A 컴포넌트가 B 컴포넌트를 의존해야한다.

OCP는 시스템 아키텍처를 떠받치는 원동력 중 하나다.
확장을 쉽게 하고, 변경으로 인한 수정의 범위가 너무 크지 않도록 한다.
따라서 컴포넌트의 분리, 고수준, 저수준의 분리와 의존 관계 등의 계층 구조를 신경써야 한다.

```text
느낀점
SRP, OCP 모두 변경으로 인한 공수의 범위가 크지 않게 하는데서 공통점이 있는 것 같다.
SRP의 경우 클래스, OCP, 컴포넌트간 세분화된 책임에 신경써야 하는 한편, 
OCP는 시스템 구조적으로 변경의 범위를 최소화하는 것 같다.

스프링 프레임워크에서 스프링 빈을 DI 할 때, 사용하는 구현체가 변경돼도 DI한 코드는 변경되지 않는다.
저수준의 구현체가 아닌 고수준의 인터페이스를 의존하고 있기 때문이다.
내가 생각했을 땐 이 다형성의 사례가 OCP를 설명하기 제일 좋은 것 같다.
```

# 9장 LSP: 리스코프 치환 원칙

```text
느낀점

```

# 10장 ISP: 인터페이스 분리 원칙
```text
느낀점

```

# 11장 DIP: 의존성 역전 원칙
```text
느낀점

```