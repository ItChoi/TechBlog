아키텍처가 의미 있으려면 좋은 코드도 동반되어야 한다.
코드가 지저분하면, 좋은 아키텍처는 의미가 없어질 수도 있다.
그래서 좋은 코드로 좋은 아키텍처를 정의하는 원칙이 필요한데 바로 SOLID 원칙이다.
SOLID 원칙은 객체지향에서만 적용되는 것은 아니다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만든다.
- '중간 수준' 모듈 수준에서 적용 가능한 범위
1. 변경에 유연하다.
2. 이해하기 쉽다.
3. 재사용 가능한 컴포넌트 기반

잘 설계된 중간 수준의 컴포넌트를 이용해도, 시스템 전체가 엉망이 될 수도 있다. 
따라서 solid 원칙 뿐만 아니라, 책 뒷 부분 고수준의 아키텍처 원칙도 알아둬야 한다.

간단히 solid 원칙 살펴보기
1. SRP: 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다. (?)
2. OCP: 기존 코드의 수정보단, 반드시 새로운 코드를 추가하는 방식으로 시스템 행위 변경 가능하게 설계해야 SW 시스템 쉽게 변경 가능하다.
3. LSP: 상호 대체 가능한 구성요소를 이용해 시스템을 만들기 위해서, 구성 요소는 반드시 서로 치환 가능해야 한다.
4. ISP: 사용하지 않는 것에 의존하지 않아야 한다. (?)
5. DIP: 고수준의 정책을 정의하는 코드는 저수준의 세부사항 코드에 절대 의존해서는 안된다. 대신 저수준이, 고수준에 의존해야 한다.

# 7장 SRP: 단일 책임 원칙
가장 와닿지 않은 원칙이다.
모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉬운데, 헷갈리지 말라.
'단일 모듈은 변경의 이유가 반드시 하나여야만 한다.'

SRP가 말하는 '변경의 이유'는 이용자와 이해관계자를 가리킨다.
다시 해석하면, '하나의 모듈은 반드시 하나의 이용자 또는 이해관계자에 대해서만 책임져야 한다.' (?) 더 이해 안된다.
그러나 이용자와 이해관계자는 두 명 이상일 수도 있다. 따라서 한명의 기준보단 집단으로 바라보아야 한다.

최종 버전은 '하나의 모듈은 반드시 하나의 집단에 대해서만 책임져야 한다.'
모듈? 바로 소스 파일이다. 그러나 일부 언어는 소스 파일을 저장하지 않는다. 
따라서 모듈 = 소스 또는 함수와 데이터 구조로 구성된 응집 결과

SRP 위반 징후를 살펴보자.
1. 우발적 중복
```text
급여 애플리케이션의 Employee 클래스
Employee는 세 가지 메서드를 가진다.
1. calculatePay()
2. reportHours()
3. save()

Employee 클래스는 SRP를 위반한다.
세 가지 메서드가 세 유형의 CFO, CTO, COO을 책임진다.
1. calculatePay()는 회계 팀에 기능 정의 - CFO 보고를 위해 사용
2. reportHours()는 인사 팀에 기능 정의 - COO 보고를 위해 사용
3. save()는 DBA가 기능 정의 - CTO 보고를 위해 사용

세 메서드가 Employee 클래스에 정의되면서, 세 직군이 서로 결합되어 버렸다.
따라서 서로 의존하는 무언가에 영향을 줄 수 있다.
예를 들면 calculatePay, reportHours 메서드를 포함한 A 메서드가 있다고 했을 때, 각 직군에 맞춰 수정이 필요할 때 A 메서드를 찾아 수정하는데,
이 수정으로 인해 사이드이펙트가 발생할 수 있다.
중요한건, 사이드이펙트를 발견하기까지 시간이 걸릴 수 있단 것이다. 
심지어 에러가 나지않고, 원하지 않는 결과물을 이상이 있는지 체크 못하고 사용될 수도 있다.

이는 서로 다른 액터(집단)가 의존하는 코드를 너무 가까이 배치했기 떄문에 발생했다.
SRP는 서로 다른 액터(집단)가 의존하는 코드를 서로 분리하라고 말한다.
```

2. 병합
```text
소스 파일에 다양하고 많은 메서드 포함시 병합이 자주 발생할 수 있다.
특히 메서드가 다양한 액터를 책임지고 포함한다면 발생 가능성이 확실히 더 높아진다.

예를 들어 다른 직군에서 서로 각자의 메서드를 수정하고,
다른 직군의 개발자 두 명이 Employee 클래스를 체크아웃 받은 후 변경사항 적용하면 서로 충돌하여 병합이 필요해진다.

요즘은 병합 도구가 워낙 뛰어나지만, 모든 경우를 해결할 순 없다. 결국 병합에는 항상 위험이 따른다.

결론적으로 서로 다른 액터(집단)을 뒷받침하는 코드는 서로 분리해야 한다.
```

다른 액터(집단)의 메서드를 각각의 클래스를 생성하여 관리하면 된다.
데이터와 메서드를 분리하는 방식이 가장 확실하다.
세 개의 클래스가 만들어지면, 서로의 존재를 몰라야 우연한 중복을 피할 수 있다.

SRP는 메서드와 클래스 수준의 원칙이다.
```text
느낀점
SRP를 기존에 생각했던 개념은 하나의 책임이고, 이는 클래스와 메서드에 하나의 책임을 두는 것으로 생각했다.
즉 메서드를 기능 단위로 하나의 기능적인 책임, 이 공통된 책임이 모인 그룹을 클래스로 이 자체를 하나의 책임이라 생각했는데,

책에서 얘기해준 내용은 비슷하면서도 달랐다.
하나의 집단, 집단이라고 해서 큰 범위가 아닌 Employee를 예로 들었을 때, 서로 다른 직군의 책임을 모두 한 곳에 포함했을 때의 문제점을 살펴보니,
SRP라는 것이 왜 등장했는지 자세히 알게된 것 같다. 
```

# 8장 OCP: 개방-폐쇄 원칙
```text
느낀점

```

# 9장 LSP: 리스코프 치환 원칙
```text
느낀점

```

# 10장 ISP: 인터페이스 분리 원칙
```text
느낀점

```

# 11장 DIP: 의존성 역전 원칙
```text
느낀점

```