# 15장 아키텍처란?
소프트웨어 아키텍트는 코드에서 탈피하지 않는다. 
즉 고수준의 정책 등의 문제에만 집중하는 것이 아니다.
아키텍트를 통해 개발팀의 생산성 극대화 방향의 설계 방향을 이끌어준다.

소프트웨어 아키텍처는 시스템 구축의 형태다.
형태는 개발팀의 규모, 컴포넌트간 어떻게 통신하게 할 지에 따라 방식이 달라진다.
그리고 완성된 형태를 통해 SW 시스템이 개발, 배포, 운영, 유지보수를 수월하게 만들어야 한다.

일반적으로 대중들이 시스템 아키텍처를 바라보는 관점은, 시스템을 제대로 동작하도록 만드는데만 있다고 생각 할 수 있다.
물론 시스템이 제대로 동작해야 하며, 이를 최우선 목표로 잡긴 해야하나,
주된 목적은 시스템의 생명주기를 지원한다. 
시스템을 쉽고, 빠르고, 이해하기 쉽게, 비용을 최소화하고, 개발자의 생산성 최대화하는 데 있다.

시스템 아키텍처는 개발팀이 시스템을 쉽게 개발 할 수 있도록 뒷받침해야만 한다.
시스템의 크기, 앞으로의 방향성, 개발자의 규모에 따라 모놀리틱한 방식이 효율적일 수도 있고, 도메인을 분리한 방식이 효율적일 수도 있다.
아키텍트에 대한 정책과 분리가 잘 되어 있다면 오히려 개발 초기에는 이로인한 시간 공수나 제약이 될 수도 있다.

하지만 도메인이 분리되고, 개발자가 많아지고 여러 팀으로 분리된다면,
안정된 인터페이스와 잘 설계된 컴포넌트 단위로 분리되어야 효율성이 늘어난다.

예를 들어 4 팀이 있다고 했을 때, 각 팀 마다 컴포넌트를 가지고 있고 총 네 개의 컴포넌트를 가지고 있다면,
배포, 운영, 유지보수 측면에서 최적일 수 없다.
일정에만 쫓겨서 일하게 된다면 결국 이렇게 된다.

개발 초기부터 배포 전략을 고려하는 경우는 드물다.
개발 관점에서는 편해도 배포 시기가 다가오면 배포가 난해해질 수 있다.
배포 전략을 초기에 결정하는 경우 더 통합된 도구를 사용하여 상호 연결이 수월한 형태로 만들 가능성이 높아진다.

아키텍처는 시스템 운영에 상대적으로 영향을 미치진 않는다.
운영 관점에서 단순히 스케일업을 통해 해결할 수도 있다.
즉 시스템의 아키텍처 비효율을 스케일업으로 해결하는 경우가 허다하다.

운영을 방해하는 아키텍처 비용 < 개발, 배포, 유지보수를 방해하는 아키텍처 비용
비용 관점에서는 후자에 더 기운다.
그렇다고 전자가 중요하지 않다는 것은 아니고 다만 비용 면에서만 그렇다.

보통 SW 시스템에서 유지 보수에 드는 비용이 가장 많다.
그 중 가장 큰 비용은 탐사와 그로 인한 위험부담이다.
즉 신규 개발 또는 오류에 있어서 최선의 선택지와 최적화된 전략을 결정할 때 드는 비용이다.

SW를 소프트하게 유지하기 위해서 가능한 선택 사항을 많이 열어둬야 한다.
여기서 말하는 선택 사항은 세부사항이다.

모든 SW 시스템의 중요한 두 가지는 정책과 세부사항이다.
아키텍트의 목표는 정책을 가장 핵심적인 요소로 식별하고, 
세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 것이다.
- 개발 초기에 데이터베이스를 지정할 필요 없다. 즉 no sql, rdbms, 등 고수준의 정책과 관련이 없도록 만들어야 한다.
- 개발 초기에 웹 서버를 지정할 필요 없다. 고수준의 정책은 웹을 통해 전달된다는 사실도 알아서는 안 된다.
- 개발 초기에 REST를 적용할 필요 없다. 고수준의 정책은 외부 인터페이스에 대해 독립적이어야 한다.
- 개발 초기에 DI 프레임워크를 적용할 필요 없다. 고수준 정책은 의존성을 해석하는 방식에 대해 신경 써서는 안 된다.

즉 세부사항과 관련 없이, 그리고 고수준의 정책은 세부사항을 알지 못하도록 한다면,
세부사항에 대한 결정은 선택 사항을 오래 열어둘 수 있다.
"좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다."

```text
느낀점 & 정리

시스템 아키텍처는 단지 아키텍처가 잘 동작하다록만 구성하는 사람이 아니다.
이와 비슷한 사례로, 나는 DBA면, 쿼리 튜닝, 모델링, 등 모든 것들을 다 DBA가 관여하는 줄 알았다.
하지만 DBA 내에서도 분리되어 튜닝을 담당하는 사람, 모델링을 담당하는 사람이 나뉜다고 얘기를 들었을 때,
개발자로서 DB라는 영역을 생각하는 것과 DBA로서 영역의 범위가 역시 다르구나 새삼 깨달았었다.
이번 장에서도 마찬가지로 시스템 아키텍처는 아키텍처를 잘 구성하는 것도 중요하지만,
개발자의 생산선, 유지보수, 비용 최소화를 위해서도 노력한다는 것을 인지하게 됐다.

그리고 고수준의 정책 등 과 저수준의 세부사항을 봤을 때, 
고수준이 저수준을 알지 못하게 하고, 저수준의 선택 사항을 독립적으로 두어 선택 사항을 열어두는 것이 좋다.
시스팀 아키텍트 관점에서 나온 내용이지만, 개발적인 관점에서도 비슷한 내용이 많아 어느정도 공감하면서 읽게 됐다.

또한 비효율적인 설계로 인한 아키텍트가 구성됐을 때, 비용적인 면에서 상대적으로 덜 중요하다고 볼 수 있지만,
이건 단지 비용에 불과하다. 
설계가 비효율이라면, 개발 등의 작업도 효율일 가능성은 크지 않은 것 같다.
아무리 스케일업을 통한 해결이 된다고 한들, 아키텍트 관점에서 또는 개발 관점에서 현재 시스템이 비효율적인지 아닌지 판단하는 역량과 공부가 필요할 것 같다.
```

# 16장 독립성
좋은 아키텍처가 지원해야 하는 중요한 네 가지
1. 시스템의 유스케이스
2. 시스템의 운영
3. 시스템의 개발
4. 시스템의 배포

## 유스케이스
시스템의 의도를 반드시 지원해야 한다.
실제 아키텍트의 최우선 관심사는 유스케이스이다
하지만 아키텍트는 시스템 행위에 큰 영향을 주지 않는다.
그러나 행위를 명확히 외부에 드러내어 시스템의 의도를 아키텍처 수준에서 인지할 수 있게 해야 한다.

## 운영
더 실질적이며 피상적인 역할을 맡는다.
시스템이 초당 많은 고객의 수를 처리한다면, 이러한 요구사항에 맞춰 처리량과 응답시간을 보장해야한다.
시스템적으로 빅데이터 테이블 질의가 필요시에도 적절한 아키텍처 구조화가 필요하다.
이런 형태를 지원하기 위해 다양한 방식이 존재한다.
- 시스템 처리 요소를 작은 서비스들로 배열 병렬 실행
- 수많은 스레드가 단일 프로세스에서 같은 주소 공간 공유

이러한 선택사항들은 열어두어야 한다.
모놀리틱 방식은 프로젝트가 점차 커짐에 따라 구조 변경이 필요해질 때 개선하기 어려울 수 있다.
반대로 적절히 컴포넌트를 격리하고 분리하고 컴포넌트간 통신 방식을 제한하지 않는다면 변경에 훨씬 수월하다.

## 개발
개발 환경 지원에 있어 핵심적인 역할을 한다.
콘웨이의 법칙 작용 지점이 바로 개발 영역이다.
콘웨이의 법칙: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

조직 내 많은 개발 팀이 존재한다면 각 팀마다 개발을 방해 받지 않는 아키텍처를 확보해야만 하고, 
아키텍처는 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다.
그래야지 컴포넌트를 독립적 작업 가능 팀에 할당된다.

## 배포
배포 용이성 결정에 중요한 역할을 한다.
즉각적은 배포를 위해 좋은 아키텍처는 시스템 빌드 후 즉각 배포 가능하도록 지원해야 한다.
이를 위해 적절한 컴포넌트 분리와 격리가 필요하다.
---

컴포넌트간 균형을 조정하고 유지하기는 매우 어렵다.
대부분의 경우 모든 유스케이스를 알 수 없고, 모든 정책과 인력의 배치 배포 요구사항 등 다 알 수가 없기 때문이다.
우리의 목표는 언제나 변한다.
목표는 변하지만, 변하지 않는 것을 잘 유지하고 체계를 잡아야 한다.
그 중 하나가 선택 사항을 열어두도록 구조를 잘 잡는 것이다.

중복이 진짜 중복인지 체크하는 것도 필요하다.
향후 서로 다른 이유로 다른 변경이 일어나면 이는 가짜 중복이다.

```text
느낀점 & 정리

이번 장은 특히 내용들이 어렵게 다가 왔다.
핵심적인 내용은 저수준의 선택 사항을 열어두고, 전체적인 시스템의 구조를 완벽하게 할 순 없다. 현재 시점에서 완벽할지라도 프로그래밍은 변한다.
따라서 변경에 대응할 수 있는 구조가 좋다. 
예를 들어 초기 개발이 모놀리틱으로 구조가 가장 합리적이고 최고라고 판단되어 구축하더라도 향후 컴포넌트간 분리 등 구조를 변경함에 있어서 
많은 에러 사항이 발생하면 안된다.
물론 여러 사람이 근무하는 조건에서 이러한 구조를 모두가 지켜낼 순 없다.
확실히 까다롭지만, 코더보다 고민하는 개발자가 필요한 이유가 이런 이유들에서 인 것 같다.
구조와 행위에 고민을 곁들인다면, 그래도 상대적으로 변경에 대응하기 구조와 행위가 나올 거라고 개인적으로 예상한다.
```

# 17장 경계: 선 긋기
SW 아키텍처는 선을 긋는 기술이다.
이러한 선을 저자는 "경계"라고 부른다.
경계를 통해 컴포넌트가 양방향으로 인지하지 못하게 한다.
선을 긋는 시점은 매우 다양하다.
그러나 로직을 오염시키지 않는 목적을 갖고 있다.

아키텍트는 인적 자원을 최소화하는 것을 잊지말자.
비용을 낮추고, 생산성을 향상시키는 것이야 말로 아키텍트의 주요 목표다.

인적 자원의 효율을 떨어뜨리는 요인은 바로 결합이다.
특히 너무 일찍 결정된 결합이다.
1. 시스템의 업무 요구사항
   - 유스케이스와 아무 관련 없는 결정
2. 프레임워크
3. 데이터베이스
4. 웹 서버
5. 유틸리티 라이브러리
6. 의존성 주입
7. 등등등

좋은 아키텍처란 위의 항목들을 부수적이다. 선택 사항을 열어두고, 의존하면 안 된다.
경계를 너무 일찍 정의하면, 프로젝트가 커지거나 환경이 변했을 때, 결합도에 따라 생산성과 인력의 비효율을 경험할 수 있다.

그러면 컴포넌트간 경계를 언제 어떻게 할까?
관련이 있는 것과 없는 것 사이에 선을 긋는다.

우리는 시스템의 행위를 대상의 행위적 측면에서 생각하는 경향이 있다.
예를 들면 GUI를 시스템으로 생각하면 안 된다.
입력과 출력은 중요하지 않다.
입력과 출력이 주어지지 않아도 모델은 모든 이벤트를 모델링하고 주어진 역햘을 충실한다.
중요한 것은 업무 규칙이다.
ex) business rule -> databaseInterface <- database
ex) business rule <- gui
    - GUI는 얼마든지 다른 인터페이스로 교체 가능하고 business rule은 전혀 개의치 않다.
    - service -> jpa interface도 마찬가지인가?
    - gui는 업무 규칙과 다른 시점에 다른 속도로 변경되므로, 경계가 필요하다.

수많은 인터페이스를 플러그인 형태로 사용하게 해야 한다.
SW 아키텍처에서 경계를 긋기 위해선 우선 시스템을 핵심 업무 규칙의 컴포넌트 단위로 분할해야 한다.

```text
느낀점 & 정리 

계속 같은 컴포넌트간 분리를 주제로 내용이 이루어지는 것을 보면,
시스템의 핵심 업무 컴포넌트의 분리와 변하는 것과 변하지 않는 것의 분리, 그리고 다른 시점 다른 속도로 변하는 것에 대한 경계를 명확히 긋는 것이 중요한 내용인 것 같다.

조금은 큰 흐름의 내용으로 내용이 구성되어, 구체적인 감은 잡히지 않았지만, 이는 내용 + 경험을 통해 메꿔질 것이라고 생각된다.
시스템은 유동적인 상황, 환경에 완벽할 수 없다. 일시적인 완벽은 있을 지라도, 언젠간 다시 요구사항과 적절한 변경으로 일시적인 완벽을 유지하는데 노력을 해야되는 것 같다.
그러기 위해서는 앞서 말한 분리, 선 긋기 등의 내용을 항상 고려해야되는 것 같다.
```

# 18장 경계 해부학
시스템 아키텍처는 소프트웨어 컴포넌트와 각 컴포넌트의 분리하는 경계에 의해 정의되고 그 형태는 다양하다.

컴포넌트간 경계를 횡단하는 비결은 소스 코드 의존성 관리에 있다.
즉, 관련없는 컴포넌트에 의해 같이 변경해야 되거나 재 컴파일을 통해 새로 배포해야될 수도 있다.

아키텍처의 흔한 형태 중 하나는 물리적 경계가 엄격하지 않은 형태다.
단일 프로세서에서 같은 주소를 공유하고 나람의 규칙에 따라 분리되어 있다.
이를 소스 수준 분리 모드라고 한다.
배포 관점에서 보면 단일 실행 파일에 불과하지 않기 때문에, 경계가 드러나지 않는다.
소스 수준 분리모드도 경계가 존재하지 않거나 무의미한 것은 아니다.
그 안에 포함된 다양한 컴포넌트와 별도의 독립적 수행을 가능하게 할 수 있다. 
이러한 형태는 대부분 동적 다형성에 의존하여 내부 의존성을 관리한다.
오히려 객체지향에 다형성이 없었다면, 물리적 경계 분리를 시도했을 수 있다.

아키텍트의 결합도를 분리하기 위해서는 어느정도 위험요소가 있었고, 그로 인해 분리 시도를 포기하게 되고, 
더불어 다형성이라는 특성도 있었기 때문에, 단일체가 나온 것 같다.

가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.

전자)
고수준 클라이언트 -> 저수준 서비스 호출은 동적 다형성 사용으로 IoC 할 수 있다.
이런 경우 고수준에서 저수준을 알아야 한다.

후자)
그러나 고수준의 영역에 클라이언트, 서비스, 요청 데이터를 두고 저수준의 영역에 서비스Impl을 두는 경우,
고수준은 저수준을 몰라도 되고, 저수준에서 고수준의 객체를 구현하여 사용 할 수 있다.
Q) MVC를 예로 들면, 컨트롤러, 서비스까지를 고수준으로 봐야하나?

후자처럼 정적 링크된 모놀리틱 구조는 아무리 단일체라고 할지라도 개발, 테스트, 배포에 큰 도움을 준다.
이로 인해 팀간 작업의 충돌이 잦아지고 저수준의 세부사항은 독립적으로 유지된다.
Q) 회사에서 특정 인원들은 Controller 안에서 Query의 정렬 형태를 정의 했는데, 이는 저수준이 고수준을 침범한 경우라고 봐도 되려나?

단일체의 컴포넌트간 통신은 단순히 내부 함수를 호출하면 되기에 매우 빠르고 비용이 저렴하다.
즉, 단일체에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.
Q) 단순 호출이 가능해짐으로써 오히려 경계간 함수롤 너무 빈번하게 호출하여 소스 코드의 오염을 일으킬 수 있는 것 같다.
단일체의 배포는 보통 컴파일과 정적 링크 작업의 형태로 시스템에 전달된다.

배포형 컴포넌트
아키텍처의 경계는 동적 링크 라이브러리를 통해 물리적으로 드러날 수 있다. 
컴포넌트간 이러한 형태는 배포시 따로 컴파일 없이 곧장 사용 가능하지만,
컴포넌트는 바이너리와 같이 배포 가능한 형태로 전달된다.
이는 배포 수준 결합 분리모드에 해당한다.
배포는 단순히 배포 가능 단위를 편리한 형태로 묶는 일에 지나지 않는다.
ex) WAR 파일 또는 디렉토리 형태로 묶는다.

즉 배포 과정에서 차이가 있지만, 배포 수준은 단일체와 동일하다.
보통 모든 함수는 동일한 프로세서와 주소 공간에 위치, 컴포넌트 분리 또는 컴포넌트간 의존성 관리 전략도 동일하다.

단일체와 배포형 컴포넌트는 경계간 통신은 순전히 함수 호출에 지나지 않고 매우 비용이 저렴하다.
후자는 동적 링크와 런타임 로딩으로 인해 최초 함수 호출은 지연될 수 있지만 마찬가지로 경계간 통신이 매우 빈번할 것이다.
Q) 배포형 컴포넌트는 물리적 경계를 통해 경계간 통신이 단일체보다 훨씬 잦을 줄 알았는데, 오해하고 읽었나보다.

스레드는 아키텍처 경계, 배포 단위 둘 다 아니다.
실행 계획과 순서의 쳬게화하는 방법에 가깝다.
모든 스레드가 단 하나의 컴포넌트에 포함될 수 있고, 분산될 수도 있다.

로컬 프로세스를 통해 강한 물리적 형태를 띠는 아키텍처 경계를 할 수 있다.
보통 메모리 보호를 통해 프로세스간 공유하지 못한다.
보통 로컬 프로세스는 소켓, 메일박스, 메시지 큐 등과 같이 OS 레벨에서 제공하는 통신 기능을 이용하여 서로 통신한다.
로컬 프로세스는 정적 링크의 단일체, 동적 링크의 여러 컴포넌트로 구성 가능하다.

전자의 경우 모놀리틱 프로세스가 같은 컴포넌트들을 가지고 있다.
즉 컴파일하고 정적 링크하는 과정에서 각 컴포넌트의 바이너리가 단일체에 물리적 복사되어 들어간다.

후자의 경우 동적 링크된 배포형 컴포넌트들을 서로 공유할 수 있다. 

로컬 프로세스는 일종의 최상위 컴포넌트라고 생각하자.
컴포넌트간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
소스코드 의존성의 한 방향으로 경계를 횡단한다. 즉 항상 고수준 컴포넌트를 향한다.
따라서 고수준 소스 코드 영역에 저수준의 정보를 절대 포함하면 안 된다.

저수준 프로세스는 플러그인 형태로 고수준의 선택해 사용된다고 생각하자. 

로컬 프로세스 경계를 지나는 통신은 운영체제 호출, 데이터 마샬랑 및 언마샬링, 프로세스 간 문맥 교환 등이 있다.
즉 비싼 비용의 통신이기에 너무 빈번한 호출이 일어나면 안 되고 신중히 제한해야 한다.

물리적인 형태를 띠는 가장 강력한 경계는 서비스다.
MVC의 ItemService가 아니고, 프로세스다.
서비스는 물리적 위치에 제한받지 않는다.
서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수도 있고, 아닐 수도 있다.
서비스간 모든 통신은 네트워크를 통한다고 가정한다.
따라서 빈번한 호출을 자제해야 하는데, 이 수준의 통신은 지연에 따른 문제를 고수준에서 처리할 수 있어야 한다.
마찬가지로 저수준 서비스는 반드시 고수준 서비스에게 플러그인 형태로 제공되야 하고,
고수준 서비스에서 저수준 서비스을 단정짓는 물리적인 정보 (url, ...)을 절대 포함해선 안 된다.


```text
느낀점 & 정리

컴포넌트간, 서비스간 컴포넌트의 경계의 형태는 다양하다.
다양한 형태에서도 유지되어야 하는 것은 고수준은 저수준을 알아서는 안 된다.
즉 저수준은 플러그인 형태로 고수준에게 제공되어야 하고, 고수준에서는 저수준을 특정할 정보를 가지고 있어서는 안 된다.

그리고 단일체 구조의 정적 링크된 프로젝트와 컴포넌트간 분리로 인해 동적 컴파일되는 프로젝트의 형태는
배포 수준은 동일하지만 배포 과정이 다르다.
단일체의 경우 단일 실행 파일로 컴파일과 정적 링크가 되어 있고(?)
복수 컴포넌트의 경우 바이너리와 같은 묶기 편한 구조로 변한되어 있다. (?) (ex: WAR, 디렉토리 구조)  

컴포넌트의 단일체의 경우 모놀리틱 구조를 통해 규모가 커지고 팀원이 많아지면 무조건 혼란을 유발할 수 있다고 생각 할 수 있지만,
모놀리틱 내부에서도 컴포넌트간 분리를 어떻게 하고, 어떠한 형태로 결합 했는지, 즉 고수준 저수준의 개념이 적합하게 적용됐는지에 따라,
배포와 개발 그리고 리팩토링을 위해서 더 수월할 수 있다.

그리고 서비스간 통신은 내부 함수 호출보다 비용이 비싸다.
당연하게 의미없는 빈번한 호출을 신중히 해야 한다.
```

# 19장 정책과 수준
SW 시스템은 정책을 기술한 것이다.
즉 SW 프로그램은 각 입력을 출력으로 변환해주는 정책을 상세하게 기술한 설명서다.
여기서 출력은 무조건 사용자에게 노출될 필요는 없다.

주요 시스템에서의 정책은 세부 정책으로 나뉘고 다시 세부 정책으로 나뉠 수 있다.
ex) 통계 규칙 처리 방식의 세부 정책, 특정 보고서의 포맷 정의 방식의 세부 정책, 입력 데이터 검증 처리 방식의 세부 정책, ...

따라서 SW 아키텍처 개발은 이러한 정책들을 명확하게 분리하고, 정책 변경으로 인한 정책, 정책 간의 재편성을 포함한다.
또한 컴포넌트들을 비순환 방향 그래프로 유지시키고, 구성하는 일을 모두 포함한다. (정점은 동일 수준 정책 컴포넌트, 간선은 다른 수준의 컴포넌트간 의존성 연결)
이러한 의존성은 소스 코드, 컴파일 타임의 의존성이다. ex) 자바의 경우 import문
다시 언급하지만 중요한 점은 저수준 컴포넌트가 고수준 컴포넌트에 의존하게 해야 한다. 즉 저수준은 플러그인 형식으로 존재해야 한다.

정책들 간의 동일 이유와 시점으로 인한 변경은 동일 수준에 위치하고 반대의 경우 다른 수준, 또는 다른 컴포넌트로 분리해야 한다.

수준(level)은 엄밀히 정의하자면 입력, 출력과의 거리이다.
수준이 I/O와 멀리 위치할수록 정책의 수준은 높아진다.
I/O를 다루는 정책은 최하위 수준에 위치한다. 

소스 코드 의존성은 수준에 따라 결합되어야 한다. 절대 데이터 흐름을 기준으로 결합하면 안 된다.
예를 들면 고 수준의 암호화는 저수준의 읽기, 쓰기를 포함하면 안 된다.
즉 암호화는 읽기, 쓰기의 구현체를 가지고 있는 것이 아니라 인터페이스를 가지고 있어야 한다. 
암호화와 I/O 인터페이스는 동일 수준의 정책은 아니고, 암호화가 최상위 수준이다.

고수준을 저수준으로 매핑하여 쓰기 위해서는 고수준 하위 위치에 고수준과 저수준을 논리적으로 연결해주는 역할이 필요한 것 같다.
입력과 출력의 방식이나 정책이 바뀌어도, 암호화는 지장이 가지 않는다.

```text
느낀점 & 정리 

정책을 고수준, 저수준으로 나누는 것은 거대한 정책과 그 세부 정책을 실제로 나눠보면서 고민해봐야 조금 더 공감이 될 것 같다.
단순하고 짧은 예제로는 이해가 가지만, 과연 방대한 실무의 세계에서도 이러한 내용을 적용할 수 있을지는 테스트 또는 경험을 해봐야 할 것 같다.

"소스 코드의 의존성은 수준에 따라 결합되어야지, 데이터 흐름을 기준으로 하면 안 된다." 무척 공감이 되고, 
실무에서 오해를 불러 일으켜 의존성이 꼬이면 리팩토링 공수가 많아지는 것 같다.
데이터 흐름의 기준으로 생각하면서도 아니라고 착각 할 수도 있는데, 이러한 점을 구별 할 수 있는 역량을 더욱 키워야 할 것 같다.
```
--- 

# 20장 업무 규칙
애플리케이션의 '업무 규칙', '플러그인' 두 가지로 구분 하기 위해서는 업무 규칙이 무엇인지 잘 이해해야 한다.
업무 규칙은 소프트웨어랑 별개로 수익 향상 또는 비용 절감이다.
예를 들면 은행의 '이자'라는 개념이 돈을 버는 핵심 업무 규칙이다.
이자 계산은 컴퓨터로 하든, 사람이 직접 하든 하등의 관계가 없다.

핵심 업무 규칙은 사업 자체의 핵심이자, 자동화가 되어 있지 않더라도 그대로 존재한다.
또한 보통 데이터를 요구한다. 앞에 은행의 예는 '이자'라는 개념을 위해 대출 잔액, 이자율, 지급일정 등의 핵심 업무 데이터가 필요하다.
즉 핵심 업무 규칙에는 핵심 업무 데이터가 필요하고, 본질적으로 결합되어 있다.
이러한 유형의 객체를 엔티티라고 한다.

엔티티는 객체다. 핵심 업무 데이터를 기반으로 동작하고 핵심 업무 규칙을 구체화한다.
엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.

업무의 핵심 개념 구현 SW와 구축 중인 자동화 시스템의 고려사항들과 분리시킨다.

결론적으로 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어 별도 SW 모듈로 구성해야 한다.

유스케이스는 시스템이 사용자에게 어떻게 보이는지 설명하진 않는다.
더 특화된 규칙과 사용자와 엔티티간의 상호작용을 규정한다.

유스케이스도 객체다. 앱에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공하고,
입력, 출력 데이터와 상호작용하는 엔티티에 대한 참조 데이터 등을 포함한다.

고수준의 엔티티는 저수준의 유스케이스를 알지 못한다. 
유스케이스는 단일 앱에 특화되어 있다는 점과 I/O에 가깝기 때문에 저수준에 속한다.
엔티티는 다양한 앱에서 사용될 수 있고 I/O와 거리가 멀다.

유스케이스의 내부 동작을 눈치챌 수 없어야 한다. 
단순히 I/O로서의 역할을 하는 것 뿐이다.
즉 어떤 사용자 인터페이스에도 종속되지 않는다.

이처럼 의존성 제거하는 일은 중요하다.
I/O로서의 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도, 간접적으로 결합된다.

업무 규칙은 사용자 인터페이스나 데이터베이스 등의 저수준 관심사로 인해 오염되면 안 되고, 원본을 유지해야 한다.
업무 규칙 담당 코드는 SW 심장부에 위치하며, 저수준의 코드는 플러그인 형태가 되어야 한다.
이를 통해 업무 규칙은 시스템 내에 가장 독립적이고 재사용 가능한 코드여야 한다.

```text
느낀점 & 정리

핵심 업무 규칙은 소프트 웨어와 별개로, 자동화가 되어 있지 않아도 그대로 유지된다.
이를 통해 수익 향상과 비용 절감을 하게 되고, SW 코드의 가장 중요한 심장부에 위치하며, 
독립적이고도 재사용이 가능한 형태를 유지해야 한다.
절대로 저수준의 플러그인 형태를 결합하여 오염시키면 안 된다.
```
---

# 21장 소리치는 아키텍처
아키텍트의 구성이, 시스템이 의도한 바로 소리치고 있는가? 예를 들면 도서 관리 시스템같은...
아니면 스프링, 하이버네이트야라고 소리치는가?

SW 앱의 아키텍처는 앱의 유스케이스에 대해 소리쳐야 한다.
아키텍처는 프레임워크나 구현 기술에 대한 것이 아니다. 그래서는 절대 안 된다.
아키텍처를 프레임워크로부터 제공받아서는 절대 안 된다.
도구로만 이용하자. 아키텍처가 준수해야 되는 사항이 아니다.
이를 지키지 않으면 아키텍처는 스프링 프레임워크라고 소리친다.

좋은 아키텍처는 유스케이스를 중심에 두고 기술한다. 이때 기술 도구의 도움을 받지 않는다.
예를 들어 집에 대한 아키텍처를 구성할 때, 거주하기 적합한 공간임을 나타내는 것이지,
벽돌로 지어지는지 나무로 지어지는지를 체크하는 것이 아니다. 이는 유스케이스를 확실히 충족시킨 이후에 생각할거리다.
프레임워크, 데이터베이스는 열어둬야 할 선택사항이다. 

웹은 아키텍처인가?
아니다. 웹은 전달 메커니즘(I/O 장치)에 불과하다.
웹을 통해 전달되기에 웹은 세부사항이고, 시스템 구조를 지배하면 안 된다.
시스템 아키텍트의 별개로 생각하자. 절대로 데이터 흐름으로 생각하면 안 된다.

프레임워크는 매우 강력하고 유용한 것은 사실이다. 
따라서 매우 신뢰하며 강한 주장이 생길 수도 있다. 
프레임워크로 모든 것은 하게 하는 것은 절대 소프트웨어 아키텍트 관점에서 좋은 태도가 아니다.
그리고 그 강한 주장으로, 특정 프레임워크, 기술에 너무나도 의존되어버린 것이 나오게 되면 안된다.
그렇다면 시스템 아키텍트는 유스케이스가 아닌, 프레임워크라고 소리친다.

유스케이스를 최우선으로 하고 프레임워크와 거리를 둔다면 테스트하기 쉬운 아키텍트를 만들 수 있어야 한다.
세부 사항과 커넥션이 되어야 테스트가 가능해서는 안 된다.

아키텍트는 시스템이다. 프레임워크를 포함해서 얘기하면 안 된다.

```text
느낀점 & 정리

웹 안에 여러 부서가 있고, 그 부서에는 개발자가 있고 개발자는 다시 백엔드, 프론트, 등으로 나뉜다.
자연스럽게 시스템 개발에도 웹을 상위 포지션으로 보고 어떤 프레임워크, 도구를 사용할지 고민을 먼저 할 것 같았으나,
이번 장을 통해 명확히 분리해야된다는 것을 알게 됐다.

고수준, 저수준의 분리와 저수준은 고수준의 플러그인 형태로 존재하며 고수준은 저수준을 알아차려서는 안 된다.
이 논리가 소픞트웨어의 많은 영역에 적용되는 것 같다.
```
---

# 22장 클린 아키텍처
지난 수십년간 아키텍처 관련 아이디어는 제시됐다.
1. 육각형 아키텍처 (Hexagonal Architechture)
2. DCI (Data, Context and Interaction)
3. BCE (Boundary-Control-Entity)
4. 등등등

위에 예시로 든 아키텍처는 모두 세부적인 면에서 다소 차이가 있지만, 내용은 상당히 비슷하다.
SW를 계층으로 분리함으로써 관심사의 분리 목표를 달성할 수 있다.
즉 아키텍처는 최소한 업무 규칙을 위한 계층과 사용자와 시스템의 인터페이스를 위한 계층을 각각 이상을 포함한다.

시스템이 다음과 같은 특징을 지니도록 만든다.
1. 프레임워크가 지닌 제약사항 안으로 시스템을 강제하지 않는다.
2. 외부 요소 없이 테스트 가능하다.
3. UI 독립성을 통해 쉽게 변경 가능하다.
4. DBMS는 선택샇아으로 열어두어 결합되지 않는다.
5. 고수준, 저수준의 분리로 고수준은 저수준을 알지 못한다.

- p.215 그림 22.1 클린 아키텍처 그림 참고

엔티티
전사적인 핵심 업무 규칙을 캡슐화한다.
메서드를 포함한 객체 또는 데이터 구조와 함수의 집합일 수도 있다.
다양한 앱에서 재사용 가능하다면 엔티티의 형태는 중요하지 않다.

엔티티가 전사적이지 않고 단순히 단일 앱을 작성하고 있따면, 업무 객체가 된다.
가장 일반적이며 고수준인 규칙을 캡슐화한다.
외부의 변경으로 엔티티가 같이 변경될 가능성은 지극히 낮고, 영향을 주면 안 된다.

유스케이스
유스케이스 계층의 소프트 웨어는 앱에 특화된 업무 규칙을 포함한다. 
엔티티로 들어오고, 나가는 데이터 흐름 조정하고 엔티티는 자신의 핵심 업무 규칙을 통해 유스케이스 목적을 달성하도록 이끈다.
유스케이스의 변경이 엔티티의 변경에 영햐을 주면 안 된다.

인터페이스와 어댑터

프레임워크와 드라이버
모든 세부사항이 위치하는 곳이다.
웹, 데이터베이스는 세부사항이다. 외부에 위치시켜 피해를 최소화하자.

원은 네개여야만 하나?
ex) 그림22.1 예제상 가장 안 쪽부터, 엔티티 - 유스케이스 - 컨트롤러, 게이트웨이, 프레젠터 - 웹, 장치, DB, 외부 인터페이스, UI
규칙에 따라 개수는 다르다.
하지만 의존성 규칙은 유지해야 한다.
안쪽에 위치할수록 정책 수준은 높다. 

경계 횡단하기
제어 흐름과 의존성 방향이 명백히 반대인 경우 보통 의존성 역전 원칙을 사용해 해결한다.
예를 들어 자바는 인터페이스와 상속을 통해 적절히 배치하여 소스 코드 의존성을 제어 흐름과 반대로 만들 수 있다.

```text
느낀점 & 정리

```
---

# 23장 프레젠터와 험블 객체
프레젠터는 험블 객체 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움된다.
클린 아키텍처는 많은 험블 객체 구현들로 되어 있다.

**험블 객체 패턴**
디자인 패턴으로, 테스트 난이도에 따라 단위 테스트 작성자가 분리하기 쉽게하는 방법으로 고안됐다.
테스트 행위들을 두 개의 모듈 또는 클래스로 나눈다. 이 중 하나가 험블이다. 어려운 난이도를 험블 객체로 옮긴다.

예를 들어 GUI 경우 단위 테스트가 어렵다.
테스트 입장에서 각 요소가 적재적소에 배치 됐는지 알기 어렵다. 또한 위치 변동 가능성도 고려 해야 된다.
험블 객체를 통해 두 부류 행위를 분리하고, '프레젠터'와 '뷰'를 만들 수 있다.

**프레젠터와 뷰**
뷰는 험블객체로, 테스트 난이도가 높기 때문에 가능한한 간단한 코드로 유지한다.
뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이다. 다른 역할은 없다.

프레젠터는 테스트하기 쉬운 객체다.
데이터를 받아 화면에 표시될 포맷으로 만든다.
이를 통해 험블객체는 간단한 일만 처리되도록 한다.

ex) 앱에 특정 필드 날짜 표시가 필요한 경우
1. 앱은 프레젠터에 Date 객체 전달
2. 프레젠터는 데이터를 적절한 포맷의 문자열로 만든다.
3. 문자열을 뷰 모델 데이터 구조에 담는다.
4. 뷰는 뷰 모델에서 데이터를 찾아 사용한다.

**테스트와 아키텍처**
테스트 용이성은 좋은 아키텍처라면 필수다.

**데이터베이스 게이트웨이**
p.226 참고

**데이터 매퍼**
ORM: 오브젝트 관계 매퍼 (Object Relational Mapper)
ORM은 어느 계층에 속하는가?
분명한 점은 ORM은 사실 존재하지 않는다.
사람 관점에서 객체는 데이터 구조가 아니다.
따라서 객체는 단순히 오퍼레이션의 집합이다.

데이터 구조는 함축된 행위를 갖지 않고, public 접근제어자만 갖는다.
ORM 보단, Data Mapper가 더 적합하다.
RDBMS의 데이터를 데이터 구조에 맞게 바인딩한다.

그렇다면 ORM은 어디에 위치해야 하는가?
당근 데이터베이스 계층이다.

**서비스 리스너**
p.227 참고

아키텍처는 경계마다 험블 객체

# 24장 부분적 경계
아키텍처 경계를 완벽히 구분하는 것은 많은 비용이 든다.
쌍방향의 다형적 인터페이스, I/O 데이터 구조, 독립적 컴파일, 배포 등 
격리시 필요한 모든 의존성을 관리해야 한다.
더불어 유지 비용도 들게 된다.

뛰어난 아키텍트는 경계 비용이 너무 크다고 판단돼면, 미래를 위해 경계를 위한 필요 공간 확보를 원할 수 있다.
애자일 커뮤니티에서 이러한 선행적 설계를 탐탁치 않아 할 수 있다.
YAGNI 원칙(You Aren't Going To Need It)을 위배한다.
하지만 어쩌면 필요할 수도... 라는 의문이 든다면 부분적 경계를 구현해보자. (완벽 경계가 아니라, 부분적 경계)

**마지막 단계를 건너뛰기**
부분적 경계를 만들 때도 많은 코드량과 사전 설계가 필요하다.
하지만 다수 컴포넌트 관리가 배제된다.
관리, 버전 번호 추적, 배포 관리 부담 등 결코 가벼운 차이는 아니다.

시간이 지나도 컴포넌트가 재사용될 가능성이 없다는게 보장이되거나 결과론적으로 그렇게 된다면, 분리 작업은 따분한 일이다.
그러나 우리는 결과를 알 수 없고, 변경에 대한 수월한 대응을 위해서 부분적 경계도 중요하다.

**일차원 경계**
완벽한 형태의 아키텍처 경계는 양방향 격리 상태 유지를 해야한다. 동일한 조건으로 양방향이 아니라, 
한 쪽은 인터페이스를 활용한다. 이는 비용이 많이 든다.
- controller
  - service (I)
    - serviceImpl

controller와 serviceImpl 격리시 필요한 의존성 역전이 적용되어 있다.
쌍방향 인터페이스가 없고, 근면 성실한 개발자가 아닌 경우 비밀 통로가 생기는 것은 막지 못한다.

**퍼사드**
단순한 경계는 퍼사드 패턴이다.
심지어 의존성 역전까지도 희생한다.

경계는 퍼사드 클래스로만 간단 정의
- 퍼사드 클래스를 통해 모든 서비스 클래스를 메서드 형태로 정의 
- 호출시 해당 서비스 클래스 호출 전달
- 클라이언트는 서비스 클래스에 직접 접근 불가
- 하지만 클라이언트가 모든 서비스 클래스에 추이 종속성을 갖는다.
- 정적 언어일 경우, 서비스 하나라도 변경되는 경우 재컴파일 필요


더 다양한 경계 전략들이 존재한다.
각 장단점이 있고, 적절한 경계법을 판단해 적용하면 된다.

```text
느낀점 & 정리

요즘 시대에 경계는 더 중요하다.
어플리케이션이 이미 커질대로 커졌지만, 더 많은 요구사항과 기술들이 생겨나며 경계에 대한 중요성은 날이 갈 수록 중요해질 거라고 생각한다.
작은 규모의 프로젝트의 경우 모놀리틱한 방식으로 적은 개발자를 통해 관리하는게 효율적일 수도 있지만, 이것 마저도 미래는 모른다.

웹 환경 뿐만 아니라, 벤치마킹 시대에서 비 IT적인 이유로도 컴포넌트간 경계는 중요한 것 같다.
완벽한 경계에는 초기 비용, 유지 비용 모두 많이 들기 때문에, 자기가 속한 팀에 적합한 경계법을 잘 찾아 적용하는 것이 중요한 것 같다.
모놀리틱한 방식으로 구조를 잡더라도, 그 안에서의 경계도 중요하다.
```
---

# 25장 계층과 경계
시스템은 생각 이상으로 다양한 컴포넌트를 사용하면서, 사용하는 컴포넌트 생각보다 개수는 훨씬 많다.

**움퍼스 사냥 게임**
게임 UI와 게임 규칙을 분리하면, UI를 재사용해 어떤 언어로든 개발 가능하다.

**클린 아키텍처?**

**흐름 횡단하기**

**흐름 분리하기**

```text
느낀점 & 정리

이번 챕터는 예제롤 기반으로 얘기하는 것 같다.
결국에는 경계는 어디에든 존재할 수 있고, 경계가 언제 필요한지를 정확히 인지하는 것이 중요하다.
경계를 미리 하지 않고, 필요할 때 즉시하게 되는 경우 비용은 더 커질 수 있다.
한편, 경계를 미리 예측해 적용한 오버 엔지니어링이 언더 엔지니어링보다 안 좋을 때가 훨씬 많다.
이것이 추상화가 필요하리라고 미리 예측하며 안된다는 YAGNI가 말하는 철학이다.
```
---

# 26장 메인(Main) 컴포넌트
모든 시스템에는 최소 하나의 컴포넌트가 존재하고 이를 메인 컴포넌트라 한다.
메인 컴포넌트에서 나머지 세부 컴포넌트로 분리하면서 컴포넌트를 생성, 조정, 관리한다.

**궁극적인 세부사항**
- 메인 컴포넌트
  - 궁극적인 세부사항
  - 가장 낮은 수준의 정책
  - 시스템 초기 진입점
  - OS만 메인에 의존한다.
  - 시스템 전반을 담당하는 나머지 기반 설비 생성 후 더 높은 수준 담당에게 제어권을 넘긴다.
  - DI를 바로 메인 컴포넌트에서 한다.
  - 클린 아키텍처 가장 바깥 원에 위치하는 저수준 모듈이다.
    - 고수준을 위한 모든 것을 로드하고, 제어권을 고수준에게 넘긴다.

메인은 애플리케이션의 플러그인이라고 생각하면 된다.

```text
느낀점 & 정리

예전에 우테코프로에서 초기에 준 과제에서 유사한 고민을 한 적 있다.
웹 서버를 두지 않고, 콘솔 창에 입 출력을 남기는 과제였는데,

그때 당시 고민으로는 메인에 객체의 행위 범위를 얼만큼 둘 것인가에 대한 고민을 했었다.
이 챕터에서도 비슷하게, 그떄의 고민에 대한 답을 내려준 것 같다.
메인은 단순히 컴포넌트지만, 소프트웨어적으로 유사한 상황에서는 이 내용과 동일하게 가도 될 것 같다.
즉, 메인은 단순희 고수준 모듈을 위한 시스템 로드에 필요한 값을 세팅하고, 
실제 행위가 이루어지는 고수준을 호출함으로써 제어권을 넘기면 된다.

확실히 여러 경험이 쌓이고, 지식을 습득해야 비교대상과 생각의 범위가 넓어져 체득하기 좋은 것 같다.
더 다양한 경험을 만들려고 노력해야겠다고 느끼는 장이었다.
```
---

# 27장 '크고 작은 모든' 서비스들
서비스 지향 아키텍처와 마이크로서비스 아키텍처는 아래와 같은 이유로 큰 인기를 끌고 있다.
1. 서비스간 상호 결합이 철저히 분리된 것으로 보인다. 일부 맞는 말이다.
2. 개발과 배포 독립성 지원하는 것으로 보인다. 일부 맞는 말이다.

**서비스 아키텍처?**
서비스를 사용한다는 것이 아키텍처를 사용한다는 것은 아니다.
시스템 아키텍처란 의존성 규칙을 준수하고, 고수준 정책과 저수준 세부사항을 분리하는 경계에 의해 정의된다.

단순히 앱의 행위를 분리하는 서비스라면, 아키텍처 관점에서 중요하게 보진 않는다.
모든 서비스가 아키텍처 관점에서 중요해야 하는 것은 아니다.
그러나 서비스 자체로 아키텍처를 정의한다고 볼 수 없다.
Q) 경계에 대한 규칙과 정의 차이?

**서비스의 이점?**

**결합 분리의 오류**
시스템을 서비스 단위로 분리하면서 서비스간 사이의 결합이 확실히 분리된다.
서비스는 서로 다른 프로세스에서 실행되므로 서비스간 직접적인 변수 호출을 할 수 없다.
따라서 모든 서비스의 인터페이스는 반드시 잘 정의되어야 한다.

하지만 위에 내용은 꼭 그렇지 않을 수 있다.
프로세서 또는 네트워크 상의 공유 자원으로 인한 결합 가능성이 여전히 존재한다.
따라서 공유 데이터로 인한 서비스간 강력한 결합도가 생길 수 있다.

서비스간 인터페이스를 잘 정의해야 되는 것도 맞지만, 
함수 인터페이스도 마찬가지로 잘 정의되어야 한다.

**개발 및 배포 독립성의 오류**
서비스 분리는 전담 팀이 각자의 서비스를 소유하고 운영하면서 책임질 수 있다.
또한 확장 가능한 것으로 간주 된다.

어느정도 일리가 있지만, 대규모 프로젝트는 SOA 뿐만 아니라, 모노리틱, 컴포넌트 기반으로도 가능은 하다.
SOA가 유일한 선택지는 아니다.
또한 서비스간 분리를 했다고 해서 항상 독립적인 개발, 운영이 가능한 것은 아니다.
데이터나 행위에서 결합도를 세밀히 따져보고, 결합 정도에 맞게 개발, 배포, 운영을 조정해야 한다.

**야옹이 문제**
ex) 택시 통합 시스템
시스템(1)-(N)도시(1)-(N)택시 업체 연관 관계로 되어 있고, 
고객은 택시의 세부 정보를 확인 후 특정 택시에 승차 요청 할 수 있다.
그리고 MSA로 구축한다고 가정해보자.
서비스간 팀을 분리하여 개발, 유지보수, 운영 책임을 세분화 했다.

택시 UI 서비스: 고객 담당, 모바일을 통해 택시 호출
택시 찾기 서비스: 택시 공급 현황 검토 후 이용자에게 적절한 택시 후보 선별토록 제공, 이용자 모바일 기기에 할당된 단기 데이터 레코드에 택시 정보 저장
택시 선택 서비스: 이용자가 택시를 지정 
택시 Dispatcher 서비스: 이용자가 지정한 택시를 전달 받아서 해당 택시 배차 지시

위에 네 가지 서비스로 분리하여 개발, 운영, 유지 보수를 진행했다.
그리고 도시에 야옹이 배달 서비스 추가 계획이 생기게 된다.
이용자는 자신의 지정한 주소지로 야옹이를 배달 주문 할 수 있다.

회사는 도시 전역에 야옹이가 탈 승차 지점 설정 및 근처 택시 선택, 올바른 주소지로 배달을 해야 한다.
택시 업체 중 일부만 이 서비스에 참여한다.
운전자는 고양이 알러지가 있을 수 있고, 이 운전자를 배제해야 한다.
또한 택시 승객이 알러지가 있는 경우, 야옹이 배달 차량은 3일간 배차 불가다.

이 서비스를 구현하려면 기존의 택시 통합 시스템의 어디를 변경해야될까?
이 서비스는 기존의 모든 서비스에 모두 결합되어 있어서 독립적으로 할 수 없다.
이게 바로 횡단 관심사가 지닌 문제다.
모든 서비스는 SOA를 떠나 직면하는 문제다.

**객체가 구출하다**
컴포넌트 기반 아키텍처를 통해 이 문제를 해결한다면, 
SOLID 설계 원칙 중 다형적 확장 가능 클래스 집합을 생성해 확장에 열려 있게 할 수 있다.
경계, 의존성 규칙 준수에 주목해야 한다.

배차 특화 로직을 라이더 컴포넌트로 추출하고, 
야옹이에 대한 신규 기능은 고양이 컴포넌트로 추출했다.
두 컴포넌트는 템플릿 메서드나 전략 패턴 등을 이용해 오버라이드 한다.
(p.257 그림 27.2 참조)

택시 UI 서비스의 변경을 어쩔 수 없다.
하지만 그 외의 것들의 변경이 필요 없다.
이를 통해 야옹이 기능은 결합 분리, 독립적 개발 배포가 가능해진다.

**컴포넌트 기반 서비스**
서비스 분리만으로도 문제를 해결 할 수 있다.
서비스도 마찬가지로 SOLID 설계 원칙을 지킬 수 있고, 컴포넌트 구조도 갖출 수 있다.
이를 통해 기존 컴포넌트의 변경 없이 확장 가능하다.

서비스 내부를 자신만의 컴포넌트로 설계하고, 적절한 컴포넌트 내부에 파생클래스 또는 확장하여 문제를 해결 할 수 있다.

**횡단 관심사**
아키텍처 경계는 서비스간에 존재하는 것이 아니다.
모든 주요 시스템이 직면하는 문제인 횡단 관심사 처리를 위해 서비스 내부를 의존성 규칙 준수 컴포넌트 아키텍처로 설계해야 한다.
즉 서비스를 작은 단위의 컴포넌트로 분리하고, 컴포넌트간 의존성을 준수해야 한다.
서비스 내에 위치한 컴포넌트에서 아키텍처 경계를 정의한다.

**결론**
서비스는 시스템의 확장에서 중요하다.
하지만 그 자체로 아키텍처에 중요하진 않다.

서비스는 단 하나의 아키텍처 경계를 갖는 단일 컴포넌트 일 수도 있다.
아니면 아키텍처 경계로 분리된 분산 컴포넌트일 수도 있다.

```text
느낀점 & 정리

실무에서는 다양한 요구사항과 변경사항이 있다.
거의 신입일 땐, 요구사항에 대해 "이 시스템에 적용해도 되나?" 라는 의문을 가졌던 빈도가 높았던 것 같다.
시니어로 다가가면서 요구사항이나 변경사항에 대응 할 수 있는 시스템적 아키텍처와 분리를 통해 
어떠한 요구사항에도 대응 가능하도록 하는 것이 중요하다고 느꼈다.
즉 기획을 의심해서는 안 된다. 
앞선 장에도 나왔듯이 개발팀은 협업 부서에 개발 관점의 입장을 이해시킬 의무를 가졌고,
기획이 나왔다면, 합리적인 변경을 통해 요구사항을 만족시켜야 한다.
개발팀은 이용자의 요구사항 뿐만 아니라, 내부적인 사용자의 요구사항도 만족시켜야 한다.

서적에 나왔듯이 요구사항으로 인한 변경은 어쩔수 없다.
그러나 그 변경의 범위를 어느 정도로 만들 것인지는 
시스템의 아키텍처, 즉 서비스의 적절한 인터페이스 분리, 컴포넌트 간의 경계를 어떻게 구분하는지에 따라 달라지는 것 같다.
```
---

# 28장 테스트 경계
테스트는 시스템의 일부이자, 아키텍처에 관여한다.

**시스템 컴포넌트인 테스트**
테스트에 포함된 내용은 상당한 혼란이 있다.
테스트의 종류는? 단위, 통합, 인수, 기능, tdd, bdd, 컴포넌트 테스트는 무엇이고 어떻게 하는가?
하지만 아키텍처 관점에서 모든 테스트는 동일하다. 즉 모두 동등하다.

테스트는 태생적으로 의존성 규칙을 따르고, 세부적이고 구체적이다.

**테스트를 고려한 설계**
테스트가 시스템 설계와 잘 통합되지 않으면 테스트는 깨지기 쉽고, 시스템은 변경이 어려워진다.
시스템에 강하게 결합된 테스트는 시스템 변경시 함꼐 변겅되어야 한다.
즉 아주 사소한 변경도 수많은 테스트를 꺠뜨릴 수 있다.
꺠지기 쉬운 테스트가 개발을 망설이게도 할 수 있다.
페이지 변경 요구 사항으로 변경해야 되는 테스트가 천 개라면, 망설여진다.

이 문제를 해결하려면 테스트를 고려해서 설계해야 한다.
소프트 웨어 설계는 변동성 있는 것에 의존하지 않아야 한다.
GUI는 변동성이 크기 때문에, 테스트 설계시 업무 규칙을 테스트 해야 한다.

**테스트 API**
시스템을 테스트 가능한 특정 상태로 강제해야 한다.
이 테스트 API는 보안 제약 사항 무시 할 수 있고 값 비싼 자원을 스킵해야 한다.
앱의 구조로부터 테스트를 분리하는 것이 목표다.

**구조적 결합**
테스트 결합 중 가장 강하고 은밀한 유형이다.
메서드 중 하나라도 변경되면 다수의 테스트가 변경되어야 한다.
결과적으로 깨지기 쉽고 상용 코드는 뻗뻗해진다.

테스트 API 역할은 테스트 내부에 애플리케이션 구조를 숨기는 것이다.
따라서 테스트를 리팩토링하거나 고도화 해도 상용 코드에는 영향을 주지 않는다.

독립적으로 테스트 하는 것은 필수적이다.
테스트는 변하고 테스트 성질과는 반대로 상용 코드 역시 변한다.
테스트 코드와 결합도가 강하면 상용 코드는 범용성과 유연성을 충분히 만족할 수 없다.

**보안**
테스트 API 자체와 상용 코드와 밀접한 결합도를 가진 부분을 독립적으로 배포 가능한 컴포넌트로 분리해야한다.

**결론**
테스트는 시스템의 일부다.
시스템 설계와 마찬가지로 테스트도 잘 설계되어야 한다.
잘 설계되지 않은 테스트는 깨지기 쉽고 유지보수 어려울 수 있다.

```text
느낀점 & 정리

스프링 부트를 사용하면서 rest docs를 사용하고 있는데, 간단히 api 테스트를 하면서도 일부 객체를 수정하면서,
많은 테스트 코드가 꺠지는 경험을 한 적 있다.
더 세부적으로 테스트가 들어간다면, 이런 빈도는 잦고 난이도는 더 어려울 것 같다는 생각이 든다.
테스트에 대한 설계를 잘 해야겠다는 생각을 해 본 적은 없는데, 
이 챕터를 통해 테스트의 구현과 테스트를 잘 설계하고, 꺠지기 쉽지 않은 테스트를 유연하게 유지하는 것도 중요하다는 것을 깨달았다.
TODO: 테스트 서적 및 활용 필요
```
---

# 29장 클린 임베디드 아키텍처
"SW는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 SW도 수정해야 한다."
하드웨어는 발전하고 개선될수록 낡아가고, SW는 새로운 기능이 추가되면서 더욱 복잡해진다.
즉 SW는 닳지 않지만, 하드웨어와 의존성을 관리하지 않으면 안으로부터 파괴될 것이다.
(서적 참조)

**앱-티튜드 테스트**
켄트백은 SW를 구축하는 세 가지 활동을 기술했다.
1. "먼저 동작하게 만들어라" SW가 동작하지 않는다면 사업할 수 없다.
2. "그리고 올바르게 만들어라" 리팩토링을 통해 가독성과 요구 사항에 잘 대응하고 개선할 수 있게 만들어야 한다.
3. "그리고 빠르게 만들어라" 요구되는 성능을 만족시켜야 한다.

앱이 동작하도록 만드는 것을 서적에서 앱-티튜드 테스트라 부른다.
(서적 참조)

**타깃-하드웨어 병목현상**
임베디드 개발자들은 제한딘 메모리 공간, 실시간성 제약, 처리 완료 시간, 제한된 입출력, 사용자 인터페이스, 센서와 실제의 상호작용 등을 경험한다.
(서적 참조)

**클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다**

**계층**

**하드웨어는 세부사항이다**

**HAL 사용자에게 하드웨어 세부사항을 드러내지 말라**

**프로세서는 세부사항이다**

**운영체제는 세부사항이다**

**인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라**

**DRY 원칙: 조건부 컴파일 지시자를 반복하지 말라**

**결론**

(서적 참조)