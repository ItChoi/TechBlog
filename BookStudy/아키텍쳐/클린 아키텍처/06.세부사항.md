# 30장 데이터베이스는 세부사항이다
SOLID 원칙이 벽과 벽돌을 배치하는 방법을 알려준다면,
컴포넌트 원칙은 빌딩에 방을 배치하는 벽
DB의 역할은 방과 방 사이를 연결하는 문 손잡이다.

데이터베이스는 데이터 모델이 아니라 일개 SW일뿐이다.
즉 데이터 접근 방법을 제공하는 유틸리티다.
아키텍처 관점에서 DB는 저수준 세부사항일 뿐이다.
뛰어난 아키텍트는 저수준이 시스템 아키텍처를 오염시키지 않게 한다.

**관계형 데이터베이스**
관계형 데이터베이스가 정의되고 계속적으로 인기를 끌었다.
하지만 아키텍처 관점에서 그저 기술일뿐이다. 즉 저수준의 세부사항이다.
데이터를 어떻게 조회하고, 얼마만큼의 성능으로 가져올지는 아키텍처적으로는 중요하지 않다.
애플리케이션의 유스케이스는 이러한 방식을 알면 안되고 관여해서도 안된다.

많은 프레임워크가 테이블과 행이 객체 형태로 시스템 여기 저기 돌아다니게 허용하는데, 아키텍처적으로 잘못된 설계다.
이렇게 된다면, 관계형 데이터 구조에 결합되어 버린다.

**데이터베이스 시스템은 왜 이렇게 널리 사용되는가?**
한마디로 "디스크" 덕분이다.
지난 반세기 동안 회전식 자기 디스크는 데이터 저장소의 중심에 있었다.
다른 형태의 저장소가 있다는 사실 조차도 모를 정도였다.

디스크는 계속 발전해 지름 3인치의 단 몇 그램짜리 얇은 단일 원판으로 1TB 이상 저장 가능하다.
디스크는 느리다는 치명적 단점이 있다.
데이터는 원형 트랙에 저장되고, 트랙은 섹터로 분할되고, 각 섹터는 사용하기 편한 크기의 바이트를 저장하는데 대체로 4K였다.
각 플래터는 대략 수백 개의 트랙으로 구성되었고, 디스크는 십 여 개의 플래터로 구성되었다.
즉, 디스크(1) - (n)플래터(1) - (n)트랙(1) - (n)섹터 - 바이트(대략 4k)로 구성된다.

- 디스크에서 특정 바이트 읽기
  - 모든 작업은 밀리초 단위의 시간이 걸린다.
  1. head를 적절한 트랙으로 옮긴다.
  2. 디스크가 회전하면서 헤드 위치에 적적한 섹터가 올 때 까지 기다린다.
  3. 해당 섹터에서 4k 모두 램으로 읽어들인다.
  4. 해당 램 버퍼의 색인을 찾아 필요 바이트를 가져온다

데이터 저장소가 디스크가 아니라면, 밀리초가 아니라 나노초 수준으로 접근 가능하다.
따라서 디스크의 단점을 완화하기 위해 색인, 캐시, 쿼리 계획 최적화, 데이터 표현 표준 방식이 필요했다.
성능과 작업 대상을 알 수 있어야 했기 때문이다.
즉 데이터 접근 및 관리 시스템이 필요했다.
이는 두 가지 유형으로 나왔다.
1. 파일 시스템
   - 문서 기반
   - 내용 기준 검색은 부적합
     - 파일명을 통해 쉽게 찾지만, 파일의 내용 기반으로 검색하는 것은 어렵고 오래걸린다.
2. RDBMS
   - 내용 기반
   - 내용 기반으로 연관 조회 가능
   - 정형화되지 않은 문서 저장, 검색은 부적합

**디스크가 없다면 어떻게 될까?**
지금은 소멸중인 부품 중 하나다.
머지않아 CD, 테이프 드라이브 등과 같이 소멸의 길로 갈 것이다.
디스크는 RAM으로 대체되고 있다.
모든 데이터가 RAM에 저장된다면 데이터를 어떻게 체계화할 것인가?
다양한 자료구조를 통해 데이터들을 체계화 하고, 데이터 접근시 포인터나 참조를 사용하면 된다.
이것이 프로그래머가 하는 일이다. 그리고 지금도 하고 있는 일이다.

**세부사항**
디비는 결국 세부사항이다.
단지 디스크 표면과 램 사이에서 데이터를 옮길 대 사용한다.
비트를 담는 거대한 그릇이고, 장기적으로 영구히 보관하는 공간일뿐이다.
아키텍처 관점에서는 디스크의 존재도 인식하면 안 된다.

**하지만 성능은?**
데이터 성능은 중요하지만, 저수준의 관심사다.
따라서 시스템의 전반적인 아키텍처와 아무런 관련이 없다.

**개인적인 일화**
디스크에서 데이터를 가져와 데이터를 표현하는 표준 방식 중 파일 시스템과 RDBMS에서
저자의 당시 기업은 파일 시스템 방식이었다.
그 방식이 시스템 아키텍처적으로 옳았다.

그러나 타 부서와 하드웨어 부서에서 RDBMS의 도입을 적극적으로 원했다.
신뢰성과 고객의 원함이었기 때문이다.

시스템 아키텍처적으로 옳던 아니던 RDBMS는 유행이 되어 고객 입장에서 필수 기술(?)이 되어있던 셈이다.
저자는 당사자들과 토론을 했고, 여러 이유로 RDBMS는 도입되었다.
그러나 저자는 그 선택이 옳았다고 한다. 시스템 아키텍처적으로 말고, 다른 이유에서 옳았다고 한다.
이런 일은 경험하지 않았지만 익숙한 환경이다.
기술 선택에 있어서 뿐만 아니고, 이러한 사유로 인한 것들은 뭐가 됐던 익숙한 것 같다.

어쨋든 디비는 세부사항이다. 아키텍처는 데이터의 표현 방식을 알아서는 안되고 관여해서도 안 된다.

```text
느낀점 & 정리

시스템의 아키텍처 방향에서 요구사항 변경은 아니었기 때문에 개인적인 일화의 RDBMS의 도입이 된 것 같다.
도메인 특성상 어떤 것이 유리하던간에 고객과 내부에서 요구하는 방향은 다를 수 있다.
설령 전문가의 의견과 반대되는 의견이라도, 그것이 유행하거나 또는 지향하고자 하는 방향에 따라 그것이 무엇이든간에 선택 될 수 있다.
저자의 개인적인 일화에서 느낀 점은 IT 소프트웨어 개발팀 입장에서 적극적으로 의견을 표명하고 커뮤니케이션했다는 것이다.
어떤 방향으로 색안경을 끼고, 대화 시도에 소극적이 될 수 있는데, 
저자는 앞에서 말했던 IT 개발 팀에 입사한 이유를 지키고 있었다.
어떤 상황에서도 일관적이고 적극적인 태도는 옳은 것 같다. 
```
---

# 31장 웹은 세부사항이다.
지난 세기, 웹이 바꾼 것은 아무것도 없고 그래서는 안 된다.
모든 연산 능력을 중앙 서버에 두는 방식과 단말에 두는 방식, 두 가지 사이에서 끊임없이 움직여 왔다.
저자는 한숨이 나왔다.

**끝없이 반복하는 추**
앞으로도 우리는 연산 능력을 어디에 둘지 알 수 없다.

**요약**
GUI는 세부사항이기에 웹은 세부사항이다.
핵심 업무 로직에서 당연히 분리되어야 하는 대상이다.
따라서 웹은 경계 바깥에 두어야 한다.
---

# 32장 프레임워크는 세부사항이다
당연하게도 프레임워크는 아키텍처가 될 수 없다.
즉, 아키텍처에 프레임워크의 결합도가 생기면 안 된다.

**프레임워크 제작자**
프레임 워크 선정은 아키텍처적으로도 중요한 요소가 될 수 있다.
기업의 목표나 도메인에 꽤 많은 영역의 도움을 받거나 겹칠 수 있다.

그러나 프레임워크는 세부사항이다.
고수준을 먼저 정의한 이후 저수준을 셀렉하면 된다.
고수준이 저수준을 알게하면 안 된다.
저수준은 선택사항으로 열어두어야 한다. 

**혼인 관계의 비대칭성**
프레임워크 수요자와 제공자의 관계는 비대칭적이다.
프레임워크 사용시 제공되는 문서를 꼼꼼히 읽어야 한다.

프레임워크 제작자 입장에서 아키텍처와의 결합은 우리와 달리 위험하지 않다.
한 번 결합되면 관계를 깨기 매우 어렵다.
따라서 프레임워크 제작자는 사용자와의 혼인(?)하기를 요구한다.
이러한 일방적인 혼인 관계를 감수하면 안 된다.
프레임워크는 세부사항이다.

**위험요인**
- 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많다.
- 프레임워크는 의존성 규칙을 위반하는 경향이 있다.
  - 예를 들어 자바 표준이 아닌 스프링에서 제공하는 라이브러리를 가공해서 상속 또는 구현한 경우 결합도가 상승한다. 
- 프레임워크는 앱 초기 기능 만드는 데 도움이 되지만, 규모가 커지면서 프레임워크 제공 기능, 틀을 벗어나게 된다.
  - 즉 규모가 커지면서, 프레임워크의 결합도가 짐이 될 수 있다.
- 프레임워크는 도움되지 않는 방향으로 진화될 수 있다.
  - 정작 중요한 일을 중요하지 않은 일 때문에 더디거나 놓칠 수 있다.
  - 권장하지 않음 등
- 더 강력한 프레임워크가 등장할 수 있다.

**해결책**
"프레임워크와 결혼하지 말라!"

프레임워크의 효율적은 사용은 좋다. 그러나 결합되어서는 안 된다.
프레임워크가 아키텍처 안쪽 원으로 들어오지 못하게 해야 한다.
즉 고수준의 영역에 가깝게 두지 말라.

프레임워크 기반 파생 클래스를 생성하지 말고, 프록시를 만들어 컴포넌트에 프록시를 위치시켜라.
프레임워크가 핵심 코드 안으로 들어오게 하면 안 된다.
대신 핵심 코드에 플러그인 형태로 제공하고, 의존성 규칙을 준수해야 한다.

예를 들어 스프링의 경우 @Autowired, 업무 객체는 절대 스프링에 대해 알아선 안 된다.
스프링을 알아도 되는 것은 메인이다. 지저분하고 최저 수준의 컴포넌트에서 사용하자. (?)

**이제 선언합니다**
결혼해야만 하는 프렝미워크도 존재한다.
C++의 경우 STL이다. 피하기 힘든 관계가 있다.
자바의 경우 표준 라이브러리와 결혼해야 한다.

이러한 관계는 정상적이면서 선택적이어야 한다.
결코 가볍게 프레임워크와 결혼하면 안 된다.

```text
느낀점 & 정리

SW 용어를 사용하면서 결혼, 혼인이 나와 살짝 당황했다.
번역이 잘못된건가 싶기도 했지만,
어쨋든 중요한 점은 프레임워크는 저수준의 선택사항이란 것이다.
선택사항은 열어둬야 하고, 언제든 목적과 목표에 맞게 갈아끼워져야 한다.
마치 플러그인 형태로 사용, 미사용을 정하듯이 말이다.
이 챕터의 내용 중 잘 이해 안 가는 부분도 있지만,
충분히 흡수한 것은, 프레임워크가 제공하는 코드를 덕지덕지 붙이면 프레임워크의 결합도가 올라갈 수 있단 것이다.
언어 to 언어로 마이그레이션한 경험은 없어서 이 것이 얼만큼 공수가 많이 드는지 아직 정확하진 않지만,
어느정도 예상은 할 수 있었다.
자바라면 자바 표준 라이브러리를 활용하고, 프레임워크가 제공하는 파생 클래스 생성을 줄여서 프레임워크와의 결합도를 높이면 안 될 것 같다.
```
---

# 33장 사례 연구: 비디오 판매
뛰어난 아키텍트의 업무 처리 과정과 결정을 간단한 사례로 살펴보자.

**제품**
웹 사이트에서 비디오 판매하는 SW 사례 연구다.
판매할 비디오가 있고, 개인과 기업에게 웹을 통해 판매한다.
개인은 단품 가격 지불해 보거나 더 높은 가격을 내고 비디오 다운로드를 할 수 있다.
기업용 라이선스는 스트리밍 전용이다. 대량 구매 할인이 있다.

개인은 구매자인 동시에 시청자
기업은 시청자와 구매자가 따로 있다.

비디오 제작자는 비디오 파일, 설명서, 부속 파일 제공
관리자는 시리즈몰 추가, 삭제 또는 라이선스에 맞춰 가격 책정한다.

**유스케이스 분석**
(p.311 그림 33.1 참고)

네 개의 주요 액터는 분면하다.
SRP에 따르면 네 개의 액터가 시스템 변경의 주요 네가지 근원이 된다.
(제작자, 구매자, 관리자, 시청자)

따라서 시스템 분할을 통해 특정 액터의 변경이 다른 액터에 전혀 영향을 미치지 않게 해야 한다.

**컴포넌트 아키텍처**
액터와 유스케이스 식별 후 예비 단계의 컴포넌트 아키텍트를 만들 수 있다. (p.312 그림 33.2 참고)
이중 선으로 경계를 구분하고, 뷰, 프레젠터, 인터랙터, 컨트롤러의 전형적인 분할 방법을 확인할 수 있다.

**의존성 관리**
한쪽 방향으로 화살표가 가리키는 것은 아키텍처가 의존성 규칙을 준수하기 때문이다.
방향은 항상 더 높은 수준의 정책을 포함하는 컴포넌트를 향한다.

```text
느낀점 & 정리
이번 장은 집중이 잘 안 됐다. 다음에 다시 한 번 읽자.
```
---

# 34장 빠져 있는 장
온라인 서점 구축시 고객이 주문 상태 조회 유스케이스 구현 예제를 살펴보자.
아키텍처를 제외한 설계나 코드 조직화 관련 몇 가지 접근법을 살펴보자.

**계층 기반 패키지**
첫 번째 설계 방식은 수평 계층형 아키텍처다.
기술적인 관점으로 코드 행위를 기반해 분할한다. 이를 계층 기반 패키지라 부른다.
계층형 아키텍처에는 웹, 업무 규칙, 영속성 코드를 위해 계층이 하나씩 존재한다.

코드를 얇은 수평 조각으로 나누고, 계층을 유사한 것들을 묶는 도구로 사용한다.
엄격한 계층형 아키텍처는 반드시 아래 계층에만 의존해야 한다.

여기서는 Controller 계층, Service 계층, Repository계층으로 각 계층으로 나뉜다.

- OrderController: 웹 기반 요청 처리
- OrderService: 주문 관련 업무 규칙 정의 인터페이스
  - OrderServiceImpl
- OrderRepository: 영구 저장 주문 정보에 접근 방법 정의 인터페이스
  - JdbcOrderRepository

마틴 파울러는 프레젠테이션 도메인 데이터 계층화에서 첫 시작은 계층형 아키텍처가 적합하다고 얘기했다.

**기능 기반 패키지**
서로 연관된 기능, 도메인 개념, Aggregate Root에 기반해 수직의 얇은 조각으로 코드를 나눈다.
즉 같은 패키지에 담는다. Controller, Service, Repository

**포트와 어댑터**

**컴포넌트 기반 패키지**
계층형 아키텍처가 좋지 않다고 여겨야 하는 이유가 있다.
계층형의 목적은 기능이 같은 코드끼리 서로 분리한다. (웹, 서비스, 리파지토리)
웹과 서비스는 다른 패키지에 속하기에 계층간 접근을 위해 무조건 서비스를 public으로 두어야 한다.
마찬가지로 서비스에서 리파지토리 계층에 접근하기 위해 리파지토리는 public로 되어 있어야 한다.

앞서 얘기했듯이 엄격한 계층형 아키텍처는 각 계층은 바로 아래 계층에만 의존해야 한다.
이러한 방식은 비순환 의존성 그래프를 만들 수 있을 것 같지만, 몇 가지 규칙을 반드시 지켜야 한다.

여러 사람이 일하는 환경에서 Controller에서 Service를 바라봐야 한다. 
왜냐하면 각 계층은 바로 아래 계층에만 의존해야되기 떄문이다.
그러나 누군가에 의해서 Controller에서 바로 Repository에 접근 할 수도 있다.

해당 유스케이스는 동작은 한다. 그러나 기대하는 형태로 구현되지 않았다.
여기서 필요한 규칙은 웹 컨트롤러에서는 리파지토리에 직접 접근해서는 안 된다는 규칙이다.
서비스와 리파지토리 모두 public으로 되어야만 하기 때문에 규칙이 필요하다.
그러나 규칙을 강제하고 무한한 믿음을 기반으로 진행해도, 끝은 모른다.

다소 조잡한 규칙이지만 효과는 있다.
가능하면 컴파일러를 사용해 아키텍처를 강제하는 방식이 좋다.
컴포넌트 기반 패키지를 도입해야 하는 이유다.

이는 포트와 어댑터, 기능 기반 패키지, 계층 기반 패키지의 혼합 형태로
큰 단위의 단일 컴포넌트 관련 모든 책임을 하나의 자바 패키지로 묶는다.

서비스 중심적인 시각으로 SW 시스템을 바라본다.

컨트롤러 계층이 존재하고, 주문 패키지에 Component, ComponentImpl, OrderRepository, OrderRepositoryImpl을 같이 둔다.
Q) 서비스가 없네?
업무 로직과 영속성 관련 코드를 하나로 묶는다. 이 묶음을 컴포넌트라 부른다.
컴포넌트의 정의는 여러 가지가 있다. 

모노리틱 앱에서도 컴포넌트를 잘 정의하면 MSA를 위한 발판을 삼을 수 있다.

**구현 세부사항엔 항상 문제가 있다**
살펴본 각각의 접근법은 서로 다른 아키텍처 스타일로 여길 수 있다.
자바에서 public 접근 제어자를 지나칠 정도로 방만하게 사용하는 모습이 자주 보이는데,
어느 순간 public 접근 제어자는 아무런 고민 없이 사용하게 됐다.
이는 프로그래밍 언어에서 제공하는 캡슐화 관련 이점을 활용하지 않는다는 것이다.

누군가는 결국 public 접근 지시자를 통해 구체적인 구현 클래스의 인스턴스의 생성을 작성하면서,
지향해야 하는 아키텍처 스타일은 위반하게 된다.
지금은 막을 수 있어도 앞으로는 막을 수 없다.

**조직화 vs 캡슐화**
자바에서 모두 public 접근 제어자로 지정했다고 가정해보자.
캡슐화 이점을 당연히 못 누리고, 사실상 패키지 사용에 따른 이점도 없다. 패키지가 없는 것과 별반 다르지 않다.
이는 어떤 아키텍처를 지향하는지 알 수도 없고 의미도 없다.

자바의 접근 제어자는 완벽하진 않아도, 절대 무시하고 고민하지 않으면 안 된다.
접근 제어자와 패키지의 적절한 사용을 통해 접근 방식이 크게 달라질 수 있다.

외부에서 접근해야하는 service, repository 인터페이스는 public으로 두고, 
구현체 클래스를 protected로 선언함으로써 조금이나마 제한 할 수 있다.

public가 적을 수록 필요 의존성 수도 적어진다.
모놀리틱 앱을 구축 중이라면 반드시 아키텍처 원칙을 강제할 때 컴파일러에 의지할 것을 권장한다!

**다른 결합 분리 모드**
소스 코드 의존성을 분리하는 방법은 모듈을 통해 할 수도 있다.
자바9에서 제공하는 모듈이나 프레임워크가 있다.

**결론: 빠져 있는 조언**
최적의 설계를 하더라도, 구현 전략의 복잡합을 고려하지 않으면 설계가 언제든 망가질 수 있다.
컴파일러의 적극적 도움을 받으며, 불필요한 결합도를 높이지 않도록 주의하라.


```text
느낀점 & 정리

보통 내가 경험했던 패키지 구조는 계층 기반 패키지 형태였다.
심지어 서비스 인터페이스를 만들지 않아서 서적에 나온대로 public을 본능적으로 사용하고는 했던 것 같다.
접근 제어자와 패키지 구조를 통한 캡슐화에 대해 많이 고민 하진 않았는데,
이번 챕터를 통해 고민하게 된 계기가 됐다.
이러한 구조 고민을 통해 모놀리틱에서 MSA의 발판이 될 수 있으니, 유의미한 고민 같다.
실무에서 public을 당연하게 여기는 팀에서 일하게 되면, 이런 고민을 하는 시간이 업무 일정에 영향을 미쳐 압박을 받을 떄도 있지만,
필요한 고민이라고 더 판단이 된 것 같다.
이러한 고민을 개인의 선에서 끝나면 압박이지만, 팀간 공유를 통해 지식을 함꼐 공유한다면 압박이 아니라 건설적 커뮤니케이션이 될 것 같다.

여러 접근 제어자를 활용해 클래스다이어그램의 가독성을 높일 수 있으니 적극 고민하자.
```
---