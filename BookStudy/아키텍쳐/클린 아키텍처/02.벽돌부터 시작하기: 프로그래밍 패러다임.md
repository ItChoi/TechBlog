# 3장 패러다임 개요
패러다임이란 프로그래밍을 하는 방법이다.
프로그래밍 구조와 구조를 언제 사용하는지 결정한다.

패러다임은 세 가지 종류가 있다.
1. 구조적 프로그래밍
   - 최초 적용 패러다임이다. (최초 생성X)
   - 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
2. 객체 지향 프로그래밍
   - 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
3. 함수형 프로그래밍
   - 할당문에 대해 규칙을 부과한다.

패러다임은 무엇을 해서는 안 되는지를 말해준다.

```text
느낀점

세 가지 패러다임이 있다. 
기존에도 알고 있던 패러다임 방식이다. 
그런데 이 패러다임 외에 새로운 프로그래밍 패러다임이 없다는건 알지 못했다.
어떤 것에 충실할 지 보단, 무엇을 회피해야하는지 알려주는 패러다임
데드락도 완벽한 해결 방법은 없기에 여러 가지 회피 규칙이 존재하는데, 
프로그래밍에서는 회피가 최선인 경우가 가끔 있는 것 같다.
```
---

# 4장 구조적 프로그래밍
'에츠허르 비버 데이크스트라' 사람이 있었다.
이는 1948년 당시 수학, 물리, 화학, 생물에서 최고 점수를 받으며 고등학교를 졸업했고, 네덜란드 최초 프로그래머로서 암스테르담의 수학센터에 취업한다.
프로그래머로 3년간 일하면서, 자신에게 이론 물리보다 프로그래밍 지적 도전이 더 큰 의미가 있다고 결론 내렸다.
당시 프로그래머라는 직업을 인정하지 않았는데, 자신의 상사(소프트웨어를 과학으로 발전시킨 사람 중 한명)의 상담을 통해 될 수 있음을 인정받았다.

당시 컴퓨터는 거대하고 쉽게 손상되고 느리고 결과도 믿을 수 없는 극도의 제한적인 환경이었다.
수정, 컴파일, 테스트를 반복하는 일은 몇시간 ~ 며칠이 걸렸다.
데이크스트라는 이런 원시적이고 극도의 환경에서 위대한 발견을 해냈다.

증명
당시 프로그래밍을 하기 위해서는 지금보다 더 많은 것을 알고 있어야 했다. 
현재 우리는 자동 설정 및 프레임워크를 사용해 당연하게 생각하는 것들을 직접 구현해야 하기 떄문이다.
이는 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다.
세부사항을 간과하면, 인간의 눈으로는 동작하는 것 처럼 보여도, 결국 예상 외의 방식으로 실패하곤 했다. 

데이크스트라는 수학적 원리를 통해 이 문제를 증명하여 해결하고자 했다.
프로그래머는 입증된 구조를 이용하고 코드와 구조를 결합시키며 올바름을 증명하는 방식이다.

그 당시 GOTO문은 헤로웠다. if/elseif/else, do/while을 통해 GOTO를 줄일 수 있다. (?)
모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration) 세 구조만으로 표현할 수 있다는 것을 증명했다.

그 당시 인터넷이 없었지만 편지를 통해 출판사에게 사실을 알렸고, 여러 논쟁이 이어지면서 goto 문장이 거의 사라졌다.

엄밀한 증명은 없었다.
대개의 프로그래머들은 엄밀한 증명이 이득이라고 보지 않았다.
오늘날 데이크스트라처럼 엄밀한 증명이 고품질 소프트웨어를 생산하기 적절한 방법이라고 믿는 사람은 거의 없다.

입증할 때 방식은 수학적인 증명뿐만 아니라, 과학적 방법도 있다.
둘 간의 차이는 올바름은 증명할 수 있는지 여부다.
과학은 사실임을 증명하기보단, 틀렸음을 증명해낸다.

데이크스트라는 테스트는 버그가 있음을 보여줄뿐, 없음을 보여줄수는 없다고 했다.
테스트에 충분한 노력을 한다면 프로그램이 목표에 부합할만큼 충분히 참이라고 여길수 있게 해주는 것이 전부다.
따라서 오히려 소프트웨어는 과학이랑 더 비슷하다.

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 다음과 같다.
1. 세부적인 모듈 분할 등을 통해 반증의 단위를 만들어낼 수 있다.
2. 기능적 분해를 최고의 실천법 중 하나로 여긴다.

```text
느낀점
```
오늘날의 프로그래밍이 책에서와 같이 과학에 더 유사하다고 해도,
지금보다 많은 것들이 갖춰지지 않고, 시간이 무려 몇 배는 더 걸리는 환경에서도 
여러 가지 수학적인 입증과 테스트는 프로그램 목표를 보장해주는 것이 아니라, 목표에 부합할만큼 참이라고 여기게 해준다는 의견을 냈다는 점에서 대단한 사람인 것 같다.
그 당시 환경과, 국가 등 여러 가지가 지금 나에게 처한 상황과 비슷하다고 볼 순 없지만, 그때보다 더 나은 개발 환경에서 일하고 있는 입장에서
테스트에 게을러지지 말고, 더 좋은 개발을 하기 위한 노력을 지속적으로 해야겠다.

폰 노이만 구조도 CPU와 메모리의 효율적 사용, 관리를 위해 계속 발전해온 것처럼 프로그래밍 구조도 계속해서 발전해왔다는 것을 알 수 있었다.
---
# 5장 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.

그렇다면 객체지향이란 무엇일까?
- 데이터와 함수의 조합?
- 실제 세계를 모델링하는 새로운 방법?
다 너무 모호하다.

본질을 설명하기 위해 세 가지 주문에 기대는 부류도 있다.
1. 캡슐화?
   - 객체 지향 언어에서는 접근제어자를 통해 표현한다. 그리고 비단 객체지향 언어 뿐만 아니라, C에서도 캡슐화는 가능하다.
     - 접근제어자를 통해 캡슐화를 어느 정도 보완하기는 했지만, 컴파일러가 캡슐화된 대상을 볼 수 있어야 하기 때문에 임시방편에 불과하다.
   - 자바와 C#은 헤더와 구현체 분리 방식이 없어서 캡슐화는 심하게 훼손됐다. 따라서 클래스 선언과 정의를 구분하는게 아예 불가능하다 ((Q) 잘 이해가 안 간다.)
     - 즉 프로그래머가 캡슈화된 데이터를 우회해서 사용하지 않을거라는 믿임을 기반으로 한다.
2. 상속?
   - OOP가 더 나은 캡슐화를 제공하진 못하지만, 상속만큼은 제공했다. -> 그러나 C도 과거부터 언어 도움 없이 손수 이런 방식 구현 가능했다.
     - 상속은 객체 지향이 나오기 전 부터 흔히 사용하던 기법이다. 하지만 다중 상속 구현은 훨씬 더 어려웠다.
     - 상속이란 기법은 과거에도 흔히 사용되어 왔지만 객체지향이 상속을 편리하게 제공하고 있다. 
3. 다형성?
   - 마찬가지로 과거 C에서도 사용되어 왔다.
   - 런타임 시점에 값을 할당

결론적으로 객체지향이란 다형성을 이용해 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
객체지향을 사용하면 아키텍트는 플러그인 아키텍트를 구성할 수 있고, 고수준에 포함하는 저수준의 세부 사항을 포함하는 모듈을 독립적으로 보장할 수 있다.

```text
느낀점
```
이번 장은 잘 와닿지가 않았다.
캡슐화와 상속은 OOP를 사용하는 이유라고 하기엔 모호한 부분이 있다.
이미 과거에서부터 비슷한 기법으로 사용되어 왔고 다만 편의성을 보장하는 정도의 수준인 것 같다.

다만 객체지향에서 다형성이란 굉장히 중요한 개념이다.
이를 통해 고수준의 구조 및 정책과 저수준의 세부사항들을 독립적으로 보장하고 사용할 수 있게 해준다.
기존의 알고 있던 이론과 크게 다른 점은 없어서 와닿은 내용은 없지만, 조금 더 고민하면서 다시 읽어봐야 될 것 같다.
객체지향 언어에 다형성이 주는 의미를 상세하게 다시 한 번 생각해보자.
---

# 6장 함수형 프로그래밍
이 패러다임의 기반은 람다 계산법이다.
함수형 언어에서 변수는 변경되지 않는다.
이는 클로저 프로그램을 보면 알 수 있는데, 가변 변수가 없다.
따라서 한 번 초기화되면 값은 절대 변하지 않는다.

아키텍처를 고려할 때 "절대 변하지 않는 값"은 중요하다.
왜냐하면 경합 조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생한다.
따라서 동시성 발생 원인의 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션이 마주치는 모든 문제는 가변 변수가 없으면 절대로 생기지 않는다.

아키텍트를 고려할 때 동시성 문제에 많은 관심을 가져야 한다.

그렇다면 값이 변하지 않는 불변성은 실현 가능할까?
실현 가능하지만, 적절한 트레이드오프가 필요하다.
1. 가변성의 분리
```text
애플리케이션 내부의 서비스를 가변, 불변 컴포넌트로 분리한다.
앞서 말했듯 함수형 언어의 변수는 변경되지 않는다.
따라서 불변 컴포넌트는 순수 함수형 방식으로만 처리되고, 
어떤 상황에서도 가변 변수를 사용하지 않는다.

불변 컴포넌트는 변수의 상태를 변경할 수 있다.
즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 
그러나 변수 상태를 변경하는 것 자체도 동시성 이슈에 노출된다.
따라서 트랜잭션 메모리를 이용해 이슈로부터 가변 변수를 보호한다.
```

세 가지 패러다임은 코드 작성 방식 형태를 한정시킨다.
해서는 안되는 것에 대해 배우는 것은 중요하다.
이를 이해한다면, 소프트웨어는 급격히 발전하는 기술이 아니라는 것을 알 수 있다.
1947년 최초 코드 작성시 소프트웨어 규칙과 현재는 다르지 않다.
단지 도구, 하드웨어만 달라졌을 뿐이다.
컴퓨터 프로그램은 단지 순차, 분기, 반복으로 구성될 뿐이다.

```text
느낀점

데드락에 대해 공부할 때, 데드락이 왜 발생할까?라는 것을 지레짐작하고 넘어갔는데, 
책에서 나온 '가변 변수'를 듣고 다시 한 번 생각하게 됐다.

공유 자원에 동시에 접근하고 이를 바꾸거나 할 때, 이 변수는 가변적으로 변하고, 시점에 따라 사용자는 다른 값을 조회하기도 하고, 이상한 값이 세팅되기도 한다.
결국에는 이 공유 자원도, 가변 변수기 때문이란걸 인지하게 되는 장이었다.
 
또한 함수형 패러다임에서는 가변 변수가 존재하지 않고, (쓰면 쓸 수 있지만 안 쓴다는건가?)
불변성 컴포넌트는 그 자체로 동작하지 않고, 하나 이상의 가변 컴포넌트와 통신한다.
가변 컴포넌트를 통해 변수의 상태를 바꿀 수 있고, 이는 여전히 가변 컴포넌트의 문제점을 안게 되지만,
트랜잭션을 활용해 가변 변수를 보호하게 된다.
```
