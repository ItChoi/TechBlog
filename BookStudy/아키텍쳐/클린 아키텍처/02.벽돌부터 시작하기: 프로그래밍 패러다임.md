# 3장 패러다임 개요
패러다임이란 프로그래밍을 하는 방법이다.
프로그래밍 구조와 구조를 언제 사용하는지 결정한다.

패러다임은 세 가지 종류가 있다.
1. 구조적 프로그래밍
   - 최초 적용 패러다임이다. (최초 생성X)
   - 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
2. 객체 지향 프로그래밍
   - 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
3. 함수형 프로그래밍
   - 할당문에 대해 규칙을 부과한다.

패러다임은 무엇을 해서는 안 되는지를 말해준다.

```text
느낀점

세 가지 패러다임이 있다. 
기존에도 알고 있던 패러다임 방식이다. 
그런데 이 패러다임 외에 새로운 프로그래밍 패러다임이 없다는건 알지 못했다.
어떤 것에 충실할 지 보단, 무엇을 회피해야하는지 알려주는 패러다임
데드락도 완벽한 해결 방법은 없기에 여러 가지 회피 규칙이 존재하는데, 
프로그래밍에서는 회피가 최선인 경우가 가끔 있는 것 같다.
```
---

# 4장 구조적 프로그래밍
'에츠허르 비버 데이크스트라' 사람이 있었다.
이는 1948년 당시 수학, 물리, 화학, 생물에서 최고 점수를 받으며 고등학교를 졸업했고, 네덜란드 최초 프로그래머로서 암스테르담의 수학센터에 취업한다.
프로그래머로 3년간 일하면서, 자신에게 이론 물리보다 프로그래밍 지적 도전이 더 큰 의미가 있다고 결론 내렸다.
당시 프로그래머라는 직업을 인정하지 않았는데, 자신의 상사(소프트웨어를 과학으로 발전시킨 사람 중 한명)의 상담을 통해 될 수 있음을 인정받았다.

당시 컴퓨터는 거대하고 쉽게 손상되고 느리고 결과도 믿을 수 없는 극도의 제한적인 환경이었다.
수정, 컴파일, 테스트를 반복하는 일은 몇시간 ~ 며칠이 걸렸다.
데이크스트라는 이런 원시적이고 극도의 환경에서 위대한 발견을 해냈다.

증명
당시 프로그래밍을 하기 위해서는 지금보다 더 많은 것을 알고 있어야 했다. 
현재 우리는 자동 설정 및 프레임워크를 사용해 당연하게 생각하는 것들을 직접 구현해야 하기 떄문이다.
이는 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다.
세부사항을 간과하면, 인간의 눈으로는 동작하는 것 처럼 보여도, 결국 예상 외의 방식으로 실패하곤 했다. 

데이크스트라는 수학적 원리를 통해 이 문제를 증명하여 해결하고자 했다.
프로그래머는 입증된 구조를 이용하고 코드와 구조를 결합시키며 올바름을 증명하는 방식이다.

그 당시 GOTO문은 헤로웠다. if/elseif/else, do/while을 통해 GOTO를 줄일 수 있다. (?)
모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration) 세 구조만으로 표현할 수 있다는 것을 증명했다.

그 당시 인터넷이 없었지만 편지를 통해 출판사에게 사실을 알렸고, 여러 논쟁이 이어지면서 goto 문장이 거의 사라졌다.

엄밀한 증명은 없었다.
대개의 프로그래머들은 엄밀한 증명이 이득이라고 보지 않았다.
오늘날 데이크스트라처럼 엄밀한 증명이 고품질 소프트웨어를 생산하기 적절한 방법이라고 믿는 사람은 거의 없다.

입증할 때 방식은 수학적인 증명뿐만 아니라, 과학적 방법도 있다.
둘 간의 차이는 올바름은 증명할 수 있는지 여부다.
과학은 사실임을 증명하기보단, 틀렸음을 증명해낸다.

데이크스트라는 테스트는 버그가 있음을 보여줄뿐, 없음을 보여줄수는 없다고 했다.
테스트에 충분한 노력을 한다면 프로그램이 목표에 부합할만큼 충분히 참이라고 여길수 있게 해주는 것이 전부다.
따라서 오히려 소프트웨어는 과학이랑 더 비슷하다.

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 다음과 같다.
1. 세부적인 모듈 분할 등을 통해 반증의 단위를 만들어낼 수 있다.
2. 기능적 분해를 최고의 실천법 중 하나로 여긴다.

```text
느낀점
```
오늘날의 프로그래밍이 책에서와 같이 과학에 더 유사하다고 해도,
지금보다 많은 것들이 갖춰지지 않고, 시간이 무려 몇 배는 더 걸리는 환경에서도 
여러 가지 수학적인 입증과 테스트는 프로그램 목표를 보장해주는 것이 아니라, 목표에 부합할만큼 참이라고 여기게 해준다는 의견을 냈다는 점에서 대단한 사람인 것 같다.
그 당시 환경과, 국가 등 여러 가지가 지금 나에게 처한 상황과 비슷하다고 볼 순 없지만, 그때보다 더 나은 개발 환경에서 일하고 있는 입장에서
테스트에 게을러지지 말고, 더 좋은 개발을 하기 위한 노력을 지속적으로 해야겠다.

폰 노이만 구조도 CPU와 메모리의 효율적 사용, 관리를 위해 계속 발전해온 것처럼 프로그래밍 구조도 계속해서 발전해왔다는 것을 알 수 있었다.
---
# 5장 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.

그렇다면 객체지향이란 무엇일까?
- 데이터와 함수의 조합?
- 실제 세계를 모델링하는 새로운 방법?
다 너무 모호하다.

본질을 설명하기 위해 세 가지 주문에 기대는 부류도 있다.
1. 캡슐화?
   - 객체 지향 언어에서는 접근제어자를 통해 표현한다. 그리고 비단 객체지향 언어 뿐만 아니라, C에서도 캡슐화는 가능하다.
     - 접근제어자를 통해 캡슐화를 어느 정도 보완하기는 했지만, 컴파일러가 캡슐화된 대상을 볼 수 있어야 하기 때문에 임시방편에 불과하다.
   - 자바와 C#은 헤더와 구현체 분리 방식이 없어서 캡슐화는 심하게 훼손됐다. 따라서 클래스 선언과 정의를 구분하는게 아예 불가능하다 ((Q) 잘 이해가 안 간다.)
     - 즉 프로그래머가 캡슈화된 데이터를 우회해서 사용하지 않을거라는 믿임을 기반으로 한다.
2. 상속?
   - OOP가 더 나은 캡슐화를 제공하진 못하지만, 상속만큼은 제공했다. -> 그러나 C도 과거부터 언어 도움 없이 손수 이런 방식 구현 가능했다.
     - 상속은 객체 지향이 나오기 전 부터 흔히 사용하던 기법이다. 하지만 다중 상속 구현은 훨씬 더 어려웠다.
     - 상속이란 기법은 과거에도 흔히 사용되어 왔지만 객체지향이 상속을 편리하게 제공하고 있다. 
3. 다형성?
   - 마찬가지로 과거 C에서도 사용되어 왔다.
   - 런타임 시점에 값을 할당

결론적으로 객체지향이란 다형성을 이용해 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
객체지향을 사용하면 아키텍트는 플러그인 아키텍트를 구성할 수 있고, 고수준에 포함하는 저수준의 세부 사항을 포함하는 모듈을 독립적으로 보장할 수 있다.

```text
느낀점
```
이번 장은 잘 와닿지가 않았다.
캡슐화와 상속은 OOP를 사용하는 이유라고 하기엔 모호한 부분이 있다.
이미 과거에서부터 비슷한 기법으로 사용되어 왔고 다만 편의성을 보장하는 정도의 수준인 것 같다.

다만 객체지향에서 다형성이란 굉장히 중요한 개념이다.
이를 통해 고수준의 구조 및 정책과 저수준의 세부사항들을 독립적으로 보장하고 사용할 수 있게 해준다.
기존의 알고 있던 이론과 크게 다른 점은 없어서 와닿은 내용은 없지만, 조금 더 고민하면서 다시 읽어봐야 될 것 같다.
객체지향 언어에 다형성이 주는 의미를 상세하게 다시 한 번 생각해보자.
---

# 6장 함수형 프로그래밍
```text
느낀점
```
