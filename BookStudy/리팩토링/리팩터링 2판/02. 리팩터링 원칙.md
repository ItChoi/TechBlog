리팩터링 전반에 적용되는 원칙 몇 가지를 살펴보자.  

# 2.1 리팩터링 정의
리팩터링은 두루뭉실한 의미를 다 포괄하지 말고, 구체적으로 엄격하게 정의해야 유용하다.  
리팩터링은 명사, 동사 두 가지 용어로 쓸 수 있다.  
1. 리팩터링(명사): 소프트웨어 겉보기 동작은 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
   - 앞 장에서 나온 '함수 추출하기', '조건부 로직을 다형성으로 바꾸기' 등이 해당한다.
2. 리팩터링(동사): 소프트웨어 겉보기 동작은 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
  
대부분의 개발자는 코드 정리 작업을 모조리 '리팩터링'이라고 표현한다.  
그러나 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.  
  
리팩터링은 결국 기존 동작을 보장한 채, 여러 단계들을 순차적으로 거쳐 코드를 수정하여 큰 변화를 만들어내는 일이다.  
리팩터링 대상의 규모는 매우 작을 수도 있고, 작은 단계를 여러 개 합친 모습일 수도 있다.  
  
중요한 것은 기존 동작을 보장하기 때문에, 리팩터링 중간에 동작을 얼마든지 멈출 수 있다.  
만약 "리팩터링 중 코드가 꺠져 며칠이나 고생했다."라고 한다면, 리팩터링을 한 것이 아니다.  
  
저자는 코드베이스 정리 또는 구조 변경하는 모든 작업을 '재구성'이라는 포괄적인 의미로 표현하고,  
재구성 중 특수한 형태를 '리팩터링'이라 본다.  
  
한 번에 변경 가능한 작업을 여러 단계로 분리해 작업한다면 오히려 비효율적이라고 느낄 수 있다.  
하지만 오히려 작은 작업도 단계를 분리해 오히려 작업을 더 효율적으로 처리 할 수 있다.  
  
리팩터링을 통해 내부 구조나 성능적으로 미세한 변화가 있다고 해도, 이용하거나 사용하는 관점에서 변화가 없어야 한다.  
리팩터링 기법 단계 중 '함수 선언 바꾸기', '함수 옮기기' 작업 중 발견한 버그는 리팩터링 후에도 남아있어야 한다. (단, 아무도 발견 못한 숨은 버그는 수정 가능)  
즉 여러 단계로 나눈 이상, 그 단계에 집중하여 수행해야 한다는 것 같다.  
  
리팩터링은 성능 최적화와 결이 비슷하다. 단지 목적이 다르다.  
코드를 변경하지만, 외부 기능은 그대로 유지한다.  
리팩터링의 목적은 코드를 이해, 수정을 쉽게하는 것이다.  

```text
내 의견

책에서 나온 리팩터링을 너무 포괄적인 용어로 쓰는 개발자 중 한 사람이었던 것 같다.
결과적으로 기능을 유지한 채, 같이 협업하는 개발자가 코드를 읽기 원활하고, 변경에 대응 가능하도록 생각하고 '리팩터링' 한다고 표현했다.
하지만 리팩터링 기법이나 여러 단계를 나눠 할 생각은 내포하지 않았었다. 
그렇기 때문에 당연히 리팩터링 중 작업을 멈췄을 때, 기능 유지를 보장하지 않았다. 작업을 끝 마쳐야 기능 동작이 유지 됐다.
그렇다면 내가 이러한 생각으로 코드를 수정한 것은 단순히 '코드 수정'이라고 표현하는게 맞을까? 

어쨋든 리팩터링을 너무 포괄적으로 사용하지 말고, 최소한 어떤 기법과 어떻게 단계를 나눌 수 있는지는 알아보고 여러 단계를 수행하며, 
단계의 우선순위를 바꾸거나 한 번에 작업을 바꾸려는 시도를 하지 말고, 연습을 통해 체득해야 할 필요가 있을 것 같다. 
```

# 2.2 두 개의 모자
저자는 SW 개발 시, 목적을 나눈다.
1. 기능 추가 목적
2. 리팩터링 목적
  
두 단계를 명확히 구분해 작업하는데, 켄트 벡은 이를 두 개의 모자에 비유했다.  
기능 추가시 기존 코드는 절대 건드리지 않고 새 기능을 추가하고, 진척도는 테스트 추가 후 통과를 기준으로 측정한다.  
리팩터링시 기능 추가는 절대 하지 않고, 오로지 '코드 재구성'에만 전념한다. 테스트도 새로 만들지 않지만, 부득이하게 인터페이스 변경시에만 기존 테스트를 수정한다.  
  
저자는 SW 개발 시, 두 모자를 자주 바꿔쓴다.  
코드 추가시 기존 코드 변경 후 작업이 원활할 때가 자주 생긴다.  
따라서 기능 추가 중, 모자를 바꿔 써 코드 재구성 완료 후 다시 기능 추가를 마무리 한다.  
기능 추가 완료 후 코드를 살펴보며 리팩터링 할 지를 판단하고 진행한다.  
중요한 점은 작은 작업일지라도, 어떤 모자를 썼는지 정확히 인지하고 진행해야 한다.  

```text
내 의견

이번 챕터는 짧지만 자서전 같은 느낌이 있어서 좋았다.
즉, 뭔가 대강 알고는 있지만 실행하지 못한 부분들을 이번에 읽으면서 앞으로 실행하면서 도움이 될 것 같다.
책에 나온 두 가지 모자를 바꿔 가며 비슷하게 진행한 적은 있지만, 명확히 구분하여 진행하지는 않았었다. 
두가지 모자를 반쯤 걸친채, 기능 추가시에도 기존 구조를 변경하고, 리팩터링 중간에도 유틸리티 생성 등 번갈아가면서 했던 것 같다.
결과적으로? 비슷할지 몰라도, 명확히 구분하여 진행한다면 미묘한 차이가 있을 것이라고 예상된다.
기능 추가, 리팩터링 두 가지 모자를 명확히 구분하여 진행하는 것을 목표로 삼아야 겠다.

```

# 2.3 리팩터링하는 이유

# 2.4 언제 리팩터링해야 할까?

# 2.5 리팩터링 시 고려할 문제

# 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

# 2.7 리팩터링과 소프트웨어 개발 프로세스

# 2.8 리팩터링과 성능

# 2.9 리팩터링의 유래

# 2.10 리팩터링 자동화

# 2.11 더 알고 싶다면
