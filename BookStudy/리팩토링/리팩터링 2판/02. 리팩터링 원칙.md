리팩터링 전반에 적용되는 원칙 몇 가지를 살펴보자.  

# 2.1 리팩터링 정의
리팩터링은 두루뭉실한 의미를 다 포괄하지 말고, 구체적으로 엄격하게 정의해야 유용하다.  
리팩터링은 명사, 동사 두 가지 용어로 쓸 수 있다.  
1. 리팩터링(명사): 소프트웨어 겉보기 동작은 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
   - 앞 장에서 나온 '함수 추출하기', '조건부 로직을 다형성으로 바꾸기' 등이 해당한다.
2. 리팩터링(동사): 소프트웨어 겉보기 동작은 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
  
대부분의 개발자는 코드 정리 작업을 모조리 '리팩터링'이라고 표현한다.  
그러나 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.  
  
리팩터링은 결국 기존 동작을 보장한 채, 여러 단계들을 순차적으로 거쳐 코드를 수정하여 큰 변화를 만들어내는 일이다.  
리팩터링 대상의 규모는 매우 작을 수도 있고, 작은 단계를 여러 개 합친 모습일 수도 있다.  
  
중요한 것은 기존 동작을 보장하기 때문에, 리팩터링 중간에 동작을 얼마든지 멈출 수 있다.  
만약 "리팩터링 중 코드가 꺠져 며칠이나 고생했다."라고 한다면, 리팩터링을 한 것이 아니다.  
  
저자는 코드베이스 정리 또는 구조 변경하는 모든 작업을 '재구성'이라는 포괄적인 의미로 표현하고,  
재구성 중 특수한 형태를 '리팩터링'이라 본다.  
  
한 번에 변경 가능한 작업을 여러 단계로 분리해 작업한다면 오히려 비효율적이라고 느낄 수 있다.  
하지만 오히려 작은 작업도 단계를 분리해 오히려 작업을 더 효율적으로 처리 할 수 있다.  
  
리팩터링을 통해 내부 구조나 성능적으로 미세한 변화가 있다고 해도, 이용하거나 사용하는 관점에서 변화가 없어야 한다.  
리팩터링 기법 단계 중 '함수 선언 바꾸기', '함수 옮기기' 작업 중 발견한 버그는 리팩터링 후에도 남아있어야 한다. (단, 아무도 발견 못한 숨은 버그는 수정 가능)  
즉 여러 단계로 나눈 이상, 그 단계에 집중하여 수행해야 한다는 것 같다.  
  
리팩터링은 성능 최적화와 결이 비슷하다. 단지 목적이 다르다.  
코드를 변경하지만, 외부 기능은 그대로 유지한다.  
리팩터링의 목적은 코드를 이해, 수정을 쉽게하는 것이다.  

```text
내 의견

책에서 나온 리팩터링을 너무 포괄적인 용어로 쓰는 개발자 중 한 사람이었던 것 같다.
결과적으로 기능을 유지한 채, 같이 협업하는 개발자가 코드를 읽기 원활하고, 변경에 대응 가능하도록 생각하고 '리팩터링' 한다고 표현했다.
하지만 리팩터링 기법이나 여러 단계를 나눠 할 생각은 내포하지 않았었다. 
그렇기 때문에 당연히 리팩터링 중 작업을 멈췄을 때, 기능 유지를 보장하지 않았다. 작업을 끝 마쳐야 기능 동작이 유지 됐다.
그렇다면 내가 이러한 생각으로 코드를 수정한 것은 단순히 '코드 수정'이라고 표현하는게 맞을까? 

어쨋든 리팩터링을 너무 포괄적으로 사용하지 말고, 최소한 어떤 기법과 어떻게 단계를 나눌 수 있는지는 알아보고 여러 단계를 수행하며, 
단계의 우선순위를 바꾸거나 한 번에 작업을 바꾸려는 시도를 하지 말고, 연습을 통해 체득해야 할 필요가 있을 것 같다. 
```

# 2.2 두 개의 모자

# 2.3 리팩터링하는 이유

# 2.4 언제 리팩터링해야 할까?

# 2.5 리팩터링 시 고려할 문제

# 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

# 2.7 리팩터링과 소프트웨어 개발 프로세스

# 2.8 리팩터링과 성능

# 2.9 리팩터링의 유래

# 2.10 리팩터링 자동화

# 2.11 더 알고 싶다면
