리팩터링 전반에 적용되는 원칙 몇 가지를 살펴보자.  

# 2.1 리팩터링 정의
리팩터링은 두루뭉실한 의미를 다 포괄하지 말고, 구체적으로 엄격하게 정의해야 유용하다.  
리팩터링은 명사, 동사 두 가지 용어로 쓸 수 있다.  
1. 리팩터링(명사): 소프트웨어 겉보기 동작은 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
   - 앞 장에서 나온 '함수 추출하기', '조건부 로직을 다형성으로 바꾸기' 등이 해당한다.
2. 리팩터링(동사): 소프트웨어 겉보기 동작은 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
  
대부분의 개발자는 코드 정리 작업을 모조리 '리팩터링'이라고 표현한다.  
그러나 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.  
  
리팩터링은 결국 기존 동작을 보장한 채, 여러 단계들을 순차적으로 거쳐 코드를 수정하여 큰 변화를 만들어내는 일이다.  
리팩터링 대상의 규모는 매우 작을 수도 있고, 작은 단계를 여러 개 합친 모습일 수도 있다.  
  
중요한 것은 기존 동작을 보장하기 때문에, 리팩터링 중간에 동작을 얼마든지 멈출 수 있다.  
만약 "리팩터링 중 코드가 꺠져 며칠이나 고생했다."라고 한다면, 리팩터링을 한 것이 아니다.  
  
저자는 코드베이스 정리 또는 구조 변경하는 모든 작업을 '재구성'이라는 포괄적인 의미로 표현하고,  
재구성 중 특수한 형태를 '리팩터링'이라 본다.  
  
한 번에 변경 가능한 작업을 여러 단계로 분리해 작업한다면 오히려 비효율적이라고 느낄 수 있다.  
하지만 오히려 작은 작업도 단계를 분리해 오히려 작업을 더 효율적으로 처리 할 수 있다.  
  
리팩터링을 통해 내부 구조나 성능적으로 미세한 변화가 있다고 해도, 이용하거나 사용하는 관점에서 변화가 없어야 한다.  
리팩터링 기법 단계 중 '함수 선언 바꾸기', '함수 옮기기' 작업 중 발견한 버그는 리팩터링 후에도 남아있어야 한다. (단, 아무도 발견 못한 숨은 버그는 수정 가능)  
즉 여러 단계로 나눈 이상, 그 단계에 집중하여 수행해야 한다는 것 같다.  
  
리팩터링은 성능 최적화와 결이 비슷하다. 단지 목적이 다르다.  
코드를 변경하지만, 외부 기능은 그대로 유지한다.  
리팩터링의 목적은 코드를 이해, 수정을 쉽게하는 것이다.  

```text
내 의견

책에서 나온 리팩터링을 너무 포괄적인 용어로 쓰는 개발자 중 한 사람이었던 것 같다.
결과적으로 기능을 유지한 채, 같이 협업하는 개발자가 코드를 읽기 원활하고, 변경에 대응 가능하도록 생각하고 '리팩터링' 한다고 표현했다.
하지만 리팩터링 기법이나 여러 단계를 나눠 할 생각은 내포하지 않았었다. 
그렇기 때문에 당연히 리팩터링 중 작업을 멈췄을 때, 기능 유지를 보장하지 않았다. 작업을 끝 마쳐야 기능 동작이 유지 됐다.
그렇다면 내가 이러한 생각으로 코드를 수정한 것은 단순히 '코드 수정'이라고 표현하는게 맞을까? 

어쨋든 리팩터링을 너무 포괄적으로 사용하지 말고, 최소한 어떤 기법과 어떻게 단계를 나눌 수 있는지는 알아보고 여러 단계를 수행하며, 
단계의 우선순위를 바꾸거나 한 번에 작업을 바꾸려는 시도를 하지 말고, 연습을 통해 체득해야 할 필요가 있을 것 같다. 
```

# 2.2 두 개의 모자
저자는 SW 개발 시, 목적을 나눈다.
1. 기능 추가 목적
2. 리팩터링 목적
  
두 단계를 명확히 구분해 작업하는데, 켄트 벡은 이를 두 개의 모자에 비유했다.  
기능 추가시 기존 코드는 절대 건드리지 않고 새 기능을 추가하고, 진척도는 테스트 추가 후 통과를 기준으로 측정한다.  
리팩터링시 기능 추가는 절대 하지 않고, 오로지 '코드 재구성'에만 전념한다. 테스트도 새로 만들지 않지만, 부득이하게 인터페이스 변경시에만 기존 테스트를 수정한다.  
  
저자는 SW 개발 시, 두 모자를 자주 바꿔쓴다.  
코드 추가시 기존 코드 변경 후 작업이 원활할 때가 자주 생긴다.  
따라서 기능 추가 중, 모자를 바꿔 써 코드 재구성 완료 후 다시 기능 추가를 마무리 한다.  
기능 추가 완료 후 코드를 살펴보며 리팩터링 할 지를 판단하고 진행한다.  
중요한 점은 작은 작업일지라도, 어떤 모자를 썼는지 정확히 인지하고 진행해야 한다.  

```text
내 의견

이번 챕터는 짧지만 자서전 같은 느낌이 있어서 좋았다.
즉, 뭔가 대강 알고는 있지만 실행하지 못한 부분들을 이번에 읽으면서 앞으로 실행하면서 도움이 될 것 같다.
책에 나온 두 가지 모자를 바꿔 가며 비슷하게 진행한 적은 있지만, 명확히 구분하여 진행하지는 않았었다. 
두가지 모자를 반쯤 걸친채, 기능 추가시에도 기존 구조를 변경하고, 리팩터링 중간에도 유틸리티 생성 등 번갈아가면서 했던 것 같다.
결과적으로? 비슷할지 몰라도, 명확히 구분하여 진행한다면 미묘한 차이가 있을 것이라고 예상된다.
기능 추가, 리팩터링 두 가지 모자를 명확히 구분하여 진행하는 것을 목표로 삼아야 겠다.

```

# 2.3 리팩터링하는 이유
리팩터링은 모든 문제점을 모두 해결하는 만병통치약이 아니다.  
다만 건강한 코드 상태를 유지하는데 필요한 약임은 분명하다.  
리팩터링을 다양하게 활용할 수 있고, 반드시 그래야 한다.  

- 리팩터링하면 소프트웨어 설계가 좋아진다.
리팩터링 없이 진행하고 세월이 지난 프로젝트는 내부 설계(아키텍처)가 썩기 쉽다.  
아키텍처의 이해없이 단기 목표만을 바라본다면 기반 구조가 무너진다.  
그러면 당연하게 다른 개발자가 프로젝트를 이해하거나 코드만 봐서 설계를 파악하기도 어렵다.  
  
내부 설계, 기반 구조가 무너지면 악순환이 시작된다.  
코드만으로 설계, 의도를 파악하기 어렵고 부패는 가속도가 붙는다.  
반면 규칙적인 리팩터링은 코드 구조를 지탱해준다.  
  
설계가 나쁘면 보통 코드가 길어지게 된다.
중복 코드 제거는 설계 개선 작업의 중요한 축을 차지한다.  
중복 코드 중 하나를 변경했을 때, 예상대로 동작하지 않을 수도 있다.  
따라서 중복 코드 제거를 통해 변경이 있을 때도 동일한 수행을 보장할 수 있으므로 바람직한 설계의 핵심이다.  
  
코드량을 줄인다고 껍데기가 좋아지는 것은 아니다. 하지만 내부적으로 변경에 대응하거나 신규 개발을 할 때 드는 노력은 크게 달라진다.  
코드가 길수록 실수 가능성이 높아지고 이해해야 하는 범위도 늘어난다.  
  
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
프로그래밍은 컴퓨터와 대화하는 것과 비슷하지만, 사실은 컴퓨터보다 사람이 가장 중요하면서도 소홀하기 쉽다.  
누군가가 짜놓은 코드를 다른 사람이 봤을 때, 코드를 이해하면 1시간이 걸릴 일을 3시간, 또는 그 이상이 걸릴 수도 있다.  
즉 기능의 동작만을 바라본다면 그 코드를 다루 개발자를 배려하지 못한다.  
단지 다른 사람을 배려하기 위해 리팩터링 하는 것은 아니다. 본인을 위해서도 중요하다.  
  
저자는 코드를 기억하지 않는다고 한다. 왜냐하면 코드를 보면 알 수 있는 것 들을 기억용량 초과 시키는 데 보태지 않는다.  
다만 기억할 필요가 있는 것들을 최대한 코드에 담으려 한다.  
(???) 어쨋든 기억할 노력을 들이는 코드 말고, 리팩터링으 통해 코드만 봤을 때 의도가 드러나는 코드를 짜야된다는 것 같다.  

- 리팩터링하면 버그를 쉽게 찾을 수 있다.
코드에 의도가 드러난다면 버그도 쉽게 찾을 수 있다. 다시말해, 어려운 코드나 설계는 버그 찾기도 어렵다.  
켄트백 "난 뛰어난 프로그래머가 아니예요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이예요."  
리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.  
  
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.
간혹 리팩터링은 시간이 드는 작업이니, 전체 개발 속도가 떨어지지 않을까 하는 우려가 있을 수 있다.  
리팩터링이 없거나 프로젝트 규모가 매우 커졌다면, 새 기능을 추가하는 데 훨씬 오래 걸리게 된다.  
다시말해, 리팩터링도 없고 프로젝트 규모도 매우 크다면, 안정성도 보장 못 하고 훨씬 작업 속도는 느려지게 된다.  
왜냐하면 새로운 기능을 기존의 코드베이스에 잘 녹여낼 방법을 찾는 시간도 걸리고, 버그 발생률도 늘고, 해결하는 시간이 한층 더 걸린다.  
나중되면 고대 유적 발굴만큼 새 기능이나 변경이 어려워진다. 그리고 어느 시점이 되면 차라리 처음부터 새로 개발하는 편이 낫겠다는 경제이 이른다.  
  
개발 인원 수와 생산성에 대해 여러 객관적인 지표가 있지만, 어쨋든 나쁜 설계로 시작한다면 기능에 비해 시간이 많이 들어가갸 된다.  
반면 좋은 설계는 초기에는 다소 느릴지 몰라도, 시간이 지나면서 기능 추가에 일정한 시간이 동일하게 들어간다.  
  
나쁜 설계와 좋은 설계의 차이는 SW 내부 품질에 있다.  
좋은 설계는 신규 기능 추가 지점을 더욱 적재적소에 찾기 수월하고, 어떻게 고칠지를 쉽게 찾을 수 있다.  
나쁜 설계는 모듈 중 많은 부분을 같이 봐야 하지만, 좋은 설계는 전체 코드베이스 중 작은 일부만 이해하거나 찾으면 된다.  
  
결론적으로 좋은 설계와 코드 구축은 프로젝트를 더욱 견고하게 만든다.  
  
20년 전 만해도 설계를 잘 하려면 코딩 시작 전 설계부터 완벽히 마쳐야 한다는 것이 정설이었다.  
그러나 처음부터 좋은 설계는 나오기 어렵다. 그리고 얼마든지 리팩터링을 통해 좋은 설계, 좋은 코드들을 유지할 수 있다.  
즉, 반드시 리팩터링은 필요하다.

```text
내 의견

경력이 쌓이면서 내용 자체는 모두 공감을 하고 이해 할 것이다.
그런데 좋은 설계와 좋은 코드 구축, 코드만으로 다른 개발자가 이해할 수 있게 환경을 만드는 것은 어느 정도 역량이 필요한 것 같다.
개발자마다 모두 의견과 생각이 다르고, 모든 의견과 생각을 적절히 취합해 우리 프로젝트에 녹여야 하는데, 
그 방향성이 좋은 설계, 좋은 코드 구축을 공감하는 것과는 별개로 멀어지는 경우가 있다.
개발에 대한 아키텍처, 클린 코드, 좋은 코드, 설계 등 어느 정도 학습량이 있어야 의견 충돌이 있어도 좋은 설계, 좋은 코드 방향으로 점진적 개선이 되는 것 같다.
모두가 학습이 되어 있다면 토론 시간이 줄어 방향성을 잡는데 시간이 많이 들지 않겠지만, 일부만 학습이 되어 있다고 하더라도 그 일부의 학습을 다른 개발자에게 전파하여 설득시키는 것도 중요한 것 같다.

처음부터 좋은 설계는 나올 수 없다. 
너무 많은 시간을 할애할 필요는 없다. 
다만 변경에 대한 대응이 수월하고, 어느 정도의 요구사항을 수용할 수 있는 정도의 틀이어도 좋다.
리팩토링은 선택이 아니라, 필수라는 가정하에서 말이다.

```

# 2.4 언제 리팩터링해야 할까?
- 저자가 리팩토링을 하며 작업 흐름에 리팩터링을 녹이는 여러 방법
  - 3의 법칙
  1. 처음에는 그냥 한다.
  2. 중복이 생겨도, 일단 계속 진행한다.
  3. 중복 세 번이 생기면 리팩터링한다.
  
- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
신규 기능 개발 전 리팩터링이 가장 좋은 시점이다.  
관련된 코드들을 살펴보며, 구조 조정 등을 하면서 진행한다.  
함수 안에 리터럴 값 몇 개가 방해될 수도 있다.  
동일한 함수를 만들어 리터럴 값만 바꿔도 되지만, 중복적인 부분이 거슬리게 된다.  
리터럴이 조금 다른 함수 두 개가 중복적으로 생기면, 요구사항 변경으로 인한 관리 포인트가 늘어나고, 중복된 코드 위치까지 찾아야 한다.  
이런 경우 '리팩터링 모자'로 바꾸고 '함수 매개변수화하기'를 적용한다.  
다른 리터럴을 파라미터화하여, 중복되는 함수를 통일해서 사용 할 수 있다.  
  
"지금 당장 빨리 가려고 하지말고, '잠깐!'을 외쳐 어떤 방법이옳은지 판단을 할 줄 알아야 한다."  
버그도 마찬가지다. 오류 발생 코드가 세 곳에 중복 돼 있다면, 한 곳에 합치는 편이 좋다.  
질의 코드에 섞여 있는 갱신 로직도 분리하면 실타래가 엉킬일 도 없다.  
  
리팩터링에 관심을 쏟을수록 버그가 없는 상태를 오래 유지하고, 다른 버그 가능성도 줄일 수 있다.  
  
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
기존 코드를 수정 할 일이 생긴다면, 먼저 그 코드가 하는 일을 파악해야 한다.  
파악 할 때, 코드 의도를 더 명확하게 리팩터링 할 여지가 없는지 찾아보면서 파악해야 한다.  
예를 들면 조건 부 로직 구조, 함수 이름, 긴 함수 분리 등..  
코드는 복잡할 필요 없다. 머리로 이해한 것을 코드에 담으면 된다. 그리고 테스트 코드를 통해 이해한 것에 대한 증명을 한다.  
단순하지만, 지금은 물론 나중에도 효과를 볼 수 있다.  
  
리팩터링을 통해 깔끔히 정리된 코드는 설계를 눈에 들어오게 해줄 수 있다.  
리팩터링을 하지 않으면 도달하지 못할 곳이 있다.  
  
- 쓰레기 줍기 리팩터링
작업을 위해 코드 파악 중, 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗길 수도 있다.  
그렇다고 악취나는 코드를 방치하는 것도 좋지 않다.  
지금 하려는 작업과 관계 없고, 시간이 조금 걸리는 작업이라면 선 메모 후 하던 일을 끝내고 처리하자.  
이런 상황을 책에서는 "쓰레기 줍"기로 표현한다. (리팩터링 변형)  
  
캠핑 규칙 처럼, "처음 왔을 때 보다 더 깨끗히 정리하고 떠나자"를 항상 기억하자.  
  
리팩터링을 잘 해두면 분리한 여러 단계들이 시간이 꽤 걸리는 상황이 오더라도 한 순간도 코드가 깨질 일이 없다.  
  
- 계획된 리팩터링과 수시로 하는 리팩터링
보통은 리팩터링 일정을 잡지 않고, 기능 추가 또는 버그를 잡으면서 함께 진행한다.  
리팩터링을 프로그래밍의 하나의 과정으로 녹인다. -> if문 작성과 마찬가지다.  
"보기 싫은 코드는 발견 즉시 리팩터링 하고, 잘 작성된 코드도 리팩터링 대상이 될 수 있다는 점을 간과하지말자."  
  
어제 적합했던 작업이, 추가되는 다른 작업에는 맞지 않을 수 있다.  
개발 할 때 적절한 타협이 필요하다.  
- 로직 내 변수들을 파라미터화
- 개별 함수로 나누는 기준
단순하게 속도에 초점을 두지 않고, 개발 완료함에 있어 적절한 타협을 하며 개발을 하게 된다면,  
코드는 깔끔하게 정리가 되고, 리팩터링하기 쉬워진다.  
  
수정을 하고자 할 땐, 수정하기 쉽게 정돈을 먼저 한다.  
개발이란 단순히 기능을 추가하는 과정이 아니다.  
새 기능을 추가하기 쉽게 코드를 수정하는 것도 중요하다.  
  
리팩터링에 투자한 시간이 더 큰 시간을 아낄 수 있다.  
버전 관리 시스템에서 커밋 할 때 '리팩터링'과 '기능 개발'을 분리해야 할까?  
저자는 완전 동의는 하지 않는다.  
리팩터링은 기능 추가와 밀접하게 엮인 경우가 많기 때문에 분리 자체가 낭비일 수 있다.  
  
- 오래 걸리는 리팩터링
팀 전체가 달려 들어도 기간이 걸리는 대규모 리팩터링도 있다.  
예를 들면 라이브러리 교체, 코드를 컴포넌트로 빼는 작업 등  
저자는 팀 전체가 리팩터링에 매달리는 것에는 회의적이다.  
주어진 문제를 점진적인으로 해결하는 편이 효과적일 때가 많다.  
  
라이브러리 교체 할 땐 기존, 신규 모듀 포괄하는 추상 인터페이스부터 마련한다. (추상화 갈아타기)  
  
- 코드 리뷰에 리팩터링 활용하기
개발팀 전체에 지식 전파와 다양한 측면을 이해하고 토론하기 좋다.  
리팩터링은 코드 리뷰 결과를 더 구체적으로 도출하는 데 도움된다.  
저자는 코드 작성자와 나란히 앉아 코드 훑어가며 리팩터링 하는 것이 가장 좋은 방법이라고 한다.  
  
- 관리자에게는 뭐라고 말해야 할까?
가치 없는 작업이라고 오해하고 있는 조직도 있다.  
리팩터링 과정이 길어질수록 오해는 커진다.  
대다수 관리자는 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다.  
이런 경우 리팩터링한다고 말 하지 않는 것도 방법이다.  
  
- 리팩터링하지 말아야 할 때
지저분한 코드가 있어도 굳이 수정 할 필요가 없다면 리팩터링 하지 않는다.  
외부 API 다루듯 호출해서 쓰는 코드도 마찬가지다.
리팩터링 보다 새로 개발하는 게 나을 때도 마찬가지다.  
내부 동작을 이해해야 할 시점에 리팩터링은 효과적이다.  

```text
내 의견

리팩터링이 필요한 시점은 기능 개발을 들어가기 전이다. 관련된 모든 것들이 신규 구축이지 않는 이상,  
구축된 코드를 리팩터링 요소를 찾아내며 파악한다.  
그리고 가능하다면 개발이 편하도록 리팩터링을 먼저 한 후 신규 개발에 들어간다.  

리팩터링의 목적은 여러가지가 있다.
1. 앞으로 기능 추가를 쉽게 하는 것
2. 협업 하는 개발자가 코드를 읽기 쉽게 하는 것

목적에 맞게 리팩터링 하면 좋다.
리팩터링을 하지 않으면 경험하거나 고민하지 못할 것들을 개발자로서 경험하는 것도 좋은 경험이다.

만약 리팩터링에 많은 시간이 할애되야 할 것 같다면 리팩터링 리스트업 후 하던 작업을 마무리하고 진행한다.
```

# 2.5 리팩터링 시 고려할 문제
저자는 누군가 기술, 도구, 아키텍처 등을 내세울 때, 항상 문제점을 찾는다.  


```text
내 의견

```


# 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

# 2.7 리팩터링과 소프트웨어 개발 프로세스

# 2.8 리팩터링과 성능

# 2.9 리팩터링의 유래

# 2.10 리팩터링 자동화

# 2.11 더 알고 싶다면
