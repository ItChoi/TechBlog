리팩터링 전반에 적용되는 원칙 몇 가지를 살펴보자.  

# 2.1 리팩터링 정의
리팩터링은 두루뭉실한 의미를 다 포괄하지 말고, 구체적으로 엄격하게 정의해야 유용하다.  
리팩터링은 명사, 동사 두 가지 용어로 쓸 수 있다.  
1. 리팩터링(명사): 소프트웨어 겉보기 동작은 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
   - 앞 장에서 나온 '함수 추출하기', '조건부 로직을 다형성으로 바꾸기' 등이 해당한다.
2. 리팩터링(동사): 소프트웨어 겉보기 동작은 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
  
대부분의 개발자는 코드 정리 작업을 모조리 '리팩터링'이라고 표현한다.  
그러나 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.  
  
리팩터링은 결국 기존 동작을 보장한 채, 여러 단계들을 순차적으로 거쳐 코드를 수정하여 큰 변화를 만들어내는 일이다.  
리팩터링 대상의 규모는 매우 작을 수도 있고, 작은 단계를 여러 개 합친 모습일 수도 있다.  
  
중요한 것은 기존 동작을 보장하기 때문에, 리팩터링 중간에 동작을 얼마든지 멈출 수 있다.  
만약 "리팩터링 중 코드가 꺠져 며칠이나 고생했다."라고 한다면, 리팩터링을 한 것이 아니다.  
  
저자는 코드베이스 정리 또는 구조 변경하는 모든 작업을 '재구성'이라는 포괄적인 의미로 표현하고,  
재구성 중 특수한 형태를 '리팩터링'이라 본다.  
  
한 번에 변경 가능한 작업을 여러 단계로 분리해 작업한다면 오히려 비효율적이라고 느낄 수 있다.  
하지만 오히려 작은 작업도 단계를 분리해 오히려 작업을 더 효율적으로 처리 할 수 있다.  
  
리팩터링을 통해 내부 구조나 성능적으로 미세한 변화가 있다고 해도, 이용하거나 사용하는 관점에서 변화가 없어야 한다.  
리팩터링 기법 단계 중 '함수 선언 바꾸기', '함수 옮기기' 작업 중 발견한 버그는 리팩터링 후에도 남아있어야 한다. (단, 아무도 발견 못한 숨은 버그는 수정 가능)  
즉 여러 단계로 나눈 이상, 그 단계에 집중하여 수행해야 한다는 것 같다.  
  
리팩터링은 성능 최적화와 결이 비슷하다. 단지 목적이 다르다.  
코드를 변경하지만, 외부 기능은 그대로 유지한다.  
리팩터링의 목적은 코드를 이해, 수정을 쉽게하는 것이다.  

```text
내 의견

책에서 나온 리팩터링을 너무 포괄적인 용어로 쓰는 개발자 중 한 사람이었던 것 같다.
결과적으로 기능을 유지한 채, 같이 협업하는 개발자가 코드를 읽기 원활하고, 변경에 대응 가능하도록 생각하고 '리팩터링' 한다고 표현했다.
하지만 리팩터링 기법이나 여러 단계를 나눠 할 생각은 내포하지 않았었다. 
그렇기 때문에 당연히 리팩터링 중 작업을 멈췄을 때, 기능 유지를 보장하지 않았다. 작업을 끝 마쳐야 기능 동작이 유지 됐다.
그렇다면 내가 이러한 생각으로 코드를 수정한 것은 단순히 '코드 수정'이라고 표현하는게 맞을까? 

어쨋든 리팩터링을 너무 포괄적으로 사용하지 말고, 최소한 어떤 기법과 어떻게 단계를 나눌 수 있는지는 알아보고 여러 단계를 수행하며, 
단계의 우선순위를 바꾸거나 한 번에 작업을 바꾸려는 시도를 하지 말고, 연습을 통해 체득해야 할 필요가 있을 것 같다. 
```

# 2.2 두 개의 모자
저자는 SW 개발 시, 목적을 나눈다.
1. 기능 추가 목적
2. 리팩터링 목적
  
두 단계를 명확히 구분해 작업하는데, 켄트 벡은 이를 두 개의 모자에 비유했다.  
기능 추가시 기존 코드는 절대 건드리지 않고 새 기능을 추가하고, 진척도는 테스트 추가 후 통과를 기준으로 측정한다.  
리팩터링시 기능 추가는 절대 하지 않고, 오로지 '코드 재구성'에만 전념한다. 테스트도 새로 만들지 않지만, 부득이하게 인터페이스 변경시에만 기존 테스트를 수정한다.  
  
저자는 SW 개발 시, 두 모자를 자주 바꿔쓴다.  
코드 추가시 기존 코드 변경 후 작업이 원활할 때가 자주 생긴다.  
따라서 기능 추가 중, 모자를 바꿔 써 코드 재구성 완료 후 다시 기능 추가를 마무리 한다.  
기능 추가 완료 후 코드를 살펴보며 리팩터링 할 지를 판단하고 진행한다.  
중요한 점은 작은 작업일지라도, 어떤 모자를 썼는지 정확히 인지하고 진행해야 한다.  

```text
내 의견

이번 챕터는 짧지만 자서전 같은 느낌이 있어서 좋았다.
즉, 뭔가 대강 알고는 있지만 실행하지 못한 부분들을 이번에 읽으면서 앞으로 실행하면서 도움이 될 것 같다.
책에 나온 두 가지 모자를 바꿔 가며 비슷하게 진행한 적은 있지만, 명확히 구분하여 진행하지는 않았었다. 
두가지 모자를 반쯤 걸친채, 기능 추가시에도 기존 구조를 변경하고, 리팩터링 중간에도 유틸리티 생성 등 번갈아가면서 했던 것 같다.
결과적으로? 비슷할지 몰라도, 명확히 구분하여 진행한다면 미묘한 차이가 있을 것이라고 예상된다.
기능 추가, 리팩터링 두 가지 모자를 명확히 구분하여 진행하는 것을 목표로 삼아야 겠다.

```

# 2.3 리팩터링하는 이유
리팩터링은 모든 문제점을 모두 해결하는 만병통치약이 아니다.  
다만 건강한 코드 상태를 유지하는데 필요한 약임은 분명하다.  
리팩터링을 다양하게 활용할 수 있고, 반드시 그래야 한다.  

- 리팩터링하면 소프트웨어 설계가 좋아진다.
리팩터링 없이 진행하고 세월이 지난 프로젝트는 내부 설계(아키텍처)가 썩기 쉽다.  
아키텍처의 이해없이 단기 목표만을 바라본다면 기반 구조가 무너진다.  
그러면 당연하게 다른 개발자가 프로젝트를 이해하거나 코드만 봐서 설계를 파악하기도 어렵다.  
  
내부 설계, 기반 구조가 무너지면 악순환이 시작된다.  
코드만으로 설계, 의도를 파악하기 어렵고 부패는 가속도가 붙는다.  
반면 규칙적인 리팩터링은 코드 구조를 지탱해준다.  
  
설계가 나쁘면 보통 코드가 길어지게 된다.
중복 코드 제거는 설계 개선 작업의 중요한 축을 차지한다.  
중복 코드 중 하나를 변경했을 때, 예상대로 동작하지 않을 수도 있다.  
따라서 중복 코드 제거를 통해 변경이 있을 때도 동일한 수행을 보장할 수 있으므로 바람직한 설계의 핵심이다.  
  
코드량을 줄인다고 껍데기가 좋아지는 것은 아니다. 하지만 내부적으로 변경에 대응하거나 신규 개발을 할 때 드는 노력은 크게 달라진다.  
코드가 길수록 실수 가능성이 높아지고 이해해야 하는 범위도 늘어난다.  
  
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
프로그래밍은 컴퓨터와 대화하는 것과 비슷하지만, 사실은 컴퓨터보다 사람이 가장 중요하면서도 소홀하기 쉽다.  
누군가가 짜놓은 코드를 다른 사람이 봤을 때, 코드를 이해하면 1시간이 걸릴 일을 3시간, 또는 그 이상이 걸릴 수도 있다.  
즉 기능의 동작만을 바라본다면 그 코드를 다루 개발자를 배려하지 못한다.  
단지 다른 사람을 배려하기 위해 리팩터링 하는 것은 아니다. 본인을 위해서도 중요하다.  
  
저자는 코드를 기억하지 않는다고 한다. 왜냐하면 코드를 보면 알 수 있는 것 들을 기억용량 초과 시키는 데 보태지 않는다.  
다만 기억할 필요가 있는 것들을 최대한 코드에 담으려 한다.  
(???) 어쨋든 기억할 노력을 들이는 코드 말고, 리팩터링으 통해 코드만 봤을 때 의도가 드러나는 코드를 짜야된다는 것 같다.  

- 리팩터링하면 버그를 쉽게 찾을 수 있다.
코드에 의도가 드러난다면 버그도 쉽게 찾을 수 있다. 다시말해, 어려운 코드나 설계는 버그 찾기도 어렵다.  
켄트백 "난 뛰어난 프로그래머가 아니예요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이예요."  
리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.  
  
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.
간혹 리팩터링은 시간이 드는 작업이니, 전체 개발 속도가 떨어지지 않을까 하는 우려가 있을 수 있다.  
리팩터링이 없거나 프로젝트 규모가 매우 커졌다면, 새 기능을 추가하는 데 훨씬 오래 걸리게 된다.  
다시말해, 리팩터링도 없고 프로젝트 규모도 매우 크다면, 안정성도 보장 못 하고 훨씬 작업 속도는 느려지게 된다.  
왜냐하면 새로운 기능을 기존의 코드베이스에 잘 녹여낼 방법을 찾는 시간도 걸리고, 버그 발생률도 늘고, 해결하는 시간이 한층 더 걸린다.  
나중되면 고대 유적 발굴만큼 새 기능이나 변경이 어려워진다. 그리고 어느 시점이 되면 차라리 처음부터 새로 개발하는 편이 낫겠다는 경제이 이른다.  
  
개발 인원 수와 생산성에 대해 여러 객관적인 지표가 있지만, 어쨋든 나쁜 설계로 시작한다면 기능에 비해 시간이 많이 들어가갸 된다.  
반면 좋은 설계는 초기에는 다소 느릴지 몰라도, 시간이 지나면서 기능 추가에 일정한 시간이 동일하게 들어간다.  
  
나쁜 설계와 좋은 설계의 차이는 SW 내부 품질에 있다.  
좋은 설계는 신규 기능 추가 지점을 더욱 적재적소에 찾기 수월하고, 어떻게 고칠지를 쉽게 찾을 수 있다.  
나쁜 설계는 모듈 중 많은 부분을 같이 봐야 하지만, 좋은 설계는 전체 코드베이스 중 작은 일부만 이해하거나 찾으면 된다.  
  
결론적으로 좋은 설계와 코드 구축은 프로젝트를 더욱 견고하게 만든다.  
  
20년 전 만해도 설계를 잘 하려면 코딩 시작 전 설계부터 완벽히 마쳐야 한다는 것이 정설이었다.  
그러나 처음부터 좋은 설계는 나오기 어렵다. 그리고 얼마든지 리팩터링을 통해 좋은 설계, 좋은 코드들을 유지할 수 있다.  
즉, 반드시 리팩터링은 필요하다.

```text
내 의견

경력이 쌓이면서 내용 자체는 모두 공감을 하고 이해 할 것이다.
그런데 좋은 설계와 좋은 코드 구축, 코드만으로 다른 개발자가 이해할 수 있게 환경을 만드는 것은 어느 정도 역량이 필요한 것 같다.
개발자마다 모두 의견과 생각이 다르고, 모든 의견과 생각을 적절히 취합해 우리 프로젝트에 녹여야 하는데, 
그 방향성이 좋은 설계, 좋은 코드 구축을 공감하는 것과는 별개로 멀어지는 경우가 있다.
개발에 대한 아키텍처, 클린 코드, 좋은 코드, 설계 등 어느 정도 학습량이 있어야 의견 충돌이 있어도 좋은 설계, 좋은 코드 방향으로 점진적 개선이 되는 것 같다.
모두가 학습이 되어 있다면 토론 시간이 줄어 방향성을 잡는데 시간이 많이 들지 않겠지만, 일부만 학습이 되어 있다고 하더라도 그 일부의 학습을 다른 개발자에게 전파하여 설득시키는 것도 중요한 것 같다.

처음부터 좋은 설계는 나올 수 없다. 
너무 많은 시간을 할애할 필요는 없다. 
다만 변경에 대한 대응이 수월하고, 어느 정도의 요구사항을 수용할 수 있는 정도의 틀이어도 좋다.
리팩토링은 선택이 아니라, 필수라는 가정하에서 말이다.

```


# 2.4 언제 리팩터링해야 할까?

# 2.5 리팩터링 시 고려할 문제

# 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

# 2.7 리팩터링과 소프트웨어 개발 프로세스

# 2.8 리팩터링과 성능

# 2.9 리팩터링의 유래

# 2.10 리팩터링 자동화

# 2.11 더 알고 싶다면
