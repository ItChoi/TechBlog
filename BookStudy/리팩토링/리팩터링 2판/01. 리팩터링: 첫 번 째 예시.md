리팩터링의 역사와 원칙을 나열할 수도 있지만, 원칙은 지나치게 일반화되기 쉽다.  
따라서 실제 적용 방법 파악이 어렵다.  
그러나 예시가 있으면 모든게 명확해진다.  
책에서 코드 예시를 복잡하게 들어 페이지 수가 길거나, 너무 단순해서는 안 된다.  
중요한 것은 예시 하나하나가 실제 상용 소프트웨어에서 존재하는 예시라고 가정을 해야한다.  

# 1.1 자, 시작해보자!
첫 번 째 예시는 다음과 같다.  
- 다양한 연극을 외주로 받아 공연하는 극단
- 공연 요청이 들어오면 '장르(비극, 희극)', '관객 규모'를 기초로 비용 책정
- 공연료와 별개로 포인트 지급

코드 정보는 다음과 같다.
- 공연할 연극 정보 JSON 파일 저장
  - 공연 이름, 장르
- 공연료 청구서 데이터 JSON 파일 저장
  - 고객명, 공연 정보(공연, 관객)
- 공연료 청구서 출력 간단 함수 존재
  - 파라미터(2)로 모든 공연 정보를 받는다.
  - 파라미터(1)(고객 정보?)을 통해 특정 공연 정보를 추출해 파라미터(2)에서 하나를 꺼내온다.
  - switch case문 사용해 분기 로직 처리
  - 포인트 적립
  - 희극 장르에 한해서 특정 인원수 만큼 추가 포인트 제공
  - 청구 내역 출력

```text 
- 내 생각
1. 스위치 케이스문 제거
2. 타입에 따른 분기 처리 로직, 메서드로 추출해 파라미터를 이용해 처리
3. 포인트 적립 및 추가 로직 메서드 추출
4. 청구 내역 출력 메서드 추출
```

# 1.2 예시 프로그램을 본 소감
그럭 저럭 쓸만한 코드로써, 짧은 코드에 이해에도 어려움이 없다.  
프로그램 코드가 지저분하다고 불평하는 것은 구조를 너무 미적인 기준으로 판단하는걸까?  
컴파일러에게는 영향이 없을 뿐더러 잘 동작하는 상황에서도 말이다.  
하지만 개인이 아닌 협업을 하는 순간 미적 상태에 민감하게 된다.  
설계가 나쁘면 수정하기도 어렵다.  
사이드 이펙이 있는 곳을 모두 찾아야 하고, 테스트 코드 또한 필수가 된다. 그럼에도 버그 가능성이 생긴다.  
수백 줄 짜리 코드 수정시, 먼저 프로그램 작동 방식 파악이 수월하도록 코드를 여러 메소드와 프로그램 요소로 재구성한다.  
구조가 빈약하다면 대체로 구조를 바로 잡은 후 기능 수정을 하는 편이 훨씬 수월하다.  
  
즉 새로운 기능을 추가하기에 편한 구조가 아니라면, 기능 추가하기 쉬운 형태로 먼저 리팩터링 하고 기능을 추가한다.  
  
1.1 예시에서 수정할 포인트 몇 개를 발견했다.  
1. 청구 내역 HTML 출력 기능
   - 이 변경이 어느 부분에 영향을 줄까?
     - html 태그 삽입을 위해 청구 결과에 문자열 추가 -> 해당 함수 복잡도 증가
       - 청구서 작성 로직 변경마다 같이 변경이 일어난다.
2. 장르는 더 다양하게 추가 될 수 있다. 
   - 장르가 추가 될 때 마다 메소드 안에 로직들을 같이 변경해줘야 한다.
  
협업을 하는 경우 다른 사람의 코드가 잘 읽히지 않거나 파악이 어렵다면, 대책을 마련해야 한다.

# 1.3 리팩터링의 첫 단계

# 1.4 statement() 함수 쪼개기

# 1.5 중간 점검: 난무하는 중첩 함수

# 1.6 계산 단계와 포맷팅 단계 분리하기

# 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨

# 1.8 다형성을 활용해 계산 코드 재구성하기

# 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

# 1.10 마치며