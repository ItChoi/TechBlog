리팩터링의 역사와 원칙을 나열할 수도 있지만, 원칙은 지나치게 일반화되기 쉽다.  
따라서 실제 적용 방법 파악이 어렵다.  
그러나 예시가 있으면 모든게 명확해진다.  
책에서 코드 예시를 복잡하게 들어 페이지 수가 길거나, 너무 단순해서는 안 된다.  
중요한 것은 예시 하나하나가 실제 상용 소프트웨어에서 존재하는 예시라고 가정을 해야한다.  

# 1.1 자, 시작해보자!
첫 번 째 예시는 다음과 같다.  
- 다양한 연극을 외주로 받아 공연하는 극단
- 공연 요청이 들어오면 '장르(비극, 희극)', '관객 규모'를 기초로 비용 책정
- 공연료와 별개로 포인트 지급

코드 정보는 다음과 같다.
- 공연할 연극 정보 JSON 파일 저장
  - 공연 이름, 장르
- 공연료 청구서 데이터 JSON 파일 저장
  - 고객명, 공연 정보(공연, 관객)
- 공연료 청구서 출력 간단 함수 존재
  - 파라미터(2)로 모든 공연 정보를 받는다.
  - 파라미터(1)(고객 정보?)을 통해 특정 공연 정보를 추출해 파라미터(2)에서 하나를 꺼내온다.
  - switch case문 사용해 분기 로직 처리
  - 포인트 적립
  - 희극 장르에 한해서 특정 인원수 만큼 추가 포인트 제공
  - 청구 내역 출력

```text 
- 내 생각
1. 스위치 케이스문 제거
2. 타입에 따른 분기 처리 로직, 메서드로 추출해 파라미터를 이용해 처리
3. 포인트 적립 및 추가 로직 메서드 추출
4. 청구 내역 출력 메서드 추출
```

# 1.2 예시 프로그램을 본 소감
그럭 저럭 쓸만한 코드로써, 짧은 코드에 이해에도 어려움이 없다.  
프로그램 코드가 지저분하다고 불평하는 것은 구조를 너무 미적인 기준으로 판단하는걸까?  
컴파일러에게는 영향이 없을 뿐더러 잘 동작하는 상황에서도 말이다.  
하지만 개인이 아닌 협업을 하는 순간 미적 상태에 민감하게 된다.  
설계가 나쁘면 수정하기도 어렵다.  
사이드 이펙이 있는 곳을 모두 찾아야 하고, 테스트 코드 또한 필수가 된다. 그럼에도 버그 가능성이 생긴다.  
수백 줄 짜리 코드 수정시, 먼저 프로그램 작동 방식 파악이 수월하도록 코드를 여러 메소드와 프로그램 요소로 재구성한다.  
구조가 빈약하다면 대체로 구조를 바로 잡은 후 기능 수정을 하는 편이 훨씬 수월하다.  
  
즉 새로운 기능을 추가하기에 편한 구조가 아니라면, 기능 추가하기 쉬운 형태로 먼저 리팩터링 하고 기능을 추가한다.  
  
1.1 예시에서 수정할 포인트 몇 개를 발견했다.  
1. 청구 내역 HTML 출력 기능
   - 이 변경이 어느 부분에 영향을 줄까?
     - html 태그 삽입을 위해 청구 결과에 문자열 추가 -> 해당 함수 복잡도 증가
       - 청구서 작성 로직 변경마다 같이 변경이 일어난다.
2. 장르는 더 다양하게 추가 될 수 있다. 
   - 장르가 추가 될 때 마다 메소드 안에 로직들을 같이 변경해줘야 한다.
  
협업을 하는 경우 다른 사람의 코드가 잘 읽히지 않거나 파악이 어렵다면, 대책을 마련해야 한다.

# 1.3 리팩터링의 첫 단계
리팩터링의 첫 단계는 항상 테스트 코드를 마련하는 것이다.  
테스트 역할은 굉장히 중요하다.  
리팩토링 기법들은 버그 발생 여지를 최소화하도록 구성됐다.  
하지만 실제 기법을 이용한 작업은 사람이 한다. 리팩토링에 자신감과 적극성을 얻으려면 테스트 코드가 반드시 수반되어야 한다.  
프로그램이 크거나, 확장 가능성이 있거나, 기타 등등의 사유로 예상치 못한 문제가 있을 수 있다.
  
테스트를 보고하는 방식은 미리 정해둔 정답과 일치한다면 통과의 의미로 초록불을 켠다.  
이는 스스로 자가 판단 테스트를 가능하게 해준다.  
자가 진단 테스트는 중요하다. 사람이 일일이 체크하는 수고를 덜어준다.  
  
중요한 것은 리팩토링 전 제대로 된 테스트를 마련하는 것이다.  
그리고 그 테스트는 반드시 자가진단해야 한다.  
  
테스트는 사람의 실수를 보호해주는 '버그 검출기' 역할을 해준다.  

# 1.4 statement() 함수 쪼개기
앞선 예제에서 statement() 처럼 긴 함수를 리팩터링 할 땐, 먼저 전체 동작에서 합리적인 분리 지점을 찾는다.  
예제에서는 swich 문이 가장 눈에 띈다.  
이 switch문은 한 번의 공연에 대한 요금을 계산한다.  
이 정보는 코드를 분석해 알아낸 '정보'이며, 정보는 사람의 기억에서 휘발성이 높다.  
즉, 동일한 분석 시간을 낭비하지 않기 위해 빠르게 코드에 반영해야 한다.  
분리된 코드를 통해 역할을 재빠르게 인식하여 '분석 시간 낭비'를 초래하지 않는다.  
추가할 함수는 파악에 필요한 정보를 녹여낸다. (함수 이름, 파라미터, ...)  
  
함수로 추출시 유효 범위를 벗어나는 변수 등이 있는지 체크해야 한다.
파라미터로 (perf, play.thisAmount) 두 가지를 넘긴다.  
perf, play 두 가지는 추출된 함수에도 필요한 파라미터지만, 변경하지 않기 때문에 파라미터로 넘겨도 된다.  
다만 play 객체 안 thisAmount 필드(play.thisAmount)의 값은 변경한다. 이런 경우 조심해서 다뤄야 한다.  
그리고 함수 안 변경되는 값을 반환한다.  
  
추출한 메서드를 적용하고, 테스트 코드 실행이 필요하다.  
아무리 간단한 수정이라도 변경 후 테스트는 필수다.  
변경이 커지고 나서야 한 번에 테스트하려면, 범위가 넓어져 실마리를 찾는데 시간이 더 걸릴 수 있다.  
따라서 변경의 폭이 좁을 때 테스트를 마치면서 진행하는 것이 리팩터링 절차의 핵심이다.  
  
리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 따라서 버그를 쉽게 발견 가능하고, 가능하게 해야 한다.  
작은 변경의 리팩터링을 마친 후 이를 기준으로 commit한다. 그래야 중간에 문제가 생기더라도 돌아가기 수월하다.  
이러한 자잘한 변경이 의미있는 단위가 됐을 때 push 한다.  
  
리팩터링을 위해 함수 이름을 의미있게 짓는 것도 중요하지만, 내부에 변수명도 마찬가지로 의미 있도록 해야한다.  
예를 들어 thisAmount 변수를 만들어 반환 할 때, 변수명을 result로 바꾸면 쉽게 반환 데이터라는 것을 인지 할 수 있다.  
  
마찬가지로 파라미터의 이름도 명확한 이름을 부여하는 것이 좋다.  
저자는 파라미터 이름에 접두어로 타입 이름을 붙이는데, 역할이 뚜렷하지 않는 파라미터라면 부정 관사(a/an)을 붙인다.  
예를 들면 amountFor(perf) -> amountFor(aPerformance), 이 방식은 켄트 백이 주로 쓴다.  
  
근본적으로 네이밍에 신경을 써야 하는 이유는 컴퓨터가 아닌 다양한 사람의 이해를 위해서다.  
  
**play 변수 제거하기**  
추출한 amountFor()의 파라미터로 aPerformance, play를 받고 있다.  
aPerformance는 루프를 돌며 파라미터로 전달한다.  
하지만 play는 aPerformance에서 얻을 수 있기에 파라미터로 전달 받을 필요가 없다.  
리팩터링시 최대한 play같은 임시 변수를 제거해야 로컬 범위에 존재하는 이름을 줄여 함수 추출 작업의 복잡도를 줄일 수 있다.  
임시 변수를 질의 함수로 바꿔 리팩토링하면 된다.  
즉, aPerformance를 단일 파라미터로 받는 함수를 새로 추출하고, plays 배열에서 원하는 값을 가져 온다.  
예를 들면 playFor(aPerformance를) return plays[aPerformance.id]  
  
즉 amountFor() 함수의 파라미터는 'play'가 아니라 'plays' 배열을 받아 aPerformance를 통해 적합한 데이터를 꺼내 사용하면 된다.  
테스트를 마친 후 '변수 인라힌 하기'를 적용한다.
```javascript
const play = playFor(perf);
left thisAmount = amountFor(perf, play);

// 변수 인라인 하기 적용
left thisAmount = amountFor(perf, playFor(perf));
```
- 예제에서는 playFor(perf).id, playFor(perf).name 등 지속적인 메서드 호출을 발생해 콜스택이 생기게 한다.
  - 여러 번 사용해야 하는 경우 변수 인라인이 아니라, 변수(const play = playFor(perf))로 한 번 꺼내 활용해 쓰는게 좋지 않을까?
  
리팩터링시 기존 amountFor(perf, play)를 둔 채로 새로운 amountFor(aPerformance, plays)를 만들어서  
새로운 함수를 테스트, 커밋 후 기존 함수를 삭제한다. 그리고 다시 한 번 커밋한다.  
리팩터링과 성능의 연관 관계는 뒤에서 살펴보기로 하고, 중요한 것은 제대로 리팩터링된 코드베이스는 성능 개선하기 훨씬 수월하다.  

지역 변수를 제거하면 추출 작업이 수월해진다.  
저자는 그래서 메서드 추출 전 지역 변수부터 제거한다.  
  
play 지역 변수 제거로 인해, 적립 포인트 계산 부분 메서드(volumeCredits) 추출이 수월해진다.  
volumeCredits 메서드는 루프가 돌 때 마다 값이 누적된다.  
최선의 방법은 volumeCreditsFor(aPerformance) 메서드 안에서 계산 결과를 반환하여 누적한다.  
  
**format 변수 제거하기**  
함수 변수를 일반 함수로 변경하는 리팩터링 기법도 있다.  
또한 format 함수명은 충분한 역할을 설명하지 못한다.  
이 함수의 핵심은 화폐 단위로 맞추는 것이다. -> usd(aNumber) 변경  

**volumeCredits 변수 제거하기**  
이 변수는 반복문을 돌며 값을 누적시킨 변수다.  
먼저 반복문 쪼개기로 값이 누적되는 부분을 추출한다.  
반복문을 동일하게 사용하는 다른 용도가 있더라도, 값을 누적하는 반복문만 우선 따로 메소드 내에서 분리한다.  
그리고 반복문 바로 위에 누적시키는 변수를 위치시킨다.  
이처럼 변수와 분리된 반복문을 붙여놓으면, 임시 변수를 질의 함수로 추출하기 수월해진다.  
다만, 반복문을 쪼개서 성능이 느려지지 않을까? 꺼릴 수도 있다.  
이정도 중복의 성능은 차이를 거의 느끼지 못한다. 똑똑한 컴파일러 등은 캐싱 기법 등으로 무장하고 있다.  
  
하지만 '대체로 그렇다'와 '항상 그렇다'는 다르다.  
때로는 리팩터링이 성능에 상당히 영향을 줄 때도 있다.  
그런 경우에도 저자는 리팩터링 한다.  
틀별한 경우가 아니라면 리팩터링으로 인한 성능 문제는 일단 무시하라.  
리팩터링 때문에 성능에 지장이 간다면, 리팩터링 마무리 후 성능을 개선하자.  
- 방금 설명한 작업의 단계
  1. 반복문 쪼개기: 변수 값 누적 반복문 부분 분리
  2. 문장 슬라이드하기: ??
  3. 함수 추출하기: 적립 포인트 계산 부분 별도 함수 추출
  4. 변수 인라인하기
  
저자라고 해도 항상 단계를 잘게 나누진 않는다. 상황이나 복잡도에 따라 단계를 더 작게 나누는 일을 먼저 하고,   
리팩터링 실패 원인을 찾지 못한다면 가장 최근 커밋으로 돌아가서 실패 리팩터링의 단계를 더 작게 나눠 재시도를 한다.  
코드가 복잡할수록 단계를 작게 나누면 작업 속도는 빨라진다.  
변수명에 베스트 네이밍이 있지만, 이미 같은 공간에서 다른 용도로 사용중이라면, 다른 용도를 인라인 할 수 있는지 체크해보고, 없다면 다른 의미의 이름을 붙여준다.  


```text
느낀점

코드를 작성하다 가끔, 파라미터로 받은 변수의 이름과 메소드 안에서 만든 로컬 변수 이름이 겹쳐 애매해지는 부분이 생겼었다.
이렇게 겹친 이름을 어떻게 다른 사람이 봤을 때 혼란스럽지 않을까를 고민한 적이 있는데, 
어쩔 수 없이 파라미터와, 지역 변수로 같은 이름이 존재해야하는 경우도 있지만, 책에서는 play 같은 임시 변수를 제거하여 파라미터에서 없애면서,
혼란 가능성을 사전에 제거하는 것 같다. 
물론 동일한 상황은 아니다. 같이 받아온 파라미터로 다른 파라미터를 찾을 수 있는 경우에, 
불필요한 파라미터를 제거하고 내부 메서드에서 파라미터를 이용해 제거된 파라미터를 대입해서 사용하면 된다.

지역 변수를 제거함에 있어서, 공통적으로 사용하는 변수를 추출해서 지역 변수로 만들기보단, 함수 호출이 여러 번이라도 지역변수를 없애면 장점이 있다.
바로 메소드 추출이 수월해진다. 
예를 들어 play = plays[per.id]를 추출해서, play.id / play.name 등을 활용해 썼는데, 그 후 메소드 추출할 일이 생길 때, 지역 변수(play) 종속성이 생긴다.
따라서 파라미터로 전달하여 사용하곤 했는데, '변수 인라인 적용 하기'를 하면, 지역 변수를 파라미터로 보낼 일이 적어진다.
동일한 함수를 호출해 call stack을 쌓을지, 지역변수를 없애 메서드 추출을 수월하게 할 지 트레이드오프가 필요한 것 같다.
결론적으로 상황에 따라 다르게 적용하면 된다.
즉 굳이 함수로 뺄 필요가 없는 로직들은 공통으로 사용하는 지역 변수로 추출해 사용하고, 사용하다가도 함수 추출할 일이 생기면 지역변수를 제거하고 함수 파라미터를 줄인다.
그리고 애초부터 함수를 추출할 일이 있으면 지역 변수를 만들지 않을 수 있으면 안 만들면 된다.

리팩터링도 성능과 연관이 있다.
반복문의 시간 복잡도나 동일한 반복문을 여러 개 사용하여 내부의 로직들을 다르게 사용하는 경우처럼 성능 영향이 미미한 경우도 있고,
아니면 성능에 정말 큰 영향을 주는 리팩터링도 있을 수 있다.
저자는 모든 경우에 리팩터링을 시도 한다. 
전자의 경우 대부분의 경우 HW 장비 + 컴파일러 기법 등으로 성능 차이를 거의 느끼지 못한다. 단순히 개발자들의 눈에 불편할 수 있을 뿐이다.
후자의 경우에도, 우선 리팩토링 시도 후, 성능에 대한 리팩터링을 재시도 한다. 단계를 별개로 본 것이다.
나는 동일한 반복문의 분리도 사용한 적이 있지만, 되도록 쓰지 않았다. 유의미한 성능은 아니지만 눈에 거슬렸기 때문이다.
그러나 책의 내용으로 인해 이러한 부분도 수용 할 수 있다는 것을 깨닫게 됐다.
왜냐하면 반복문의 분리를 통해 함수 추출이 수월해지고, 제대로된 리팩터링은 오히려 성능을 개선하기 수월해지는 덕분이다.
단순히 나의 편향된 생각으로 무언가를 정해놓지 말자. 책을 통한 개선이든, 깊은 고민을 통해 편향된 생각을 안 갖는 것이 중요한 것 같다. 새로 배운 점도 있지만, 이런 의미에서 좋은 챕터였다. 
```

# 1.5 중간 점검: 난무하는 중첩 함수
리팩토링 결과를 보면 최상위 호출 statement()의 라인 수는 상당히 줄었다.  
출력할 문장 생성하는 작업만 도맡았다.  
결과적으로 역할에 맞게 함수를 분리하면서, 전체 흐름에 대한 가독성이 향상됐다.  

# 1.6 계산 단계와 포맷팅 단계 분리하기
앞선 예제를 통한 리팩터링은 프로그램의 논리적 요소 파악을 위한 코드 구조 보강에 주안점을 두고 했다.  
이는 리팩터링 초기 단계에서 흔히 수행한다.
- 구조 보강
- 기능 변경
  
리팩토링 요소는 중요한 점이 많다.  
예를 들어 복잡하게 얽힌 덩어리를 쪼개는 것, 역할과 책임에 맞는 네이밍 등 여러 중요한 요소가 있다.  
  
예시에 대한 코드 구조 보강 후 statement()의 HTML 버전을 만드는 작업이 있다. (?)  
코드 구조 보강 후 작업을 했을 때, 추가적인 기능에 대해 삽입 위치나 코드 구조를 잡기에 훨씬 수월해졌다.  

**예제 요구사항**  
- statement()에 대응하는 HTML 작성
- 분리된 함수들은 statement() 함수 안 중첩 함수로 들어가 있다.
- 그대로 중복 사용해 HTML을 만들고 싶진 않다.
- 텍스트 버전, HTML 버전 두 가지를 동일 계산 함수 사용하여 만들어야 한다.
  
위에 요구사항을 만족하기 위해서는 다양한 해결책이 있다.  
책에서는 "단계 쪼개기" 방식을 선호한다.  
그래서 statement()의 로직을 여러 단계로 쪼갠다. (책에서는 두 단계로 나눈다.)  
1. 로직에 필요한 데이터 처리
   - 두 단계를 위한 전달 데이터 구조 생성
2. 처리 결과를 text 또는 html로 표현  
즉 두 번 째 단계로 전달할 중간 데이터 구조를 첫 단계에서 생성한다.
  
먼저 2단계(1단계 X)가 될 코드들을 "함수 추출하기"로 뽑아내야 한다.  
```javascript
function statement(invoce, playss) {
    const statementData = {}; // 중간 데이터 구조를 인수로 전달
    return renderPlainText(statementData, invoice, plays); // 본문 전체를 별도 함수로 추출
}

function renderPlainText(invoice, plays) {
    // 기존 statement() 7줄 그대로 적용
}
```
- 위 단계를 거쳐 컴파일 -> 테스트 -> 커밋
- invoice, plays 파라미터를 방금 만든 중간 데이터 구조로 옮긴다.
  - 계산 관련 코드 -> statement()
  - 매개변수로 전달된 데이터만 처리 -> renderPlainText()
  
결국 html 버전, text 버전으로 나뉘면서, 두 단계로 나뉘고, 중간 데이터 함수 호출 인자를 통해 다른 함수의 불필요한 파라미터를 제거 가능하다.  
```text
function statement(invoice, plays) { }
function renderPlainText(data, plays) { }
```
- plays도 마찬가지로 중간 데이터에 저장한다.
- 결국 형식에 맞는 데이터를 뿌려주기 위해 data 파라미터만 전달받아 처리하게 만들 수 있다.
- 기존에 리팩터링했던 함수들도, 다른 것들이 리팩터링되면서 위치가 달라질 수 있고 또 다시 리팩터링 대상이 될 수 있다.
  - 책에서는 '함수 옮기기'
  
반복문을 파이프라인으로 바꾸기 적용  
- for문이 아니라, stream이나, 파이프라인을 사용 (자바로 예를 들면.forEach(), ...)

```text
내 의견

챕터 앞 부분에 강조했던 부분이 '단계 쪼개기'와 '함수 옮기기'다.  
핵심은 단계 쪼개기 같다.  
예를 들면 한 메소드에 여러 책임과 역할 등을 모두 담아두었다면 동료 개발자가와서 코드 분석하기도 힘들 뿐더러,  
추가나 변경에 대응하기 위해서도 더 많은 시간을 쏟을 수 있다.  
따라서 리팩터링 대상이 되야 하고, 단계를 쪼개며 진행하는 것이 좋다.  
기능, 역할 책임 등 그 행위에 맞는 역할을 분리하고 분리하면서 원래 있던 함수 호출부를 옮겨가며, 더 적합하게 제어 가능한 것 같다.  
리팩터링을 한 번에 다 하려 하지말고, 기능이 클수록 단계를 세분화하여 점진적으로 진행하여 최종 목적에 달성하도록 하는 것이 중요하다.  
변경에 유연하게 대응하던, 클린 코드를 통한 코드 가독성을 높이던 핵심은 단계를 적절하게 나누는 것 같다. (+ 함수 옮기기)

- 논리적 요소 파악을 위한 코드 구조 보강
```

# 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨

# 1.8 다형성을 활용해 계산 코드 재구성하기

# 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

# 1.10 마치며