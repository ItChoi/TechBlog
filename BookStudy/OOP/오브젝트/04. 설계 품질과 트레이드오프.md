# 서론
- 객체지향 설계의 핵심
  1. 역할
     - 대체 가능한 책임의 집합
  2. 책임
     - 객체가 다른 객체와 협력하기 위해 수행하는 행동
     - 세 가지 중 가장 중요하다.
       - 책임이 적절히 할당되지 못한다면 역할과 협력 역시 기대 할 수 없다.
  3. 협력
     - 메시지를 주고받는 객체들 사이의 상호작용
  
- 객체지향 설계는 올바른 객체에게 올바른 책임을 할당해 낮은 결합도, 높은 응집도를 창조하는 활동이다.
  1. 객체 지향 설계의 핵심은 '책임'이다.
  2. 책임 할당 작업은 결합도, 응집도와 같은 '설계 품질'과 연관 된다.
  
설계는 변경을 위해 존재하고, 변경은 다양한 방식으로 비용이 든다.  
결합도와 응집도를 합리적으로 유지하기 위해 객체의 상태가 아니라 '객체의 행동'에 초점을 둬야 한다.  
객체의 책임에 초점을 둬 설계 변경에 유연하게 해야 한다.  
  
좋은 설계와 나쁜 설계를 살펴보는 과정도 필요하다.  
나쁜 설계(변경에 취약한 데이터 중심 설계)를 살펴보자. 

# 01. 데이터 중심의 영화 예매 시스템
- 객체 지향 설계에서 시스템을 객체로 분할하는 두 가지 방법
  1. 상태를 분할의 중심축으로 삼는 방법
     - 일반적으로 객체의 상태는 '데이터의 집합'을 의미한다. (상태 == 데이터)
     - 데이터 조작에 필요한 오퍼레이션을 정의한다. (데이터 중심 관점)
     - 객체의 상태에 초점 -> 독립된 데이터 덩어리
  2. 책임을 분할의 중심축으로 삼는 방법 
     - 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요 상태를 보관 (책임 중심 관점)
     - 객체의 행동에 초점 -> 협력하는 공동체 일원
  
훌륭한 객체지향 설계는 '책임'에 초점을 둬야 한다.  
왜냐하면 변경과 관련이 있다.  
  
객체의 상태는 구현에 속한다.  
구현은 변경 가능성이 상대적으로 더 높다.  
따라서 상태를 객체 분할의 중심으로 두면 세부사항이 객체 인터페이스에 스며들어 캡슐화가 무너진다.  
'책임'은 인터페이스에 속하여 상대적으로 변경에 안정적인 설계를 얻을 수 있다.  


## 01.1 데이터를 준비하자
데이터 중심 설계란 객체 내부 저장 데이터를 기반으로 시스템을 분할한다.  
객체 내부에 '저장해야 하는 데이터가 무엇인가?'를 물으며 시작된다.

객체의 책임을 결정하기 전 데이터에 초점을 둔다면 데이터 중심 설계에 매몰돼 있을 수도 있다.  
특히 Movie 객체에 객체 종류를 나타내는 movieType과 타입 별로 사용될 discountAmount, discountPercent 등을  
하나의 클래스에 포함하는 것은 데이터 중심 설계에 흔히 볼 수 있는 패턴이다.

객체 지향의 가장 중요한 원칙 중 하나는 캡슐화다.  
getter와 setter를 이용해 캡슐화가 위반되지 않게 해야 한다.

## 01.2 영화를 예매하자
- code/chapter04 참고 

--- 

# 02. 설계 트레이드 오프
- 데이터 중심 설계, 책임 중심 설계의 장단점을 비교하기 위해 세 가지를 알아보자.
  1. 캡슐화
  2. 응집도
  3. 결합도
  
## 02.1 캡슐화
하나의 객체에 '상태'와 '행동'을 두는 이유는 객체 내부 구현을 외부에 감추기 위해서다.  
구현은 향후 변경될 여지가 높다.  
객체지향은 변경으로 인한 사이드 이펙트를 적절히 조절 할 수 있는 장치를 제공한다.  
  
변경 가능성이 높은 부분을 구현, 상대적으로 안정적인 부분을 인터페이스라 한다는 점을 기억하자.  
따라서 변경 정도에 따라 구현과 인터페이스를 분리하고 의존 관계를 조절한다.  
  
객체지향 설계의 가장 중요한 원리는 '불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것이다.'  
설계는 요구사항 변경에 대응 할 수 있게 해준다.  
캡슐화는 불안정/안정적인 부분 분리를 통해 변경의 영향을 통제 할 수 있다.  
변경될 수 있는 어떤 것이라도 캡슐화해야 한다.  

## 02.2 응집도와 결합도
- 응집도
  - 내부 요소들의 연관 정도를 나타낸다.  
  - 모듈 내부 요소들이 하나의 목적을 위해 긴밀히 협력한다면 높은 응집도를 가졌다고 한다.  
  - 객체지향 관점에서 객체에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.
- 결합도
  - 의존성 정도를 나타낸다.
  - 다른 모듈에 대해 얼마나 알고 있는지에 대한 척도
  - 너무 자세한 부분까지 알고 있다면 높은 결합도를 가졌다고 한다.
  - 모듈간에 꼭 필요한 지식만 알고 있다면 낮은 결합도를 가졌다고 한다.
    - 적절한 수준의 관계만 유지해야 한다 
  
응집도와 결합도의 진정한 의미를 이해하기 위해 설계와 관련됐다는 사실을 이해해야 한다.  
일반적으로 좋은 설계는 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.  
  
높은 응집도와 낮은 결합도를 추구하는 것은 또 다시 변경과 관련이 있다.  
두려움, 주저함 없이 쉽게 설계를 변경할 수 있게 한다.  
응집도가 높을수록 변경 대상과 범위가 명확해진다. -> 변경이 수월해진다.  
  
결합도는 하나의 변경으로 인해 변경을 요구하는 정도를 측정 할 수 있다.  
변경된 확률이 매우 적은 안정적인 모듈은 결합도가 높아도 상관 없을 수 있다. (String, ArrayList, ...)  
코드를 완성한 순간부터 코드 수정 준비를 해야 한다. 즉 낮은 결합도, 높은 응집도를 유지하려고 노력해야 한다.  
  
---

# 03. 데이터 중심의 영화 예매 시스템의 문제점
데이터 중심 설계와 책임 중심 설계의 기능적인 측면만 보면 동일 할 수 있다.  
다만 가장 중요한 설계 관점에서 큰 차이를 보인다.  
가장 큰 차이는 캡슐화 방식이다.  
인터페이스를 적절하게 사용하던지, 데이터 상태로 두어 코드를 길게 할 건지 차이다.  
  
캡슐화의 정도가 응집도와 결합도를 결정한다.  
  
- 데이터 중심 설계 문제점
  1. 캡슐화 위반
  2. 높은 결합도
  3. 낮은 응집도

## 03.1 캡슐화 위반
실제 객체에 접근은 getter, setter로만 허용한다고 해도 캡슐화 원칙을 지켰다고 할 수 있을까?  
getter, setter만으론 객체 내부 상태를 캡슐화하지 못한다.  
getter, setter로 인스턴스 변수 이름과 타입을 알 수 있다.  
  
설계시 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 getter, setter를 갖는 경향이 있다.  
객체간 협력을 고려해야만 추측에 의한 설계를 하지 않는다.  

## 03.2 높은 결합도
데이터 중심 설계는 getter, setter를 통해 내부 구현을 인터페이스의 일부로 만들어 캡슐화를 위반한다.  
데이터 중심 설계는 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되어 강한 결합도를 갖게 된다.  
예를 들면 제어 로직에 특정 타입이 다른 타입으로 변경된다거나, 필드 자체가 수정됐다거나 하는 경우 결국 함께 변경해야 한다.  

## 03.3 낮은 응집도
객체의 수정사항이 발생하는 경우 낮은 응집도는 두 가지 설계 문제를 일으킨다.
1. 변경의 이유가 다른 코드들을 하나의 모듈 안에 뭉쳐 놓은 경우 변경과 무관한 코드들도 같이 영향을 받는다. 
2. 하나의 요구사항 반영을 위해 동시에 여러 모듈이 수정돼야 한다. 즉 책임 일부가 엉뚱한 곳에 위치하고 있을 수 있다.
  
데이터 중심 설계는 개방 폐쇄 원칙, 단일 책임 원칙을 위반한다.  
현재 설계에 새로운 요구사항이나 타입이 추가 됐을 때 여러 곳의 수정이 발생한다면 응집도가 낮다.

---

# 04. 자율적인 객체를 향해

## 04.1 캡슐화를 지켜라
캡슐화는 설계의 제 1원리다.  
객체는 스스로의 상태를 책임지고, 외부에서는 인터페이스를 통해서만 상태에 접근해야 한다.  
단순히 private으로 설정했다고 해도, getter 또는 setter를 통해 외부로 제공한다면 캡슐화를 위반한다.  
  
객체 스스로의 책임을 이상한 곳에 위치시키면, 중복 발생 가능성과, 변경에 취약해지고, 더 많은 정보를 제공해 결합도가 높아진다.  

## 04.2 스스로 자신의 데이터를 책임지는 객체
객체 안에 상태와 행동을 단위로 묶는 이유는 객체 스스로의 책임을 지게 하기 위해서다.  
단순히 데이터 제공자를 넘어 객체간 협력에 참여하며 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.  
객체의 책임과 어떤 데이터를 포함할지는 별개로 분리해 생각해야 한다.
- 이 객체가 어떤 데이터를 포함해야 하나?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
  - Movie
    - 영화 요금 계산 오퍼레이션 필요
      - 할인 정책 염두 필요 (금액, 비율, 미적용)
    - 할인 여부 판단 오퍼레이션 필요
      - 인스턴스 변수로 DiscountCondition 포함 -> 할인 여부 판단 오퍼레이션이 필요해진다 (변수가 없다면 필요하지 않다.)
  
---

# 05. 하지만 여전히 부족하다

## 05.1 캡슐화 위반
데이터 중심 설계도 자칫하면 객체지향 취지에 맞는 것 처럼 보일 수 있다.  
예를 들면 객체 자신의 데이터를 갖고 상태를 체크 할 수 있을 때, 겍체지향 취지에 맞는 것 처럼 보인다.  
하지만 메서드 파라미터들은 인터페이스를 통해 외부에 노출되고 있다.  
뿐만 아니라, getter 메서드를 통해 내부 인스턴스 변수들을 모두 체크 할 수 있다.

파라미터로 받고 있는 속성이 변경되는 경우 등 내부 구현의 변경이 외부로 퍼져나가는 파급 효과(ripple effect)는 캡슐화가 부족하다는 명백한 증거다.  
즉 객체가 자신의 데이터로 스스로 상태 관리를 하더라도 내부 구현의 캡슐화는 실패 할 수 있다.

또한 메서드 이름에 구체적인 내용을 명시할 필요가 없다.
- Movie
    - calculateAmountDiscountedFee
    - calculatePercentDiscountedFee
    - calculateNoneDiscountedFee

Movie 메서드의 세 개 메서드는 내부 구현을 인터페이스에 노출하고 있다. -> 캡슐화 X  
신규 할인 정책 추가 또는 기존 정책을 제거 할 때 메서드들에 의존하는 모든 객체가 영향을 받는다.  
  
- 캡슐화의 진정한 의미
  - 객체 내부 데이터를 외부로부터 감추는 것 이상의 의미를 가진다.
  - 변경될 수 있는 모든 것을 감추는 것을 의미한다.
    - 속성의 타입
    - 할인 정책 종류
  - 내부 구현 변경으로 인해 외부 객체 영향 -> 캡슐화 위반
  - 설계 단계에서 변하는 것을 체크 -> 변하는 개념을 캡슐화

## 05.2 높은 결합도
Movie, DiscountCondition 두 객체의 isDiscountable 메서드를 살펴보며 변경으로 인한 영향 범위를 삺펴보자.  
- 변경
  1. DiscountCondition 할인 조건 명칭 변경시 Movie 내부 구현 변경 동반
  2. DiscountCondition 종류 추가 또는 삭제시 Movie 내부 구현 변경 동반
  3. DiscountCondition의 isDiscountable 메서드 파라미터 변경시 Movie 내부 구현 변경 동반
  - DiscountCondition 구현 변경이 Movie의 변경을 초래한다. 즉 두 객체 사이의 결합도가 높다.

DiscountCondition 여파는 Movie만 한정되지 않는다.  
모든 문제의 원인은 캡슐화 원칙을 지키지 않아서 발생했다.  
DiscountCondition 내부 구현을 제대로 캡슐화 하지 않은 탓이다.  
  
유연한 설계를 위한 첫 목표는 캡슐화이다.  

## 05.3 낮은 응집도
DiscountCondition 내부 구현 변경시 Movie의 isDiscountable 메서드 변경으로 인해, Screening 객체도 함께 변경해야 한다.  
결국 isDiscountable 메서드를 사용하는 Screening, Movie, DiscountCondition가 함께 변경을 동반한다.  
  
하나의 변경을 수용하기 위해 여러 곳을 동시에 변경해야 한다면 설계의 응집도가 낮다는 증거다.  
캡슐화를 위반하면 응집도는 낮아진다.  
  
데이터 중심 설계를 객체지향화를 점진적으로 시켜도 고질적인 문제가 해결되지 않는다.  
왜 결합도가 높고 응집도가 낮은 문제를 야기할까?  

---

# 06. 데이터 중심 설계의 문제점
- 설계가 변경에 유연하지 못한 이유
  1. 캡슐화 위반
     - 구성 요소들의 낮은 응집도, 높은 결합도
     - 변경에 취약하다.
       1. 너무 이른 시기에 데이터 결정 강요
       2. 협력이라는 문맥을 고려하지 않고 객체를 고립하여 오퍼레이션 결정
  
## 06.1 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다
데이터 중심 설계의 첫 질문은 이 "객체가 포함해야 하는 데이터"다.  
데이터는 구현의 일부인데, 너무 이른 시기에 내부 구현에 초점을 둔다.  
데이터 중심 설계는 일반적으로 데이터와 기능을 분리하는 절차적 방식을 따른다.  
객체를 단순 데이터 집합체로 바라본다. -> 접근자와 수정자가 과도하게 추가되는 중상이 동반된다.  
인스턴스 변수를 숨겨도 getter, setter를 통해 public 속성과 큰 차이가 없어진다. -> 캡슐화가 무너진다.  
  
데이터 결정 -> 오퍼레이션 결정 순서는 인터페이스에 고스란히 드러나게 된다. 더불어 변경에 취약하다.  

## 06.2 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다
객체지향 앱을 구현한다는 것을 객체간 공동체를 구성하고 서로 협한 관계를 구축한다는 것이다.  
객체를 고립시키지 않고 '협력'이라는 문맥 안에서 필요한 '책임'을 결정하고 수행할 적절한 객체를 결정하는 것이 중요하다.  
객체지향 설계 중심의 무게는 내부가 아니라 외부에 맞춰야 한다.  
데이터 중심 설계는 외부가 아니라 내부에 맞춰졌다.  

---

```yaml
느낀점 & 정리
객체를 고립시키지 않고 공동체 관계로 바라보며 협력을 통해 상호작용한다.
즉 데이터 상태에 초점을 두는 것이 아니라, 행동에 초점을 두어야 한다.

객체를 만들 때 데이터에 집착하다보면, 데이터 중심 설계 방향으로 흐를 수 있다.
그리고 초기에 데이터 중심 설계가 된다면, 이를 점진적으로 객체지향으로 바꾸더라도
근본적인 높은 결합도, 낮은 응집도의 문제를 해결 할 수 없다.
데이터 중심 설계로 시작하여 객체지향의 한계라고 오해하지 말아야 할 것 같다.
결국에 데이터 중심 설계는 하나의 객체의 변경이 여러 객체에 동시 변경을 유발하게 된다.
결국 이는 변경에 유연하지 못하고, 리팩터링이 무서운 존재가 되버린다.
불완전해도 좋으니, 객체는 데이터 상태가 아니라 행동에 초점을 둬 공동체 관계에서 생각하여 설계를 하자.

불안정한 세부사항을 인터페이스 뒤로 숨긴다.
책에서는 자주 변경되는 것들을 캡슐화 대상으로 보았다.
책에서 나오는 데이터 캡슐화를 나도 캡슐화로 오해했었는데, 본질을 어느정도 이해하게 됐다.  
객체의 데이터를 먼저 정하는 것은 세부사항(내부 구현)을 먼저 정의하는 것과 같은데,
이는 앞서 말한 변경의 유연함을 가질 수 없고 외부 인터페이스에 구현이 들어나게 되어 객체지향적이지 못하게 된다.

객체지향 설계는 변경에 유연하고, 캡슐화되어 높은 응집도와 강한 결합도를 갖는다.
설계는 결국 변경에 대응하기 위한 것인데, 객체지향 설계에 적합하게 다가가야 할 것 같다.
```
