# 서론
객체지향에서 분석, 설계, 구현 활동 중심에 클래스를 놓는다.  
클래스는 중요하지만, 구체화할 수 있는 도구일 뿐이다.  
클래스에 집착하게 되면 경직되고 유연하지 못한 설계가 나올 수 있다.  
  
객체지향은 말그대로 클래스가 아니라 객체를 지향해야 한다.  
즉 협력이라는 문맥 안에서 메시지 기반으로 객체의 책임에 중심을 둬야 한다.  
  
입문자가 오해할 수 있지만, 객체지향에서 가장 중요한 재료는 클래스가 아니라 **객체들이 주고받는 메시지**다.  
클래스 사이의 정적인 관계 -> **메시지 사이의 동적인 흐름** 초점 전환이 필요하다.  
애플리케이션은 클래스로 구성디지만 메시지를 통해 정의된다!  
  
객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.  
훌륭한 퍼블릭 인터페이스를 얻기 위해 책임 주도 설계만으로는 부족하다.  
유연하고 재사용 가능한 퍼블릭 인터페이스를 위해 설계 원칙과 기법을 적용해야 한다.  

---

# 01. 협력과 메시지

## 01.1 클라이언트-서버 모델
협력은 메시지를 통해 이뤄진다.  
객체간 유일한 접근은 메시지 전송이다.  
요청과 응답은 두 객체 사이의 협력을 구성한다.  
  
협력 사이의 메시지 전송 객체는 클라이언트, 메시지 수신 객체는 서버라고 한다.  
협력은 "클라이언트 -> 서버" 단방향 상호작용이다.  
  
- Screeing (클라이언트)
  - 가격 계산 하라 요청
    - Movie (서버)
      - 예매 요금 응답
    
클라이언트 Screening은 메시지 전송을 통해 도움을 요청하고, 서버 Movie는 가격 계산 서비스를 제공하며 메시지에 응답한다.  
  
- Movie (클라이언트)
  - 할인 요금 계산 하라 요청
    - DiscountPolicy (서버)
      - 할인 요금 응답
  
객체들은 클라이언트와 서버를 병행하며 객체간 협력을 구성한다.  
즉 협력은 **메시지 전송**과 **메시지 수신**의 집합이다.  
대부분 객체 수신에만 초점을 맞추지만, 협력에 적합한 객체 설계는 두 집합 모두 고려해야 한다.  
- 가격 계산해라 (메시지)
  - Movie (클라이언트 & 서버)
    - 예매 요금 응답
    - 할인 요금 계산해라 (메시지)
  
객체는 독립적으로 수행하기 보단 협력을 통해 더 큰 책임을 수행해야 한다.  
따라서 협력을 유일하게 가능하게 하는 **메시지**는 중요하다.  
  
## 01.2 메시지와 메시지 전송
메시지는 객체간 협력에 사용할 수 있는 유일한 의사소통 수단이다.  
객체간 도움을 요청하는 행위를 "메시지 전송" 또는 "메시지 패싱"이라 부른다.  
클라이언트-서버 모델에서 메시지 전송자는 클라이언트, 메시지 수신자는 서버다.  
  
메시지는 메시지 수신자와 오퍼레이션명(operation name과 인자(argument)로 구성된다.  
- 메시지 전송 표기법
  - condition.isSatisfiedBy(screeing);
    - condition: 수신자
    - isSatisfiedBy: 오퍼레이션
    - (screeing): 인자
   
## 01.3 메시지와 메서드
메시지 수신자가 실제 실행되는 함수를 메서드라 부른다.  
동일한 객체에게 동일한 메시지를 보내도 구쳔체가 다른 다형성은 실행되는 메서드가 달라질 수 있다.  
즉 메시지와 메서드는 실행 시점에 연결되기에 컴파일 시점과 실행 시점 의미가 다를 수 있다.  
  
실행 시점에 실제 실행 될 때 메시지 수신자는 객체 타입에 따라 달라진다.  
따라서 메시지 전송자는 메시지 수신 객체가 존재하고, 적절한 메서드를 선택 후 응답한다고 믿을 수 밖에 없다.  
  
메시지와 메서드의 구분을 통해 느슨한 결합을 가능하게 한다.  
즉 객체간 구체적인 내용을 모르더라도 원활한 협력이 가능하다.  
  
## 01.4 퍼블릭 인터페이스와 오퍼레이션
외부 객체는 공개된 메시지를 통해서만 다른 객체와 상호작용 할 수 있다.  
객체가 의사소통 수단을 외부에 공개하는 메시지 집합을 "퍼블릭 인터페이스"라 한다.  
퍼블릭 인터페이스에 포함된 메시지를 "오퍼레이션"이라 한다.  
오퍼레이션은 수행 가능 행동에 대한 추상화다.  
오퍼레이션은 내부 구현 코드 제외, 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.  
예를 들어 DiscountCondition 인터페이스에 정의된 isSatisfiedBy가 오퍼레이션이다.  
실제 실행되는 코드는 메서드라 한다.  
  
## 01.5 시그니처
오퍼레이션 또는 메서드 + 파라미터 목록을 합쳐 시그니처(signature)라고 부른다.  
오퍼레이션은 시그니니처만 정의 한 것이고, 메서드는 시그니처 + 구현이다.  
  
하나의 오퍼레이션에 하나의 메서드만 존재시 단순하다.  
이럴 경우 굳이 구분 할 필요도 없어진다.  
다형성을 통해 하나의 오퍼레이션에 여러 메서드를 구현 할 수 있다.  
즉 다형성을 통해 동일 오퍼레이션 호출로 여러 메서드 중 적합한 메서드가 실행된다.  
  
중요한 것은 메시지가 퍼블릭 인터페이스와 오퍼레이션을 결정한다.  
  
---

# 02. 인터페이스와 설계 품질
좋은 인터페이스는 두 조건을 만족해야 한다.
1. 최소한의 인터페이스 -> **꼭 필요한** 오퍼레이션만 인터페이스에 포함
2. 추상적인 인터페이스 -> 어떻게가 아니라 **무엇을 하는지 표현**
  
가장 좋은 방법은 책임 주도 설계를 하는 것이다.  
즉 메시지를 먼저 선택해서 구현 내용이 인터페이스에 스며드는 것을 방지한다.  
메시지가 객체를 선택함으로써 클라이언트 의도를 메시지에 표현한다. 추상화가 강조 될 수 있다.  
  
- 퍼블릭 인터페이스 품질에 영향을 주는 기법 & 원칙
  1. 디미터 법칙
     - 객체 내부 구조가 결합되지 않도록 경로를 제한
     - 인접 이웃하고만 말하라
     - 하나의 도트만 사용하라 (.)
     - 객체들의 협력 경로 제한시 결합도가 효과적으로 낮아진다.
     - 클래스는 특정 조건 만족 대상에게만 메시지 전송하도록 개발
       - 메서드 인자로 전달된 클래스
       - 클래스의 인스턴스 변수
     - 캡슐화를 다른 관점에서 표현한 것
       - 캡슐화는 내부 구현을 감추는 것을 강조
       - 디미터 법칙은 협력 클래스간 캡슐화를 위해 접근 요소 제한
     - 디미터 법칙 위반 코드
       - screeing.getMovie().getDiscountConditions();
     - 너~~무 디미터 법칙만 강조하다보면 인터페이스 관점에서 객체 응집도가 낮아질 수도 있다.
  2. 묻지 말고 시켜라
  3. 의도를 드러내는 인터페이스
  4. 명령-쿼리 분리

## 02.1 묻지 말고 시켜라
디미터 법칙은 "훌륭한 메시지"는 객체 상태를 묻지 않고 시키는 시키는 것을 강조한다.  
객체 외부에서 해당 객체 상태를 기반한 결정은 캡슐화를 위반한다.  
  
"묻지말고 시켜라"를 통해 연관 정보와 행동을 함께 갖는 객체를 만들 수 있다.  
즉 자연스레 정보 전문가에게 책임읋 할당하게 되면서 퍼블릭 인터페이스 품질을 향상시킬 수 있다.  
  
묻지말고 요청한다고 다 해결되진 않는다.  
객체 수행 작업이 어떻게 되는지 노출시키면 안 된다.  
즉 객체의 "어떻게"가 아니라 "무엇을" 하는지 서술해야 한다.  
  
## 02.2 의도를 드러내는 인터페이스
- 켄트 벡의 **메서드 명명** 두 가지 방법
  1. 메서드 이름은 작업을 어떻게 수행하는지 나타내도록 명명한다.
     - 메서드 이름을 통해 내부 구현 방법을 드러낸다.
     - 좋지 않은 스타일이다.
       - "isSatisfiedByPeriod", "isSatisfiedBySequence" 
         - 두 메서드는 모두 할인 조건 판단하는 동일 작업을 수행하지만, 메서드명이 달라 내부 구현을 이해해야 동일 작업인 것을 인지 할 수 있다.
       - 메서드 수준에서 캡슐화 위반
         - 클라이언트로 하여금 협력 객체 종류를 알도록 강요한다.
           - 참조해 사용하는 객체 뿐만 아니라 메소드명도 변경해야 된다.
             - 서버 메소드 변경은 클라이언트 로직 변경 필요
  2. "어떻게"가 아니라 "무엇"을 하는지 드러낸다.
     - 읽고 이해하기 쉽다.
     - 설계 유연성 향상

메서드 명명시 "어떻게"를 포함하면 내부 구현을 드러내고, 협력 설계 초기부터 클래스 내부를 고민 할 수 밖에 없다.  
반면 "어떻게"를 포함하면 협력 안에서 수행하는 책임에 관해 고민해야 한다.  
즉 메시지 전송자가 목적을 먼저 생각하도록 만들어 협력하는 클라이언트 의도에 부합한 메서드명이 된다.  
  
이처럼 "어떻게"가 아니라 "무엇을" 하느냐에 따라 메서드명을 짓는 패턴을 "의도를 드러내는 선택자"라고 부른다.  
하나의 구현을 가진 메서드라도, 매우 다른 성질의 구현체가 추가된다는 상황을 가정하고 메소드명을 짓는다면 추상적인 메서드명을 만들 때 도움된다.  
  
"의도를 드러낸 선택자"를 "의도를 드러낸 인터페이스"로 확장 할 수도 있다.  
결과적으로 구현 관련 정보를 캡슐화 하고 퍼블릭 인터페이스는 협력 관련 의도만 표현해야 한다.  
  
결과와 목적만 포함한 클래스와 오퍼레이션의 이름을 부여하면 조화를 이룬 퍼블릭 인터페이스들이 구성된다.
클라이언트 개발자는 내부 이해가 필요하지 않고 사용 할 수 있다.  
  
객체에게 묻지말고 요청하며 클라이언트 의도를 드러내야 한다.  
  
## 02.3 함께 모으기
- 훌륭한 설계 원칙
  - 디미터 법칙 (인접 이웃하고만 말해라, 참조의 참조를 사용하지 말라)
  - 묻지말고 요청 (어떻게 X, 무엇을 O)
  - 의도를 드러내는 인터페이스
  
위 원칙들을 위반하는 코드를 살펴봄으로써 배울 수도 있다.  
  
디미터 법칙 위반시 퍼블릭 인터페이스 뿐만 아니라 내부 구조에 결합된다.  
즉 디미터 법칙 위반 설계는 "인터페이스와 구현 분리 원칙"을 위반하고 구현이 외부로 새어나간다.  
따라서 변경에 쉽게 무너지는 불안정한 코드를 얻게 된다.  
  
- 인터페이스 의도를 드러내자
  - TicketSeller.setTicket
  - Audience.setTicket
  
두 메서드의 의도를 알 수 있는가? 직접 개발한 사람은 알 수 있다.  
퍼블릭 인터페이스를 해석하고 사용하는 개발자는 의도를 알 수 없다.  
즉 Audience, Bag 객체의 입장에서 setTicket 메서드명은 클라이언트 의도를 명확하게 드러내지 못한다.  
  
관중에게 티켓을 판매하는 의도를 표현할 땐 setTicket 보단 sellTo 메서드명이 의도가 명확하다.  
클라이언트 입장에서 의도를 분명하게 드러내는 메서드명을 지어야 한다.  
  
오퍼레이션명은 협력 관점에서 생각하고, 클라이언트가 객체에게 무엇을 원하는지 표현해야 한다.  
표현은 객체 자신이 아닌 클라이언트 의도를 표현해야 한다.  
  
디미터 법칙, 묻지말고 요청, 의도를 드러낸 인터페이스를 잊지말자!  

---

# 03. 원칙의 함정
디미터 법칙, 묻지말고 요청, 의도를 드러낸 인터페이스는 잊으면 안 되지만, 절대적인 법칙은 아니다.  
SW 설계에 절대적인 법칙은 없다. 원칙만 존재하고 원칙엔 예외가 넘쳐난다.  
  
다시 한 번 상기해야 한다. 설계는 트레이드 오프의 산물이다.  
초보자는 원칙을 맹목적으로 추종한다.  
충돌되는 원칙들에 정당성을 부여해 억지로 끼워맞출 수도 있다.  
  
원칙이 현재 상황에 부적합하다면 과감하게 원칙을 무시해라.  
원칙은 언제 유용한지 아닌지를 잘 판단해야 한다.  
  
## 03.1 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다
도트를 많이 사용해 필터체이닝을 해도 결과적으로 동일 클래스를 반환해 필터체이닝이 된다면 디미터 법칙을 위반하지 않는다.  
인접 이웃에게만 접근 가능한지 체크하는 원칙이다.  

## 03.2 결합도와 응집도의 충돌
객체 상태를 묻고 반환 데이터를 기반으로 결정하는 것 보단, "묻지말고 요청해라"로 코드를 작성해야 한다.  
위임 메서드를 통해 객체에 상태와 동작을 함꼐 넣어 스스로 결정하는 자율적인 객체를 만든다는 것은 객체간 결합도를 낮추고 응집도를 높이는 효과적인 방법이다.  
  
"묻지말고 요청", "디미터 법칙" 두 개를 준수한다고 해서 항상 긍정적이진 않다.  
즉 모든 상황에 위임 메서드를 추가하면 퍼블릭 인터페이스에 적합하지 않은 오퍼레이션이 공존하게 된다.  
  
클래스는 하나의 변경 원인만을 가져야 한다.  
서로 상관없는 책임들이 여러 개가 되면 응집도는 낮아지고 작은 변경으로도 무너질 수 있다.  

디미터 법칙 위반 여부는 묻는 대상이 객체, 자료구조에 따라 다르다고 설명한다.  
객체 내부 구조는 당연히 숨겨야 하지만, 자료 구조라면 디미터 법칙을 적용할 필요 없다.  
  
소프트 웨어 설계는 절대적인 법칙은 없다.  
원칙을 맹신하지 말고, 적절하고 부적절한 상황을 판단 할 안목을 길러야 한다.  
설계는 트레이드 오프의 산물이다.  
  
[필요에 따라] 묻지말고 요청해라.  
너무 잦은 묻지말고 요청해라는 낮은 응집도가 된다.  

---

# 04. 명령-쿼리 분리 원칙
퍼블릭 인터페이스 오퍼레이션 정의에 참고 할 수 있다.  
- 용어 설명
  - 루틴: 절차를 묶어 호출 가능하도록 부여한 기능 모듈
    - 프로시저 (명령)
      - 정해진 절차에 따라 내부 상태 변경
      - 부수효과 O, 값 반환 X
    - 함수 (쿼리)
      - 절차에 따라 필요 값 계산 후 반환
      - 부수효과 X, 값 반환 O
  
상태를 변경하던, 정보를 반환하던 둘 중 하나만 해야 하는 원칙이다.  
구시대 전자 기기 버튼있는 디스플레이라고 생각하면 된다.  
  
명령과 쿼리를 분리함으로써 얻는 장점은 무엇이 있을까?  

## 04.1 반복 일정의 명령과 쿼리 분리하기
- 도메인의 중요한 두 가지 용어
  1. 이벤트
     - 특정 일자에 실제로 발생하는 사건
       - 24.09.14 10:30 회의 -> 회의가 이벤트
  2. 반복 일정
     - 주기적으로 발생하는 사건 전체를 포괄적으로 지칭
       - 매주 수요일 10:30 ~ 11:30 회의 -> 반복시 반복 일정
  
즉 반복 일정을 만족하는 특정 이벤트들이 존재한다.  
코드는 서적 참고 p.205 ~  
  
명령과 쿼리를 한 곳에서 수행하게 되면 버그를 찾기 어렵다.  
한 곳에 두면 요구사항 변경으로 인한 사이드 이펙트를 고려하거나 예상하기 어렵다.  
혼자 개발하는 것이 아닌, 팀 단위로 개발을 같이하는 경우 '명령'과 '쿼리'가 나누어진 경우 각자의 요구사항 해결을 위해 코드가 지저분해질 수 있다.  
  
복잡해보여도, 명령과 쿼리를 분리함으로써 얻는 이점이 크다.  
분리된 코드는 예측 가능하고 이해하기 수월하며 디버깅 및 유지보수가 용이하고 수월하다.  

## 04.2 명령-쿼리 분리와 참조 투명성
명령과 쿼리를 엄격히 분리한 경우 "객체의 부수효과" 제어가 수월해진다.  
또한 참조 투명성을 제한적이지만 누릴 수 있다.  

## 04.3 책임에 초점을 맞춰라
디미터 법칙, 묻지말고 요청, 의도를 드러내는 인터페이스 설계를 할 수 있는 쉬운 방법이 있다.  
메시지를 선택한 후 메시지 처리 객체를 선택하면 된다.  
이는 명령과 쿼리 분리 원칙에도 긍정적인 영향을 미친다.  
  
책임 주도 설계를 통해 객체간 협력에 적합한 메시지를 만들 수 있다.  

---

```text
느낀점 & 정리

일을 하다 보면 요구사항을 들었을 때 대략적으로 생각되는 객체들을 일단 만들고, 만들면서 의존성을 고민하고 바로 매핑해서 작업하는 경우가 많았다.
틀렸다고 할 수 있는 방식은 아니지만 이런 경험도 필요하다고 생각한다.
다만 이번 챕터에서 얘기하고자 하는 내용을 개인적으로 해석 및 정리를 해보자면 다음과 같다.
1. 객체 자체에 초점을 두지 말고 메시지를 먼저 선택한 후 처리할 객체를 지정해라.
2. 책임은 정보 전문가에게 할당해라.
3. 서버와 클라이언트 구조에서 메시지는 클라이언트에 초점을 두어 네이밍 및 파라미터를 지정해야 한다.
4. 서버는 클라이언트의 의도를 구체적으로 정의 할 필요 없다.
5. 등등등

이번 챕터에서 나온 내용은 많지만, 내가 해왔던 방식이랑은 차이가 있었던 내용들이다.
객체에 초점을 두어 관계를 매핑하면서 우연의 일치로 1.2.3.4.5 등이 지켜졌을 진 몰라도 나의 개발 방식과는 조금 차이가 있었다.
설계는 결국 요구사항 변경 등의 이유로 변경을 최소화하고 사이드 이펙트를 최소화하기 위함이다.
객체를 먼저 지정하고, 복잡한 객체들의 설계가 이루어졌을 때 의존관계 때매 고민을 했던 경험이 많다.  
앞에 나열한 사항들과 디미터 법칙, 묻지말고 요쳥, 의도를 드러내는 인터페이스, 명령과 쿼리 분리 등을 고민하며 개발할 필요가 있다고 느끼는 챕터였다.
서적에서 나오듯이 원칙은 법칙이 아니기 때문에 상황과 팀 분위기에 따라 적합하게 하는 것이 중요하지만, 
결과적으로 도메인 전체의 낮은 결합도, 높은 응집도와 유연하고 이해가 수월하고 재사용 가능한 코드를 유지하도록 고민을 많이 해야 할 것 같다.  
```