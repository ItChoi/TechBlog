# 서론
객체지향 패러다임 관점에서 핵심은 세 가지다.
1. 역할(Role)
2. 책임(Responsibility)
3. 협력(collaboration)
이 세가지는 객체지향의 본질이라고 볼 수 있다.  
앞서 상속, 다형성을 통한 지연 바인딩, 컴파일/실행시간 의존성, 합성 등 중요한 개념을 배웠지만 구현 측면에 치우쳐 있다.  
  
즉 객체지향의 본질은 객체간 협력 관계를 맺는 것이다.  
그 과정에서 협력 구성을 위한 적절한 객체를 찾고, 책임을 할당한다.  
  
객체간 협력 관계를 맺고, 책임을 할당 한 후 앞서 배운 구현을 진행하면 된다.   
APP 기능 구현을 위해 객체간 협력, 역할, 책임을 먼저 정해야 한다.  
구현에 초점을 맞춘 설계와 코드는 변경하기 어렵고 유연하지 못한 원인이 된다.  
  
--- 

# 01. 협력
다시 한 번 강조하지만, 객체지향에서 중요한 것은 역할, 책임, 협력을 구축하는 것이다.  

## 01.1 영화 예매 시스템 돌아보기
- User
  - Screening (reserve(customer, audienceCount))
    - Movie (calculateMovieFee(screening))
      - AmountDiscountPolicy(calculateDiscountAmount(screening))
        - PeriodCondition(isSatisfiedBy(screening))
        - SequenceCondition(isSatisfiedBy(screening))
    - Reservation (create)
  
영화 예매 APP 흐름만 보더라도, 다양한 객체에 로직을 분배하고, 요청 흐름에 따라 실행하며 App의 완성도를 높인다.  
즉 다양한 객체들이 기능 구현을 위해 서로 메시지를 주고 받으며 상호작용한다. 이를 **협력**이라 한다.  
협력에 참여하는 객체가 수행하는 로직을 **책임**이라 한다.  
협력안에서 객체들이 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.  
  
정리하자면 다음과 같다.
1. 협력: 기능 구현을 위해 객체간 메시지를 통해 상호작용
2. 책임: 협력 안에서 객체가 수행하는 로직
3. 역할: 책임들이 모여 역할 구성 (? 이건 잘 와닿지가 않네)  

## 01.2 협력
객체는 고립된 존재가 아니라, 자율적인 객체들의 공동체이자 객체간 협력하는 사회적인 존재다.  
협력을 통해 기능을 유일하게 구현한다.  
두 객체의 협력은 **메시지**를 통해 시작된다.  
객체간 내부에 자세하게 접근할 수 없기 때문에 객체간 유일한 커뮤니케이션인 **메시지**를 통해 요청을 전달한다.   
두 객체의 상호작용을 통해 더 큰 책임을 수행한다.  
  
메시지 수신 객체는 메서드를 통해 요청에 응답한다.  
메시지 처리는 메시지를 요청하는 객체가 아닌, 수신하는 객체가 처리 방법을 스스로 결정한다. -> 자율적인 존재  
- 예시
  - Screening calculateMovieFee(screening) -> Movie

Screening은 Movie에게 처리를 위임한다.  
영화의 기본 요금, 할인 정책은 Movie 객체가 더 잘 알고 있다.  
Screening이 Movie 내부 구현에 직접 접근한다면, Movie는 수동적인 존재로 전락한다.  
Movie는 자신의 정보를 이용해 직접 요금계산을 해야 객체들의 전체적인 자율성을 향상시킨다.  
즉 객체들의 자율성 보장을 위해 내부 구현을 캡슐화가 필요하다.  
  
자율적인 객체는 자신의 책임을 수행 중 필요한 정보가 생기면 다른 객체에 메시지를 전송한다.  
이처럼 객체간 협력 구성을 통해 App의 기능이 구현된다.  

## 01.3 협력이 설계를 위한 문맥을 결정한다
객체란 상태와 행동을 함께 캡슐화하는 실행 단위다.  
객체의 상태와 행동을 어떤 기준으로 결정할까?  
객체간 협력을 구성할 때, 각 객체는 협력에 필요한 적절한 행동을 보유하고 있다.  
즉 객체 행동을 결정하는 것은 **협력**이다.  
협력이 바뀌면 객체 행동도 같이 변경돼야 한다.  
  
- Movie를 통한 고민 포인트
  - Movie 객체는 어떤 것을 수행할 수 있어야 할까?
    - 영화 상영?
    - 요금 계산?  

Movie 객체 안 영화 상영 행위는 없다.  
오히려 단순히 생각했을 때 어울리지 않는 요금 계산 행위가 존재한다.  
이는 Movie 객체가 '영화 예매 시스템' App 안에서 영화 예매를 위한 협력으로 참여하고 있고, 요금 계산을 책임지기 때문이다.  
  
즉 Movie의 행동 결정은 '영화 예매 협력'이다.  
협력을 고려하지 않고 행동을 결정하는 것은 의미가 없다.  
협력이 있고 그 다음 객체가 존재하기 때문이다.  
  
객체의 행동은 협력을 통해 결정되고,  
객체의 상태는 행동을 통해 결정된다.  
어쨋든 협력을 통해 행동과 상태가 결정된다.
  
Movie 객체 안 Money fee, DiscountPolicy discountPolicy 두 변수 모두 서적에서는 상태의 일부로 포함한다.  
계산 행동을 수행함에 있어서 필요한 정보들이기 때문이다.  
단순히 status, type 등을 상태로 보지 않고, 행동에 필요한 데이터도 상태의 일부로 본다.  

결과적으로 협력은 객체 설계에 필요한 문맥을 제공한다.  

---

# 02. 책임

## 02.1 책임이란 무엇인가
객체 설계를 위해 필요한 협력을 갖춘 후 행동 수행을 위한 적절한 객체를 찾는다.  
객체가 수행하는 행동을 책임이라 한다.  
  
객체의 책임은 두 가지 범주로 나누어 세분화하고 있다.
1. 객체가 무엇을 알고 있는가? (아는 것)
   - 사적인 정보
   - 관련 객체
   - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 (?)
2. 객체가 무엇을 할 수 있는가? (하는 것)
   - 객체 생성, 계산 수행 등 스스로 하는 것
   - 다른 객체의 행동을 시작시키는 것
   - 다른 객체의 활동을 제어, 조절하는 것

Screening 책임 -> 영화 예매 (아는 것)  
Movie 책임 -> 요금 계산 (하는 것)  
Movie 책임 -> 가격, 적용된 할인 정책 (아는 것)  
  
협력 안에서 객체에 할당된 책임이 외부 인터페이스와 내부 속성을 결정한다.  
- Screeing 객체는 reverse 메시지 수신, movie 인스턴스 변수 포함 -> 영화 예매 책임 
- Movie 객체는 calculateMovieFee 메시지 수신, 가격/할인정책 속성 포함 -> 가격 계산 책임
  
일반적으로 책임 > 메시지이다.  
책임은 객체 수행 행동을 종합적이고 간략하게 서술한다.  
단순한 책임도 여러 개 메시지로 분할되기도 하고, 더 다양한 객체와 협력해야하는 커다란 책임으로 자라는 것이 일반적이다.  
  
책임 관점에서 '아는 것'과 '하는 것'은 밀접히 연관돼 있다.  
객체는 책임에 필요한 정보와 메시지를 보낼 객체를 알고 있을 책임이 있다.  
  
책임을 능숙하게 객체에 할당하는 것은 어렵지만 핵심이다.  
적절한 협력이 적절한 책임을 제공하고, 객체에 적합한 책임을 할당해야만 품질과 단순하고 유연할 설계를 만들 수 있다.  
  
객체지향 설계에서 가장 중요한 것은 **책임**이다.  
구현 방법은 책임보다 상대적으로 덜 중요하다.  
책임을 결정한 후 구현 방법을 고민하도록 하자.  
  
- CRC 카드
  - Candidate (후보)
  - Responsibility (책임)
  - Collaborator (협력자)
  - 객체지향 설계 기법 고안 기법이다.
  - 하나의 카드는 협력에 참여하는 하나의 후보(역할, 객체, 클래스, ...)
  - 뒷 면에 후보의 목적 기술 (개별 상용 정보, 실제 예매 대상)
  - 앞 면에 후보 이름, 세분화된 목적, 책임을 적는다.

## 02.2 책임 할당
자율적인 객체를 만들기 위해선, 책임 수행에 필요한 정보를 잘 아는 객체에게 책임을 할당해야 한다.  
이를 책임 할당을 위한 정보 전문가 패턴이라 한다.  
  
책임 할당 전 협력이라는 문맥을 정의해야 한다.  
협력 설계의 출발점은 App의 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.  
시스템의 책임을 완료하는 데 필요한 더 작은 책임들을 찾아내 객체에게 할당하는 것을 반복하며 객체지향 설계 모양을 맞춰야 한다.  
  
영화 예매 시스템 예제로 돌아가 정보 전문가 패턴을 통해 책임 할당하는 방법을 살펴보자.  
- App 기능 -> 영화 예매 (시스템 책임) 
1. '예매 하라' 메시지를 통해 협력을 시작한다.
2. 메시지 처리 객체 선택
3. 영화 예매 책임 -> 정보 전문가에게 할당 -> 영화 예매는 상영 시간, 기본 요금을 알아야 한다. -> Screenng
4. 영화 예매를 위해 예매 가격 계산 필요
5. Screenng 객체에 '가격을 계산하라' 새로운 메시지 추가
6. 메시지 처리 객체 선택 
7. 가격 계산 책임 -> 정보 전문가에게 할당 -> 가격 계산은 가격과 할인 정책을 알아야 한다 -> Movie
8. 가격 계산을 위해 할인 요금 필요
9. '할인 요금 계산하라' 새로운 메시지 추가

위와 같은 순서로 협력에 필요한 메시지를 찾고, 적절한 객체 선택을 반복하는 과정을 통해 설계가 이뤄진다.  
협력을 설계하며 객체 책임 식별하는 과정의 결과물은 시스템 구성 객체 인터페이스와 오퍼레이션 목록이다.  
  
무조건 정보 전문가에게 책임을 할당하진 않는다. 응집도와 결합도 관점에서 다른 객체에게 할당하는 것이 적절할 때도 있다.  
그러나 정보 전문가에게 할당하는 것이 상태, 행동을 함께 가지는 자율적인 객체로 만들 가능성이 높다.

## 02.3 책임 주도 설계
협력 설계를 위해 책임에 초점을 맞춰야 한다.  
책임이 곧 전체적인 설계의 방향과 흐름을 결정한다.
- 책임 주도 설계(Responsibility-Driven Design, RDD)
  - 객체의 구현이 아닌 책임에 집중할 수 있게 해준다.
    - 객체 책임의 집중을 통해 유연, 견고한 객체지향 시스템을 얻을 수 있다.
  - 책임을 찾고, 책임을 수행할 적절한 객체에 할당
  - 책임 주도 설계 방법 과정 정리
    1. 시스템이 이용자에게 제공하는 기능(시스템 책임) 파악
    2. 시스템 책임을 더 작은 책임으로 분할 (기능을 더 작은 단위로 분리)
    3. 분할된 책임을 수행할 적절한 객체 또는 역할을 찾아 책임 할당
    4. 객체의 책임 범위가 아닌 정보를 책임질 적절한 객체 또는 역할을 찾는다.
    5. 타 객체에 책임을 할당하고 두 객체는 협력하게 된다.
  
협력은 객체 설계의 구체적인 문맥(상태, 행동)을 제공하고, 책임을 이끌어낸다.  
또한 책임은 협력에 참여할 객체를 결정한다.  
  
책임 할당 할 때 고려해야 하는 두 가지 요소
1. 메시지가 객체를 결정
2. 행동이 상태를 결정

## 02.4 메시지가 객체를 결정한다
객체 책임 할당에 필요한 메시지를 먼저 식별하고, 메시지 처리 객체를 나중에 선택한다.  
즉 객체가 메시지를 선택하는게 아니라, 메시지가 객체를 선택한다.  
  
- 메시지가 객체를 선택해야 하는 두 가지 중요한 이유
  1. 객체가 최소한의 인터페이스를 가질 수 있다.
     - 필요한 메시지 식별 전, 퍼블릭 인터페이스에 어떤 것도 추가하지 않는다. -> 꼭 필요한 크기의 퍼블릭 인터페이스를 갖는다.
  2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.
     - 객체 인터페이스는 '무엇(What)'만 표현하고, '어떻게(how)'를 노출하면 안 된다. -> 메시지 선 식별을 통해 '무엇'에 초점을 맞추는 인터페이스 얻기 가능하다.

## 02.5 행동이 상태를 결정한다
객체의 존재 이유는 협력에 필요하기 때문이다.  
따라서 객체는 협력에 필요한 행동을 제공해야 한다.  
즉 객체의 상태보다 객체간 제공하는 행동에 집중해야 한다.  
  
객체가 협력에 참여하는 유일한 방법은 객체의 행동이다.  
객체지향 초보자들은 객체의 필요 상태를 결정한 후 행동을 결정한다.  
  
선 상태 후 행동은 객체 내부 구현이 퍼블릭 인터페이스에 노출되도록 만들어 캡슐화를 저해한다.  
객체 내부 구현 변경은 퍼블릭 인터페이스도 변경되고, 해당 객체에 의존하는 곳에 변경 영향이 전파된다.  
객체 내부 구현에 초점을 맞춘 설계 방법을 데이터 주도 설계(Data-Driven Design)이라 한다.  
  
객체의 상태는 단지 행동을 정상적으로 수행하기 위한 재료일 뿐이다.  
중요한 것은 객체의 '행동'이고, 행동이 '상태'를 결정한다.  

---

# 03. 역할

## 03.1 역할과 협력
객체는 협력 안에서 특정한 목적을 갖는다.  
객체의 목적은 협력 안에서 객체가 맡는 책임의 집합으로 표시된다.  
객체가 특정한 협력 안에서 수행하는 책임의 집합을 '역할'이라 한다.  
실무에서 협력을 모델링 할 때 객체가 아닌 역할에 책임을 할당한다고 생각해야 한다.  
  
영화 예매 시스템에서 '예매하라' 메시지 처리 객체로 Screening이 선택됐는데,  
선택된 단계는 두 개의 독립된 단계가 합쳐진 것이다.
1. 영화를 예매할 수 있는 적절한 역할 찾기
2. 역할 수행 객체로 Screening 객체 선택
  
역할에 이름을 부여하진 않았지만, 익명의 역할을 찾고 역할 수행 객체 선택 방식으로 진행됐다고 생각하는 것이 자연스럽다.  
  
왜 역할 이라는 개념을 추가해 설계과정을 더 복잡하게 만드는 것일까?  

## 03.2 유연하고 재사용 가능한 협력
역할은 유연하고 재사용 가능한 협력을 얻을 수 있게 해준다.  
- 역할 고려 없이 객체 책임 할당 예시
  1. Movie 가격 계산위해 할인 요금 필요
  2. '할인 요금 계산' 메시지를 외부 객체에 요청
  3. 인터페이스가 아닌 구현체 객체 (고정 금액, 퍼센트)
  
문제 해결을 위해 객체가 아닌 '책임'에 초점을 맞춰야 한다.  
책임 관점에서 고정 금액, 퍼센트 모두 '할인 요금 계산'이라는 동일한 책임을 갖는다.  
협력 안에서 두 객체를 동적으로 갈아 끼우려면 '역할'이 필요하다.  
  
역할이 두 종류의 구현체를 포괄하는 '추상화'라는 점에 주목하면 된다.  
추상화 이름 부여 -> DiscountPolicy  
  
요점은 동일 책임 수행 역할들을 하나로 통합할 수 있는 것이다.  

## 03.3 객체 대 역할
한 종류의 객체만 협력에 참여 할 때 '역할'을 고려하는 것이 유용할까?  
이런 경우 역할이 아닌 간단히 객체로 간주한다.  
  
설계 초반에 적절한 책임, 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 한다.  
역할과 객체를 명확하게 구분하는 것은 크게 중요하진 않다.  
즉 애매하다면 단순히 객체로 시작하고, 필요한 순간 객체를 역할로 분리하는 것이 가장 좋은 방법이다.  
중요한 것은 '책임'이다.  

## 03.4 역할과 추상화
추상화를 통한 설계의 두 가지 장점
1. 중요 정책을 상위 수준으로 단순화 가능
2. 설계가 유연해진다.

추상화의 장점이 협력 관점에서 '역할'에도 동일하게 적용된다.  
협력이라는 관점에서 세부사항을 무시하고 추상화에 집중하는 것이 유용하다.  
예를 들면 협력에 참여하는 할인 정책, 할인 조건의 종류는 중요하지 않다.  
구체적인 조합을 고려하지 않고 상위 수준에서 협력을 충분히 설명할 수 있다.  
객체에게 중요한 것은 '행동'이다.  
(메시지를 처리할 객체에게 메시지 처리 책임을 할당하고, 상태를 결정한다. 그리고 객체의 책임이 중복되는 경우 역할을 고려하면 된다.)  
  
설계가 유연해진다는 것은, 기존 코드 수정 없이 새로운 행동을 추가하거나 삭제 할 수 있다.  
프레임워크, 디자인 패턴 등 재사용 가능한 코드, 설계 아이디어 구성의 핵심 요소는 바로 '역할'이다.  

## 03.5 배우와 배역
연극 안에서 배우들은 자신이 맡은 배역을 충실히 연기한다.  
즉 연극 상영시 배우들은 자신들의 배역의 가면을 쓴다.  
- 연극의 배역과 배우 관계간 특성
  - 배역은 특정 연극에서 배우의 역할이다.
  - 배역은 연극 상영 중에만 존재하는 일시적 개념이다.
  - 연극이 끝나면 배우들로 돌아온다.
  - 동일한 배역은 여러 배우들이 맡을 수 있다.
  - 배우 한명이 서로 다른 배역을 맡을 수 있다.  
- 예시
  - 배역 -> 역할
  - 연극 -> 협력
  - 배우 -> 일시적 배역

협력 안에서 역할은 책임을 수행하는 객체의 일부다.  
역할은 객체가 협력에 참여하는 동안 일시적으로 존재한다.  
객체는 다양한 역할을 가질 수 있지만, 특정 협력 안에서 일시적으로 오직 하나의 역할만 수행한다.  

---

```text
느낀점 & 정리

단순히 특정 기능을 개발 할 때, 큰 틀로 다양한 객체들을 생각날 때마다 추가해 관계들을 구성했다.  
이게 서적에서 나오는 객체 본질에 집중하는 것과는 다른 것 같다.  
서적에서 나온 내용을 간략하게 내 기준으로 해석하면, 나무보다 숲을 보며 설계를 구현해야 하는 것이다.  
시스템이 제공하는 기능을 하나의 책임으로 바라보고, 그 책임을 협력이라는 관점에서 봤을 때, 객체를 구체적으로 정의하지 않고,
협력 안에서 어떤 객체들이 필요할지 객체들을 찾는다.  
그리고 메시지를 먼저 탐색 후 메시지 처리 할 객체를 찾아 책임을 할당한다. 그리고 객체의 상태를 결정한다.  
숲을 보지 않고 나무를 바라보거나 구현 관점에서 생각하고 기능을 개발 한다면, 진정으로 유연하고 재사용이 가능한 객체 설계가 되기 어렵다.

일시적으로 재사용, 유연해 보일 수 있겠으나, 객체 설계의 미묘한 차이가, 하나의 프로젝트에 여러 개발자가 모여 관리되다보면, 
의도를 정확하게 파악하기 어려워 그 틀에서 벗어나거나 잘못된 설계 방향으로 흘러갈 수 있을 것 같다.

실무를 하다보면, 객체 구성, 의존성 방향, DB 설계를 되게 빨리 내놓는 상황을 몇 번 접했었다.
속도가 중요하진 않지만, 빨리 내놓을 수 있는 이유 중 하나가 서적에 나온 고민을 하지 않았기 때문에 나왔다고 느낀적이 있다.
결과적으로 그 구성은 복잡했고, 설계는 빠르게 나왔지만, 그걸 분석하고 객체지향 설계에 적용하는 시간이 더 걸린 것 같다.

따라서 객체를 책임, 협력, 역할 관점에서 잘 이해하고 설계를 잘 녹여내 기능을 완성하는 것이 중요한 것 같다.
서적에 나온대로, 의존성 방향이나 객체의 추상적인 관계는 초반에 한 번에 완벽하게 하려기 보단, 우선 설계를 진행해보고,
애매한 부분은 역할이 아닌 구현체로 만들어가 가공 후 관계를 재적립해도 좋을 것 같다.
중요한 것은 객체의 '책임'이란 것을 잊지말자.

```
