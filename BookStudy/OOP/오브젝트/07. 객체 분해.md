# 서론
- 사람의 기억
  - 단기 기억
    - 직접 접근 가능
    - 정보 보관 속도, 공간 제약
    - **실제 문제 해결**
  - 장기 기억
    - 단기 기억으로 옮긴 후 접근 가능
    - 매우 큰 저장 용량
  
실질적으로 단기 기억을 통해 문제를 해결하는데, 그러나 기억 용량 초과시 인지 과부하가 걸릴 수 있다.  
인지 과부하 방지를 위해 필요한 정보 양을 조절해야 한다.  
필요한 정보란 불필요한 세부사항을 걸러낸 본질적인 정보다.  
  
큰 문제를 여러 단위의 작은 문제로 나누고, 또 더 작은 단위로 나눈다.  
즉 문제들을 분해하여 작은 단위로 만들어, 단기 기억 효율을 높인다.  
하나의 단위로 취급 될 수 있는 논리적인 청크(chunk)  
청크는 더 작은 청크를 퐇마하고, 연속적 분해가 가능하다.  
  
더 큰 추상화로 압축하여 단기 기억 한계를 초월 할 수 있다.  
11자리 번호 -> 휴대폰 번호  
  
---

# 01. 프로시저 추상화와 데이터 추상화
- 현대 프로그래밍 언어 두 가지 추상화 메커니즘
  1. 프로시저 추상화 (행위)
     - SW가 무엇을 해야 하는지 추상화
  2. 데이터 추상화 (상태)
     - SW가 무엇을 알아야 하는지 추상화
  
복잡성 극복 방법은 현재 문제를 해결 할 수 있는 효과적인 추상화 메커니즘과 분해 방법을 찾아야 한다.  

---

# 02. 프로시저 추상화와 기능 분해

## 02.1 메인 함수로서의 시스템
기능 분해 관점에서 추상화 단위는 프로시저다.  
프로시저는 반복적 실행, 유사 실행 작업들을 한 장소에 두고 재사용 및 중복 방지 추상화 방법이다.  
수학의 함수와 동일하다.  

## 02.2 급여 관리 시스템
- 설명
  1. 연초 연봉협상 후 1년간 지급
  2. 회사는 급여 지급시 소득 세율에 따라 일정 금액 세금 공제
  3. 직원 실제 급여 계산식 -> 급여: 기본급 - (기본급 * 소득세율)
- 급여 관리 시스템 구현을 위한 기능 분해 방법
  - 전통적 기능 분해 방법 -> 하향식 접근법
  - 직원 급여 계산
    - 소득 세율 입력
      - 세율 입력 창 화면에 출력
      - 키보드를 통해 세율을 입력
    - 직원 급여 계산
      - 기본급 정보 전역 변수로 저장
      - 급여 계산
    - 결과 출력
      - 결과 형식에 맞는 출력
  
기능 분해는 최상위 기능 정의 후 필요 절차를 나열한다.  
기능 중심으로 필요 데이터를 결정한다. (주: 기능, 부가: 데이터)  
이는 유지보수에 다양한 문제를 야기한다.  

## 02.3 급여 관리 시스템 구현
- 루비 언어로 구현
- 최상위 추상 메인 함수 정의
  - 구현 가능 수준까지 세부 단계로 분해
    - 트리로 표현 가능
      - 트리의 노드 하나는 시스템 구성 하나의 프로시저 의미
      - main
        - getTaxRate
          - print...
          - return...
        - calculatePayFor
          - index = ...
          - basePay = ...
        - describeResult
          - return ...
          - return ...
  
최상위 추상화를 기준으로 세부적인 분해를 통한 하향싱 기능 분해는 논리적이고 쳬게적인 시스템 개발 절차를 제시한다.  
그러나 문제가 있다.  

## 02.4 하향싱 기능 분해의 문제점
겉보기엔 이상적으로 보이나, 다양한 문제를 직면한다.
- 하향식 기능 분해 문제점
  1. 요구사항 변경에 유연하게 대처 하지 못한다.
  2. 너무 이른 시기에 함수 실행 순서 고정 -> 유연성, 재사용성 저하
  3. 데이터 형식 변경으로 인한 파급 효과 예측 불가
  
하향식 기능 분해는 변경에 취약한 설계가 나온다.  
최상단 추상화가 흔들리면 분해된 하위들도 흔들린다.  
설계 시작시부터 시스템이 "어떻게"에 초점을 둔다. **"무엇을" 해야하는지에** 초점을 둬야 한다.  
모든 문제의 원인은 결합도다.  

## 02.5 언제 하향식 분해가 유용한가?
하향식 기능 분해가 결합도 문제가 생긴다고 해도 적합한 때는 있을 거다.  
설계가 어느정도 안정화된 후 논리적 설명, 문서화에 용이하다.  
즉 좋은 구조로 설계하는 방법은 아니다.  
  
하향식 분해는 프로젝트 초기에 설계의 본질을 무시하고 사용자 인터페이스와 같은 비본질적인 측면에 집중한다.  
근본적으로 결합도가 높고, 재사용이 어렵다.  

---

# 03. 모듈

## 03.1 정보 은닉과 모듈
시스템 변경의 기본적인 전략은 함께 변경되는 것을 묶어 퍼블릭 인터페이스를 통해 접근하게 하는 것이다.  
즉 기능 기반이 아니라 변경 방향에 맞춰 시스템을 분해한다.  
  
정보 은닉은 자주 변경되는 부분을 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.  
모듈과 기능 분해는 상호 배타적인 관계가 아니다.  
모듈 분해는 감춰야 하는 비밀을 선택하고 인터페이스 뒤로 감춘다.  
- 모듈이 감춰야 할 두 가지 비밀
  1. 복잡성
  2. 변경 가능성
  
가장 일반적인 비밀은 "데이터"다.  
그러나 반드시 데이터일 필요는 없다.  
데이터, 복잡한 로직, 자료구조 등이 될 수 있다.  
  
앞선 장에서 나왔던 아무리 객체를 캡슐화해도, getter, setter를 남발하면 본연의 캡슐화, 정보 은닉이 되지 않는다.  
비밀 정보를 숨기고 퍼블릭 인터페이스를 통해 접근 가능하도록 해야 한다.  
퍼블릭 인터페이스는 인터페이스 그 자체가 될 수도 있고, 메서드가 될 수도 있는 것 같다.  

## 03.2 모듈의 장점과 한계
- 장점
  - 모듈 내부 변수 변경 -> 모듈 내부에만 영향
  - 비즈니스 로직과 사용자 인터페이스 관심사 분리
    - 사용자 입력, 화면 출력 등을 모듈이 아닌 외부에 둘 수 있다.
  - 전역 변수, 전역 함수 제거를 통해 네임스페이스 오염 방지
  
모듈은 변경 정도에 따라 시스템을 분해하게 한다.  
모듈을 통해 데이터와 함수를 외부에 감출 수 있다.  
따라서 높은 응집도를 유지할 수 있다.  
모듈간 통신은 퍼블릭 인터페이스를 통해서만 한다.  
모듈의 핵심은 데이터다.  
모듈을 통해 감출 데이터를 결정하고 데이터 조작을 위한 필요 함수를 결정한다.  

---

# 04. 데이터 추상화와 추상 데이터 타입

## 04.1 추상 데이터 타입
추상 데이터 타입을 통해 객체를 현실 세상 방식에 근접해지도록 수준을 향상시킬 수 있다.  
추상 데이터 타입은 말그대로 시스템 상태 저장 데이터를 표현하고 핵심 로직은 외부에 존재한다.

---

# 05. 클래스

## 05.1 클래스는 추상 데이터 타입인가?
클래스, 추상 데이터 타입 모두 외부에서 객체 내부 속성을 직접 접근 할 수 없다.  
명확한 의미에서 둘은 동일하지는 않다.  
클래스는 상속과 다형성을 지원하지만, 추상 데이터 타입은 지원하지 않는다.  
  
즉 추상 데이터 타입은 **"타입" 추상화**, 클래스는 **"절차" 추상화**를 한다.  
- 타입 추상화 예시
  - Employee
    - 정규 직원
    - 아르바이트 직원
  - 하나의 타입처럼 보이지만, 두 개의 타입이 공존한다 -> 구체적인 타입을 외부에 캡슐화
  - 타입 추상화는 오퍼레이션을 기준으로 타입을 통한한 데이터 추상화 기법
  - 타입 추상화 기반 대표 기법 -> 추상 데이터 타입
  
추상 데이터 타입은 오퍼레이션을 기준으로 타입을 묶는다.  
객체지향은 타입을 기준으로 오퍼레이션을 묶는다.  
결과적으로 객체지향은 정규직, 아르바이트 각 클래스 정의 후 오퍼레이션을 적절하게 구현한다.  
  
정규직, 아르바이트 각 클래스로 구분한다면, 공통 로직을 어디에 둘 것인가?  
- 부모 클래스 정의 후 상속 (다형성)
  
## 05.2 추상 데이터 타입에서 클래스로 변경하기
Employee 타입 안에 두 가지 직원 타입을 캡슐화하는 추상 데이터 타입을 알아봤다.  
클래스를 이용한다면 두 직원 타입을 독립적인 클래스로 구현한다.  

## 05.3 변경을 기준으로 선택하라
객체지향 분해에서 타입을 기준으로 절차를 추상화해야 한다.  
그 방식이 타입 추상화, 클래스 중 어떤 것이라도 말이다.  
  
객체 내부 인스터늣 변수 저장 값을 기반으로 메서드 내 타입을 명시적 구분하는 방식은 객체지향을 위반한다.  
객체지향에서 타입 변수 이용 조건문은 **다형성**으로 대체한다.  
클라이언트가 객체 타입 확인 후 적절한 메서드를 호출하는 것이 아니다.  
객체가 직접 메시지 처리에 적절한 메서드를 선택한다.  
  
조건문 사용 방식 기피 이유는 변경이다.  
타입 추가나 삭제, 변경 마다 클라이언트 조건문을 찾아 모두 수정해야 한다.  
객체지향은 새로운 유형 추가시 구현 클래스에 상속 계층을 추가하고 필요한 메서드를 오버라이딩하면 된다.  
즉 개방-폐쇄 원칙(OCP)를 통해 변경, 확장이 쉬운 구조로 설계하자.  
  
다시 한 번 상기하자.  
설계는 변경 관련됐다.  
변경 방향성, 발생 빈도에 따라 적절하게 구성해야 한다.  
  
변경의 압력은 타입 추가, 오퍼레이션 추가 등에 따라 설계의 유용성이 달라진다.  
타입 추가는 다형성을 활용하고, 오퍼레이션 추가를 통한 변경이라면 상속 계층에 속하는 모든 클래스 한 번에 수정!  
  
새로운 타입을 빈번하게 추가해야 되는 경우 클래스 구조가 더 유용하다.  
객체지향 접근법이 모든 경우 옳다고 생각하지 말자. 합리성을 잘 따져봐야 한다.  
  
## 05.4 협력이 중요하다
객체지향에서 가장 중요한 것은 역할, 책임, 협력이다.  
모든 객체지향 원칙을 지킨다고 해도 협력이라는 문맥을 고려하지 않는다면 올바르지 않을 수 있다.  
  
객체가 참여할 협력, 스스로 움직이는 자율적인 객체, 메시지 등을 고민하자.  
  
---

```text
느낀점 & 정리

인간은 단기 기억, 장기 기억 이용해 학습하고 활동한다.
결국 단기 기억을 통해 활동을 하는데, 이 단기 기억을 효율적이고 합리적인 방법들이 존재한다.
서적에서 나왔듯이 핸드폰 번호를 숫자 하나하나 외우는 대신, 3-4-4로 외운다던가 하는 방법 말이다.

소프트웨어도 비슷한 면이 있는 것 같다.
오히려 더 어렵기도 한 것 같다.
단기 기억, 장기 기억은 하나의 생명체에서 무의식에서도 학습하고 활동 할 수 있지만,
SW는 효율과 합리적인 선택 그리고 고민을 곁들이지 않는다면 빠르게 노후되어 간다.

소프트웨어가 노후화를 방지하는 방법 중 하나는 설계를 잘하는 것이다.
설계는 서적에서도 반복적으로 얘기했듯 변경에 대응하기 위한 것이다.
그리고 더 나쁜 코드를 양성하지 않는 길이기도 한 것 같다.

설계를 할 때, 하향식 접근법을 통해 기능 분해를 하며 진행할 수 있다.
다만 너무 빠른 시기에 이르게 결정되기 때문에, 요구 사항 변경 등의 사유에 적합하지 않은 선택이 될 수 있다.
그렇다고 항상 나쁜 방식은 아니다.
적절한 곳에 적절하게 쓰게 된다면 하향식 접근 방법이 설계에 옳지 않아도 유용한 정보가 될 수 있다.
서적에서도 무언가를 이해시키는 방법으로 안 좋은 설계를 먼저 실행하고 이후 리팩터링을 통해 독자에게 이해를 시키는 방식이 있는 것 처럼,
안 좋은 것을 알고 인지하고 있다는 것 그 자체만으로 좋은 설계를 할 수 있는 하나의 방안이 될 수 있다.

다만 좁은 시야에서 내가 알고 있는 원칙, 경험들을 항상 고집하면 안 된다.
원칙이지 법칙이 아니란 것을 항상 인지하고 더 꺠달을 필요가 있다는 것을 서적을 읽으면서 깨닫고 있다.
설계는 트레이드 오프의 산물이라고 한 것 처럼, 객체지향의 초점을 맞춰 역할, 책임, 협력 안에서 우리 도메인에 적합한 원칙과 방향성을 계속 고민하는 경험이 필요하다.

타입 추가도 무조건적으로 클래스 추가를 통한 다형적 구조로 해야된다는 강박에 빠질 필요가 없을 것 같다.
변경 방향성이나 빈도에 따라 더 적합하고 현명한 팀 프로젝트, 코드를 향해 조금 더 고민하고 공부를 해야 될 필요를 느끼는 챕터였다.
```










































