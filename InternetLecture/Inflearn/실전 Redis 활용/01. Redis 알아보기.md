# Redis 소개
- Reids: Remote Dictionary Server
  - Remote 서버란 이유는 각 서버에 Local하게 존재하지 않고, 여러 서버가 공통 사용 가능하도록 원격에 저장
  - Dictionary 
    - HashMap처럼 Key/Value 형태로 상수의 시간 복잡도로 사용 가능하다.
- 분산된 서버가 공통으로 사용할 수 있는 해시 테이블
- 표준 C로 작성된 오픈소스 인메모리 데이터 저장소
  - 백업을 제외한 모든 데이터를 램에 저장
    - 램은 매우 빠르다. 관계형 DB와 다른 구조와 특징을 갖는다.
- 대중성으로 6위
  - Key/Value 저장소 중에서는 압도적 1위

# Redis 특징과 장점
- 레디스 특징
  - 인메모리(RAM)에 모든 데이터 저장
    - 백업, 스냅샷 제외
    - 실질적으로 사용하는 데이터는 모두 RAM에 저장
  - 단일 Thread에서 모든 Task 처리
    - 멀티 쓰레드는 분명한 장점이 있지만, 프로그래밍 복잡도를 증가시킨다.
    - 단순 디자인 채택 -> 장점으로 뛰어난 성능, 사용만 잘하면 사이드 이펙트가 없는 안정적 기술
  - 클러스터 모드 지원 -> 다중 노드에 데이터를 분산 저장하여 안정성 & 고가용성 제공
  - Persistence -> 인메모리 특성상 휘발성 데이터 저장
    - RDB(Redis Database) + AOF(Append only file)을 통해 영속성 옵션 제공
      - 데이터를 안전하게 영속적으로 저장 가능
  - Pub/Sub -> Pub/Sub 패턴 지원하여 손쉽게 앱 개발 가능
    - 실시간 채팅, 알림 서비스 손쉽게 개발 가능

- 레디스 장점
  - 매우 높은 성능
    - 모든 데이터를 메모리에 저장, 매우 빠른 읽기/쓰기 속도 보장
  - 다양한 데이터 타입 지원
    - 직관적 인터페이스로 구현, 전반적 성능 매우 뛰어나, 다양한 기능 매우 쉽게 구현 가능
  - 다양한 언어로 작성된 클라이언트 라이브러리 지원 (백엔드와 쉽게 연동 가능)
  - 다양한 사례, 커뮤니티 활성화
    
# Redis 주요 사용 사례
1. 캐싱
   - 임시 비밀번호 (One-Time Password)
   - 로그인 세션 (Session)
2. Rate Limiter
   - Fixed-Window / Sliding-Window Rate Limiter (비율 계산기)
   - 보통 서버에서 특정 API에 대한 요청 횟수 제한, 레디스를 이용해 쉽게 구현 가능
3. Message Broker
   - 메시지 큐
     - Lists, Streams 데이터 타입 활용하여 구현 가능 
       - 서비스간 Coupling 줄일 수 있다.
4. 실시간 분석 / 계산
   - 순위표(Rank / Leaderboard)
     - Score에 따라 순위를 표시
   - 반경 탐색 (Geofencing)
     - 좌표 활용
   - 방문자 수 계산 (Visitors Count)
     - 실시간 방문자 수 계산
5. 실시간 채팅
   - Pub/Sub 패턴 활용

# Redis 영속성 (Persistence)
- 영속성 (Persistence)
  - 레디스는 주로 캐시로 사용되지만, 영속성 옵션 제공
  - 일반적으로는 손실되도 무방한 데이터를 휘발성으로 저장
  - 캐시라 할지라도 데이터 손실로 서비스 지연, 장애 상황으로 이어질 수 있다.
    - 이럴 때 SSD와 같은 영구적 저장 장치에 데이터 저장
  - RDB (Redis Database)
    - 특정 시간에 스냅샷을 생성하는 기능
      - Point-in-time Snapshot
        - 재난 복구 (Disaster Recovery) 또는 복제에 주로 사용
          - 장애 상황 발생시 특정 시점으로 빠르게 되돌린다. 
          - 동일 데이터 캐시 복제
      - 스냅샷 특성상 새로운 스냅샷 생성 이전, 일부 데이터 유실이 있을 수 있다.
        - 생성 중 레디스 성능 지연 발생 -> 서비스 요청 처리에 일정 시간 지연 발생
  - AOF (Append Only File)
    - 레디스에 적용되는 모든 Write 작업을 모두 로그로 저장
    - 데이터 유실 위험 낮지만, 재난 복구시 Write 작업 다시 적용 -> RDB(스냅샷 방식) 보다 속도 느림
- RDB, AOF를 아예 사용하지 않거나, 모두 사용하거나, 필요한 것만 사용하거나, 앱 용도에 맞게 적절히 사용하면 된다.

# Caching
- 데이터를 빠르게 읽고 처리하기 위해 임시로 저장하는 기술
  - 계산된 값 임시 저장, 동일 요청 또는 계산 할 때 사용
- Cache: 임시 저장소

- 사용 사례
  - 컴퓨터 공학 전반에 다양하게 사용
  - CPU 캐시
    - CPU, RAM 속도차이 엄청난다.
      - 지연을 줄이기 위해 CPU 주변에 L1, L2, L3 캐시 사용 -> 효율적 동작 보장
  - 웹 브라우저 캐싱
    - 웹 브라우저가 웹 페이지 데이터 로컬에 저장, 재방문시 사용
  - DNS 캐싱
    - 이전에 조회한 도메인 이름, IP 주소를 저장하여 재요청시 사용
    - TTL 설정: 시간 값에 따라 데이터 캐싱 시간 결정
  - 데이터베이스 캐싱
    - RDBMS -> 버퍼풀에 자주 사용하는 데이터를 메모리에 미리 올려놓고 사용
  - CDN
    - 이미지, 큰 파일을 올려놓고 사용한다.
      - 물리적인 거리가 멀다면, 네트워크에 따라 전송되며 시간이 오래 걸린다.
        - CDN을 활용해 POP 서버에 파일들을 미리 옮겨놓고, 요청시 가장 가까운 Pop Server에서 파일을 응답, 네트워크 지연시간을 줄인다.
  - 어플리케이션 캐싱
    - 레디스를 활용해, 백엔드 서버에서 사용, 데이터나 계산 결과 캐싱하여 반복적 작업을 최적화
  - 다양한 사례가 더 있지만 생략
- 캐싱을 제대로 이해해야 다양한 서비스를 목적에 맞게 잘 활용할 수 있다.

# Cache Hit & Cache Miss
- 레디스 서버에 특정 Key로 요청
  - Cache Hit -> 정상적인 응답 (캐시 데이터 존재)
  - Cache Miss -> Key 없음 또는 만료로 비정상 응답 (케시 데이터 미존재)
    - 아무 것도 Return 되지 않는다.

# Cache-Aside pattern
- 캐시 전략 중 하나의 패턴
  - 캐싱 사용 패턴 중 가장 흔한 형태로 무조건 알고 있어야 한다.
- 애플리케이션에서 클라이언트 요청을 처리할 때, 먼저 캐시 조회
  - Cache Hit -> 캐시 사용
  - Cache Miss -> 원본 스토리지에서 데이터 조회하여 캐싱 후 반환
- 그 외 패턴
  - 일반적인 앱에서는 자주 사용되지 않는다.
  - write through
  - write behind