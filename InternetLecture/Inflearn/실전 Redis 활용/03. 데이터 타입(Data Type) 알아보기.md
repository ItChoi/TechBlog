- 레디스에서 지원하는 데이터 타입을 알아보자.
  - 설명 + 명령어 실습

# Strings
- 문자열, 숫자, serialized object(json string) 등 저장
- 레디스는 데이터 타입에 따라 명령어가 다르다.
  - Strings
    - SET key value
      - value에 json string을 직접 저장 가능
    - MSET key value key value
      - 다중 String 값을 한 번에 저장
    - MGET key key key
      - 다중 Key의 값을 한 번에 반환
    - INCR price
      - 별도 Integer 타입 없이 숫자를 String에 저장
      - 숫자 형태 String 저장 시 +, - 연산 가능
        - 해당 명령어는 +1 명령어
    - INCRBY price 10
      - 숫자 string 값에 특정 값을 더할 때 사용
    - SET key:ko:price 200
      - 의미 단위를 콜론으로 구분하여 세팅
        - 반드시 지켜야 하는 것은 아니지만, 레디스 컨벤션
        - json value에 값을 추가, 저장하는 것이 아니라 단순 하나의 변수 생성이지만 의미를 부여하는듯

- 실습
  - SET lecture inflearn-redis
  - MSET price 100 language ko
  - MGET lecture price language
  - INCR price
    - +1
  - INCRBY price 9
    - +9
  - SET inflearn-redis '{"price": 100, "language": "ko"}'
  - GET inflearn-redis
  - SET inflearn-redis:ko:price 200

# Lists
- String을 Linked List로 저장 -> push / pop에 최적화 O(1)
- Queue(FIFO), Stack(FILO) 구현에 사용
- 명령어
  - LPUSH queue job1 job2 job3
    - RPOP queue (FIFO)
  - LPUSH stack job1 job2 job3
    - LPOP stack (FILO)
  - LPUSH queue job1 job2 job3
    - LRANGE queue-2 -1
      - 뒤에서 2번째 아이템부터 뒤에서 첫번째 아이템까지 조회 -> 가장 먼저 추가된 아이템 조회
      - 다수 아이템 조회 (인덱스 이용)
      - 왼쪽부터 카운팅시 0부터 시작 (0, 1, 2, ...)
      - 오른쪽부터 카운팅시 -1 부터 시작 (-1, -2, -3, ...)
  - LTRIM queue 0 0
    - 나머지 부분만 남길 수 있다. (?)
    - 0번째 인덱스만 남기고 모두 삭제
- 리스트를 이용해 간단한 메시지 브로커 구현 가능하다.
- LPUSH
  - <로 쌓인다. 3 2 1
- RPUSH
  - >로 쌓인다. 1 2 3

- 실습
  - LPUSH queue job1 job2 job3
  - RPOP queue
    - job1
  - LPUSH stack job1 job2 job3
  - LPOP stack
    - job3
  - LPUSH queue job 4 job5
  - LRANGE queue 0 -1
    - 가장 첫 번째 ~ 가장 마지막 아이템까지 다 출력
      - job -> 5,4,3,2
  - LTRIM queue 0 1
    - job -> 5, 4만 남음

# Sets
- 유니크한 String 값 저장, 정렬 X
- 집합 연산이 존재한다.
  - 교집합 (intersection)
  - 합집합 (union)
  - 차집합 (difference)
- 명령어
  - SADD user:1:fruits apple banana orange orange
  - SADD user:2:fruits apple lemon
  - SADD user:3:fruits apple
  - SADD user:4:fruits apple lemon
  - SMEMBERS user:1:fruits
    - Set의 모든 데이터 조회
  - SCARD user:1:fruits
    - Set의 카디널리티 조회 -> Set의 데이터 개수
  - SISMEMBER user:1:fruits banana
    - Set에 해당 value가 포함됐는지 체크
      - 1: 존재
      - 0: 미존재
  - SINTER user:1:fruits user:2:fruits user:3:fruits user:4:fruits
    - 교집합 데이터
  - SDIFF user:1:fruits user:2:fruits user:3:fruits
    - user2의 레몬은 안나오네???
      - 기준 데이터가 첫 번 째 나오는 Set (user:1) 따라서 안 나오는게 맞다.
    - 차집합 데이터
  - SUNION user:1:fruits user:2:fruits user:3:fruits user:4:fruits
    - 합집합 데이터

- 실습
  - SADD user:1:fruits apple banana orange orange
  - SMEMBERS user:1:fruits
  - SCARD user:1:fruits
  - SISMEMBER user:1:fruits banana
  - SADD user:2:fruits apple lemon
  - SINTER user:1:fruits user:2:fruits
  - SDIFF user:1:fruits user:2:fruits
  - SUNION user:1:fruits user:2:fruits

# Hashes
- field, value 구조를 갖는다.
  - dictionary 또는 map과 유사한 개념
  - 다양한 속성 데이터 저장시 유용
- 명령어
  - HSET lecture name inflearn-redis price 100 language ko
    - 다수의 field, value를 한 번에 저장 가능
      - key는 lecture 그 후 field, value, ...
  - HGET lecture name
    - 하나의 필드 조회
    - key field, key만 입력 X
  - HMGET lecture price language invalid
  - HINCRBY lecture price 10

- 실습
  - HSET lecture1 name inflearn-redis price 100 language ko
  - HGET lecture1 price
  - HMGET lecture1 name price language aaaa
    - 존재하지 않는 aaaa는 nil 반환
  - HINCRBY lecture1 price 10
    - 숫자형이 아닌 경우 타입 에러 발생 -> 숫자형 스트링에만 사용 가능

# Sorted Sets
- 중복은 없지만, score라는 추가적인 필드를 갖고 있어서 이를 통해 정렬된 집합
- 레디스만의 독특한 데이터 타입
  - 내부적으로 Skip List + Hash Table로 이루어지고, score 필드를 통해 정렬 유지
- score가 동일하다면 lexicographically (사전 편찬 순) 정렬
- ZSet이라고 불린다.
- 명령어
  - ZADD points 10 TeamA 10 TeamB 50 TeamC
    - points key
  - ZRANGE points 0 -1
    - 순서를 갖기 때문에 List와 마찬가지로 RANGE를 통해 특정 범위 조회 가능
    - 가장 처음부터 가장 마지막까지 조회
  - ZCARD points
    - 아이템 개수
  - ZRANGE points 0 -1 REV WITHSCORES
    - REV: reverse
    - 역순 반환, score와 함께 반환
  - ZRANK points TeamA
    - 아이템의 랭킹을 반환 (0부터 시작) -> sorted set의 인덱스 반환

- 실습
  - ZADD points 10 TeamA 10 TeamB 50 TeamC
  - ZRANGE points 0 -1
  - ZRANGE points 0 -1 REV WITHSCORES
  - ZRANK points TeamB

# Streams
- append-only log에 consumer groups과 같은 기능을 더한 자료 구조
  - 카프카 등 이벤트 스트리밍 플랫폼과 어느정도 유사한 부분이 있다.
  - append-only log: DB나 분산 시스템에 주로 사용, 데이터 수정/삭제가 아니라 추가만 되는 구조
- 추가 기능
  - unique id로 하나의 엔티티 조회시 O(1)
    - unique id: 시간과 순서로 레디스에 의해 자동 할당
  - Consumer Group을 통해 분산 시스템에서 다수의 consumer가 event 처리
    - 안전하게 메시지를 컨슈밍 할 수 있도록 컨슈머 그룹이 포함되어 있다.
      - product -> event1/event2/event3 -> consumer group(consumer1, consumer2)
        - 다수의 컨슈머가 메시지를 처리하면서도, 동일한 메시지를 중복 처리 가능하다. 
- 명령어
  - XADD events * action like user_id 1 product_id 1
    - key(events) 이후 '*' 추가시 레디스에 의해 unique id가 자동 할당된다.
  - XADD events * action like user_id 2 product_id 1
  - XRANGE events - +
  - XDEL event ID
    - 스트림에서 이벤트 제거

- 실습
  - XADD events * action like user_id 1 product_id 1
    - '*' 옵션을 통해 자동 할당 받고, 고유 id 출력
    - events 스트림 생성
    - action -> 1번 유저가 1번 제품의 좋아요를 눌렀다는 의미
    - 데이터를 보고, 구매가 이루어지지 않으면 쿠폰 발급, 추천 상품 권유 등의 행위로 이루어질 수 있다.
  - XADD events * action like user_id 2 product_id 1
  - XRANGE events - +
    - 가장 처음 들어간 이벤트부터 ~ 추가된 이벤트를 볼 수 있다.
  - XDEL events 1706418974084-0

# Geospatial

# Bitmaps

# HyperLogLog

# BloomFilter