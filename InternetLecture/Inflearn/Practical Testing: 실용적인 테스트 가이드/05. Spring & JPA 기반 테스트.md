# 레이어드 아키텍처 (Layered Architecture)와 테스트
- 스프링 MVC 기반에서 가장 많이 사용
- 이용자 요청
  - 레이어 별로 끊어서 개발 (3 또는 4 티어 )
    - Presentation Layer
    - Business Layer
    - Persistence Layer
    - Infrastructure Layer
- 왜 분리할까? -> 관심사의 분리 -> 유지보수, 관리에 더 용이하도록 책임을 나눈다.
- A, B 각 모듈이 있을 때, 여러 객체가 협럭 하는 기능일 때 어떻게 동작할것인지 예측 가능할까?
  - A-B, B-A, C?
    - 통합 테스트가 필요하다.
- 통합 테스트
  - 여러 모듈의 협력을 통합적 검증
  - 작은 범위의 단위 테스트만으로 기능 전체 신뢰성 보장 불가
  - 풍부한 단위 테스트 + 큰 기능 단위 검증 통합 테스트

# Spring / JPA 훑어보기 & 기본 엔티티 설계
- 라이브러리와 프레임워크의 차이는?
  - 라이브러리는 내 코드가 능동적인 주체가 된다.
  - 프레임워크는 이미 동작 가능한 환경들이 구성되어, 내 코드는 수동적인 역할을 하게 된다.
- Spring
  - IoC
    - 객체에 대한 생명 주기를 제 3자에게 맡긴다.
  - DI
  - AOP
- ORM
  - 객체 기반 패러다임, 관계형 기반 패러다임의 불일치
  - 이전에는 객체지향적으로 객체를 만들어도, 데이터를 한땀한땀 DB에 저장 해야 했다.
  - ORM을 통해 단순 작업 줄이고, 비즈니스 로직에 집중
- JPA
  - Java Persistence API
  - 자바 진영 ORM 기술 표준
  - JPA는 인터페이스, 구현체로 Hibernate가 있고, Spring은 JPA를 한 번 더 추상화한 Spring Data JPA를 제공한다.
  - QueryDSL -> 타입 체크, 동적 쿼리 등 이점
- 엔티티 설계 - 카페 키오스크(주문)
  - Order
  - Product (메뉴)
  - 두 엔티티는 다대다 관계 -> 1:N - N:1로 풀자.
    - OrderProduct를 둔다.
  
# Persistence Layer 테스트 (1)
- Data Access 역할
- 비즈니스 가공 로직은 포함시키지 않는다. -> Data에 대한 CRUD에만 집중한 레이어

- 요구사항
  - 키오스크 주문을 위한 상품 후보 리스트 조회
  - 상품 판매 상태: 판매중, 판매 보류, 판매 중지
  - id, 상품 번호, 상품 타입, 판매 상태, 상품 이름, 가격

# Persistence Layer 테스트 (2)
- Repository Layer 테스트 -> 스프링을 띄워서 통합 테스트를 하지만 단위 테스트 성격에 가깝다. (데이터 접근만 할 뿐)
  - 검색 조건, JPQL, QueryDSL 등을 사용하는 경우 구현 방법, 기술이 변경될 수 있기 때매 테스트 코드 작성이 필요하다.
  - 미래에 어떻게 변경될지 모른다. 쿼리 결과에 대한 보장이 필요
```java

@ActiveProfiles("local-test")
@DataJpaTest // 스프링 서버를 띄워 테스트, SpringBootTest보다 가볍다. Jpa 관련 Bean들만 띄워 빠르게 해주지만, 강사는 @SpringBootTest를 선호
//@SpringBootTest // 스프링 서버를 띄워 테스트
class ProductRepositoryTest {
  @Autowired
  private ProductRepository productRepository;
  
  @org.junit.jupiter.api.DisplayName("원하는 판매상태를 가진 상품들을 조회한다.")
  @org.junit.jupiter.api.Test
  void test() {
    // given
    Product p1 = new Product("판매중");
    Product p2 = new Product("품절");
    Product p3 = new Product("판매중지");

    productRepository.saveAll(List.of(p1, p2, p3));
      
    // when
    List<Product> products = productRepository.findAllByStatus("판매중", "품절");
      
    // then
    assertThat(products).hasSize(2)
            .extracting("productNumber", "name") // 검증할 필드만 추출
            .containsExactlyInAnyOrder(
                tuple("001", "아메리카노", "판매중"),  // 추출 필드에 맞춰 tuple 활용    
                tuple("002", "카페라떼", "품절")      
            );
  }
}
```
- given / when / then 순서로 잘 작성하면 된다. @SpringBootTest 활용! -> 데이터 접근 필요
    

# Business Layer 테스트 (1)
- 비즈니스 로직 구현 역할
- Persistence Layer와 상호 작용(데이터 읽고 쓰는 행위)을 통해 비즈니스 로직을 전개
- 트랜잭션 보장해야 한다. -> 작업 단위 원자성 보장
- Business Layer 테스트는 Business Layer + Persistence Layer와 통합적인 느낌의 테스트

- 요구사항
  - 상품 번호 리스트를 받아 주문 생성
  - 주문은 주문 상태, 주문 등록 시간을 가진다.
  - 주문의 총 금액을 계산 할 수 있어야 한다.

```java
//@DataJpaTest
@DSpringBootTest
class OrderServiceTest {
  @Autowired
  private OrderService orderService;
  @Autowired
  private ProductRepository productRepository;
  
  @org.junit.jupiter.api.DisplayName("주문번호 리스트를 받아 주문을 생성한다.")
  @org.junit.jupiter.api.Test
  void test() {
    // given
    Product p1 = new Product("판매중", 1, 1000);
    Product p2 = new Product("품절", 2, 2000);
    Product p3 = new Product("판매중지", 3, 3000);

    productRepository.saveAll(List.of(p1, p2, p3));
    OrderCreateRequest request = new OrderCreateRequest(List.of(1, 2));
    
    // when
    OrderResponse orderResponse = orderService.createOrder(request);
      
    // then
    assertThat(orderResponse.getId()).isNotNull(); // ID가 비어있지 않는 것이 중요
    assertThat(orderResponse)
            .extracting("등록시간", "totalPrice")
            .contains(LocalDateTime.now(), 3000);
    assertThat(orderResponse.getProducts()).hasSize(2)
            .extracting("id", "price")
            .containsExactlyInAnyOrder(
                    tuple(1, 1000),
                    tuple(2, 2000)
            );
  }
}

class OrderTest {
    @org.junit.jupiter.api.DisplayName("주문 생성 시 상품 리스트에서 주문의 총 금액을 계산한다.")
    @org.junit.jupiter.api.Test
    void test() {
      // given
      List<Product> products = List.of(
              new Product("판매중", 1, 1000),
              new Product("품절", 2, 2000),
              new Product("판매중지", 3, 3000)
      );
      
      // when
      Order.create(products);
      
      // then
      assertThat(order.getTotalPrice()).isEqualsTo(6000);
    }

  @org.junit.jupiter.api.DisplayName("주문 생성 시 주문 상태는 INIT이다.")
  @org.junit.jupiter.api.Test
  void test() {
    // given
    List<Product> products = List.of(
            new Product(1, 1000),
            new Product(2, 2000),
            new Product(3, 3000)
    );

    // when
    Order.create(products);

    // then
    assertThat(order.getOrderStatus()).isEqualsByCompareingTo(OrderStatus.INIT); // isEqualsByComparingTo: Enum 그 자체로 비교 해주는 메서드 
  }

  @org.junit.jupiter.api.DisplayName("주문 생성 시 등록 시간을 기록한다.")
  @org.junit.jupiter.api.Test
  void test() {
    // given
    LocalDateTime now = LocalDateTime.now();
    List<Product> products = List.of(
            new Product(1, 1000),
            new Product(2, 2000),
            new Product(3, 3000)
    );

    // when
    Order.create(products, now);

    // then
    assertThat(order.getRegisterDateTime()).isEqaulto(now); 
  }
}
```
- TDD로 테스트를 진행하며, 단위 테스트가 필요한 객체가 만들어지면 같이 진행한다.

# Business Layer 테스트 (2)

# Presentation Layer 테스트 (1)

# Presentation Layer 테스트 (2)

# 키워드 정리