# 15. TCC 란 무엇인가?
- Try-Confirm-Cancel
- 분산 시스템에서 데이터 정합성 보장
- 분산 트랜잭션 처리 방식
- 트랜잭션을 세 단계로 나누어 처리
  - 멱등하게 설계되어야 한다.
  1. Try
     - 필요 리소스 점유 가능한지 검사 후 임시 예약
  2. Confirm
     - 실제 리소스 확정 처리 반영
  3. Cancel
     - 문제가 있는 경우 원복
- 장점
  - 확장성
  - 성능
  - 2PC에 비해 DB Lock 점유 시간이 짧음
  - 2PC에 비해 Long Transaction 덜 취약
  - 장애 복구 재시도 처리 유연
- 단점
  - 설계와 구현 복잡
  - 모든 단계는 멱등적 설계 필요
  - 네트워크 오류, 재시도 시나리오 고려한 복잡 로직 구현 필요
---
# 16. TCC 구현하기(1) - Product Try API 구현하기
- 편의를 위해 git branch 사용
- git init
- tcc 브랜치 추가 
# 17. TCC 구현하기(2) - 동시성문제 해결하기
- 현재 구현에서 발생할 수 있는 동시성 문제
- 하나의 주문 -> 하나만 실행되도록 Lock
- 상풍 -> Lock이 걸려있지 않다.
  - 여러 개 주문에서 동일 상품 구매 -> 동시성 문제 발생 가능
- 상품 수량 -> 2 + 5 -> 5개가 된다. 이후 요청으로 이전 업데이트 내역 유실
  - Optimistic Lock을 통해 해결 가능
    - 버전 컬럼을 통해 동시성 제어
      - version 1 -> 업데이트 / version: 2
      - version 1 -> 조회 X -> 로직을 처음부터 다시 수행 -> 동시성 문제 해결 가능
    - 스프링에서 @Version 통해 손쉽게 Optimistic Lock을 추가 할 수 있도록 지원한다.
      - 도메인에 @Vesion private Long version; 추가
      - 실패시 재시도를 위해 퍼사드 클래스 하나 생성 필요 (ProductFacadeService)
        - 재시도 로직만 추가된 단순히 프록시 역할
    - 동시성 테스트
      - 소스 코드 디버깅 찍고, 수행(커밋) 전
      - mysql> update products set reserved_quantity = 1, version = 1 where id = 1 and version = 0;

# 18. TCC 구현하기(3) - Product Confirm API 구현하기
- controller -> facade > service -> repository
  - facade에서 재시도 로직 추가 (프록시 역할)
# 19. TCC 구현하기(4) - Product Cancel API 구현하기

# 20. TCC 구현하기(5) - Point Try API 구현하기

# 21. TCC 구현하기(6) - Point Confirm API 구현하기

# 22. TCC 구현하기(7) - Point Cancel API 구현하기

# 23. TCC 구현하기(8) - Order service 구현하기
- Order에서 트랜잭센 제어
- 재고 예약, 포인트 사용 예약
  - 성공 -> 실제 차감
  - 실패 -> 모두 취소
- order, product, point 트랜잭션을 제어할 order.OrderCoordinator
# 24. TCC 구현하기(9) - 주문하기 API 구현하기

# 25. TCC 구현하기(10) - Retry 를 활용하여 일시적인 오류에 대처하기
- msa 환경에서는 네트워크 오류, 일시적 장애 발생 가능 -> 대처 가능해야한다.
- 재고 예약 성공, 포인트 예약 실패 (커넥션 풀, 네트워크 단절) -> 연결 시도 자체 X
  - 일시적 실패 -> 재시도를 통해 극복하여 정상 처리 유도가 바람직할 수도 있다.
    - 안전하게 적용해야 한다 -> 시스템이 반드시 멱등성 보장하도록 설계해야 한다.
- 스프링 재시도 쉽게 하도록 기능 지원
  - 의존성 추가 필요
  - implementation("org.springframework.retry:spring-retry")
  - Application -> @EnableRetry
  - Logic -> @Retryable( retryFor = { Exception.class }, maxAttempts = 3, backoff = @Backoff(delay = 500) )
    - 무제한 재시도 경우 서비스 이용에 문제가 생길 수 있기 때문에, 보통 재시도 3번 정도 까지만 한다.
    - 오류 발생시 -> 바로 재시도 -> 또다시 오류 발생 가능성 -> 살짝 딜레이 준 후 재시도
- read timeout -> 외부 서비스 통신에 적절 리드 타임아웃 설정 -> 서비스 특정마다 다르지만, 2초로 설정
  - 의존성 추가
    - implementation("org.apache.httpcomponents.client5:httpclient5:5.4.4")
- 클라이언트가 잘못된 요청을 한 경우는 재시도 할 필요가 없다.
  - no retryFor -> httpstatus: 4xx -> 재시도 대상 제외 가능
# 26. TCC 구현하기(11) - Pending 상태인 주문 해소 전략
- 주문 도중 오류 발생 -> 상태가 비정상적으로 남아있는 경우 해소 방법 필요
  1. Confirm 단계 오류 -> 주문 상태 pending으로 남아있는 상태
     - Pending -> 일정 시간 지난 후 확정 처리 -> 항상 좋은 방식은 아니다.
       - 고객이 동일한 주문을 다시 한 경우, 팬딩 상태를 확정 처리하면, 두 번 주문하게 된다.
     - 수동 확정 처리 (관리자) 
  2. 예약 도중 실패 -> 주문 상태는 Cancelled, 실제로 일부 자원 취소되지 않은 상태
     - 예약 일정 시간 지난 후 상태를 주기적 탐색 -> 발견시 각 서비스는 현재 주문 상태 조회 -> Cancelled시 취소 처리
       - Scheduler
     