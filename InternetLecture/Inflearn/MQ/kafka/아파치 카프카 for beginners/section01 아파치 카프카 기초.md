# 1. 아파치 카프카 개요 및 설명

# 2. 토픽이란?
- 카프카는 다양한 데이터가 들어갈 수 있는데, 데이터가 들어가는 공간을 토픽이라 한다.
- 카프카 토픽은 AMQP와 다르게 동작한다.
- 카프카에서는 토픽을 여러 개 생성 가능하다.
- 토픽은 데이터베이스 테이블, 파일시스템의 폴더와 유사한 성질
  - 프로듀서(Source Application)가 토픽에 데이터를 넣는다.
  - 컨슈머(Target Application)는 데이터를 가져간다.
- 토픽은 이름을 가질 수 있다.
  - 목적에 따라 클릭로그, send sms, location log, ...
  - 명확한 이름으로 명시 -> 유지보수 편리
- 카프카 토픽 내부
  - 하나의 토픽은 여러 개의 파티션으로 구성된다.
  - 파티션은 0번부터 시작된다.
  - 파티션은 Queue처럼 내부에 데이터가 파티션 끝에서부터 차곡차곡 쌓인다. 2 1 0
  - 해당 토픽에 카프카 컨슈머가 붙어서 가장 오래된 데이터를 순타적으로 가져간다. (0, 1, 2)
    - 컨슈머가 토픽 내부 파티션을 가져갈 때, 파티션 데이터는 삭제되지 않는다. (그대로 남는다)
      - 즉 새로운 컨슈머가 붙었을 때 다시 0번부터 가져와 사용할 수 있다.
        - 다만 컨슈머 그룹이 달라야 하고, auto.offset.reset=earliest 여야 한다.
  - 더이상 데이터가 들어오지 않는 경우, 컨슈머는 데이터가 들어올 때 까지 기다린다.
  - 토픽 파티션 내부 데이터를 여러 컨슈머가 두 번 처리하게 할 수 있다.
    - 카프카를 사용하는 아주 중요한 이유다.
  - 토픽에 파티션이 두 개 이상인 경우
    - 프로듀서에 의해 데이터가 들어갈 때 어떤 파티션에 들어가야 할까?
      - 데이터 보낼 때 키 지정 가능
        - 키를 지정하지 않는다면 Round Robin으로 파티션 지정
    - 파티션을 늘리는 것은 아주 조심해야 한다. 늘릴 순 있지만, 다시 줄일 수가 없다!
      - 파티션을 늘리면 컨슈머의 개수를 늘려 데이터 분산 처리 가능!
  - 파티션 데이터 삭제는 옵션에 따라 다르다.
    - 최대 보존 시간, 최대 보존 크기 지정 가능

# 3. 브로커, 복제, ISR(In-Sync-Replication)
- 카프카 운영에 있어서 아주 중요한 역할을 한다.
- 복제
  - 카프카 아키텍쳐의 핵심
  - 서버 장애시 가용성 보장의 가장 좋은 방법이 복제다.
- 카프카 브로커
  - 카프카가 설치된 서버 단위
  - 보통 3개 이상의 브로커를 구성해 사용하는 것을 권장
  - 레플리케이션은 파티션의 복제를 뜻한다.
    - 레플리케이션 = 1, 파티션 1개만 존재
    - 레플리케이션 = 2, 원본 하나와 복제본 1개
  - 브로커 개수에 따라 레플리케이션 개수가 제한된다.
    - 브로커 개수가 3이면, 레플리케이션은 4가 될 수 없다.
  - 파티션
    - 원본 파티션 -> Leader Partition
    - 복제본 파티션 -> Follower Partition
    - 원본, 복제본 파티션을 합쳐 ISR(In Sync Replica)라고 볼 수 있다.
    - 브로커 3대중 한 대가 장애가 나도, 레플리카 개수가 2라면 Follower Partition 리더 역할로 승계한다.
- 리더 파티션과 팔로워 파티션의 역할은 ?
  - 프로듀서 -> 토픽의 파티션에 데이터 전달
    - 전달 받는 주체는 리더 파티션
    - 프로듀서 ack 옵션을 통해 고가용성 확보 가능
      - 파티션의 복제와 관련이 있다.
      - ack = 0
        - 속도는 빠르지만, 데이터 유실 가능성 존재
      - ack = 1
        - 데이터 전달이 잘 됐는지 체크 가능
        - 데이터를 전달받는 즉시 원본 브로커 장애 발생 -> 복제 됐는지 알 수 없다.
      - ack = all
        - 데이터 전달 및 follower partition 복제가 잘 됐는지까지 체크 가능
        - 데이터 유실은 없다고 할 수 있다. -> 다만 속도가 현저히 느리다는 단점이 있다.
- 레플리케이션이 많을수록 좋나?
  - 레플리케이션이 많아질수록 브로커 리소스 사용량이 늘어난다.
  - 저장 시간을 계산해 레플리케이션 개수를 정하는 것이 좋다.
  - 브로커 3대 이상 -> 레플리케이션 3 추천

# 4. 파티셔너(Partitioner)란?
- 프로듀서의 파티셔너
  - 카프카 프로듀서의 중요한 개념 중 하나
  - 이해하면 효과적으로 사용 가능!
  - 데이터를 토픽의 어떤 파티션에 넣을지 결정하는 역할
    - 레코드에 포함된 키 또는 값에 의해 파티션 위치 결정
- 프로듀서 -> 데이터 전달 (토픽)
  - 무조건 파티셔너를 통해 브로커로 데이터가 전송된다.
- 프로듀서 사용시 파티셔너 미설정
  - UniformStickyPartitioner로 설정이 된다.
    - 메시지 키가 존재 유무에 따라 동작이 다르다.
    - 메시지 키 존재
      - 메시지 키를 가진 레코드는 파티셔너에 의해 특정 해시값이 생성된다.
      - 해시 값을 기준으로 어느 파티션에 들어갈지 결정된다.
    - 메시지 키 미존재
      - 라운드 로빈으로 파티션에 들어간다.
        - 전통적인 라운드 로빈 방식과는 조금 다르게 동작 (UniformStickyPartitioner)
        - 프로듀서에서 배치로 모을 수 있는 최대한의 레코드를 모아 파티션으로 데이터를 보낸다. (빼치 단위)
        - 파티션에 적절히 배치된다 라고 이해해도 된다.
  - 커스텀 파티셔너도 프로듀서에 설정할 수 있다.
    - Partitioner 인터페이스 제공
    - 메시지 키, 메시지 값, 토픽 이름에 따라 어느 파티션에 데이터를 전달할지 결정 할 수 있다.
    - VIP, 일반 고객 파티셔너(8:2)를 나눌 수 있다
      - 데이터 처리량을 VIP 고객에 몰아주는 형태로 개발 가능
      - AMQP 기반 메시징 시스템에서 우선순위 큐를 만드는 것과 비슷하다.
  
# 5. 컨슈머 랙(Consumer Lag)이란?
- 카프카 운영에 있어서 아주 중요한 모니터링 지표 중 하나다.
- 카프카 Lag 이해 전 토픽, 파티션, 컨슈머 프로듀서, 오프셋 모두 이해하고 있어야 한다.
- 카프카 프로듀서
  - 카프카 토픽의 파티션에 데이터를 차곡차곡 넣는다.
  - 파티션 데이터는 오프셋이라는 숫자가 붙게된다.
    - 토픽의 파티션 1개라고 가정
      - 프로듀서가 데이터 삽입시 0부터 순차적으로 숫자가 매겨진다.
    - 컨슈머가 마지막으로 읽은 offset
    - 프로듀서가 마지막으로 넣은 offset
- 프로듀서가 데이터를 넣는 속도가 컨슈머가 가져가는 속도보다 빠르면 어떻게 될까?
  - 두 사이의 간격을 "컨슈머 랙"이라 한다.
    - 적을 수도 있고, 많을 수도 있다.
    - 컨슈머 랙 숫자를 통해 현재 해당 토픽에 대한 파이프라인으로 연계된 프로듀서와 컨슈머 상태에 대해 유추 가능하다.
      - 주로 컨슈머 상태를 볼 때 사용
- 컨슈머 랙은 각 파티션의 컨슈머, 프로듀서 두 오프셋의 차이를 기반으로 한다. 
  - 토픽의 파티션이 여러 개인 경우 컨슈머 랙은 여러 개 존재할 수 있다.
- 컨슈머 랙이 여러 개 존재할 때, 높은 숫자의 lag을 records-lag-max라고 부른다.
- 컨슈머 성능이 안 나오거나, 비정상 동작시 컨슈머 랙이 필연적으로 발생한다!
- Lag은 두 가지만 알면 된다.
  1. 프로듀서의 오프셋과 컨슈머의 오프셋 간의 차이
  2. Lag은 여러 개 존재할 수 있다.

# 6. 컨슈머 랙 모니터링 애플리케이션, 카프카 버로우(Burrow)
- 컨슈머 랙 모니터링 - 오픈소스 버로우 사용 이유!
- kafka-client 라이브러리 사용해 프로그래밍 언어를 통해 카프카 컨슈머 구현 가능!
  - KafkaConsumer 객체를 통해 현재 Lag 정보를 가져올 수 있다. 
- Consumer Lag 실시간 모니터링
  - 데이터를 Elasticsearch, InfluxDB 등의 저장소에 넣은 뒤 Grafana 대시보드를 통해 확인 가능
  - 컨슈머 단위에서 Lag 모니터링 -> 위험하고, 운영 요소가 많이 들어간다!
    - 컨슈머 로직으로 Lag 수집 -> 컨슈머 상태에 디펜던시에 걸리고, 더이상 컨슈머는 Lag 정보를 보낼 수 없다.
    - 그래서 컨슈머 랙을 효과적으로 모니터링 -> 오픈소스 버로우! 
- 카프카 버로우(Burrow)
  - Golang으로 개발
  - 오픈소스
  - Consumer Lag 모니터링을 돕는 독립적인 앱!
  - 버로우 3가지 특징
    1. 멀티 카프카 클러스터 지원
       - 카프카 클러스터가 여러 개 더라도, 버로우 1대만 연동해도 모두 모니터링 가능
    2. Sliding Window를 통핸 Consumer status 확인
       - ERROR, WARNING, OK 표시

# 7. 카프카, 레빗엠큐, 레디스 큐의 차이점
- 메시징 플랫폼은 두 가지 정도로 나뉜다.
  1. 메시지 브로커
     - 이벤트 브로커 역할 수행 불가
  2. 이벤트 브로커
     - 메시지 브로커 역할 수행 가능
- 메시지 브로커
  - 대규모 메시지 기반 미들웨어 아키텍처에서 사용
    - 미들웨어 
      - 서비스 앱들을 효율적으로 연결하는 요소로 작동하는 SW
      - 메시징 플랫폼, 인증 플랫폼, 데이터베이스, ...
  - 특징
    - 메시지 받고, 처리 후 즉시 또는 짧은 시간 내 삭제되는 구조
- 이벤트 브로커
  - 두 가지 특징
    1. 레코드(이벤트 혹은 메시지라 불린다.)를 딱 하나만 보관하고, 인덱스를 통해 개별 액세스를 관리한다.
    2. 업무상 필요한 기간동안 이벤트를 보존할 수 있다.
  - 데이터를 받고, 처리한 후 삭제하지 않는다.
    - 서비스에서 나오는 이벤트를 DB에 저장하듯, 이벤트 브로커의 Queue에 저장한다.
    - 저장함으로써 얻는 이점
      - 한 번 일어난 이벤트 데이터를 브로커에 저장함으로써 "단일 진실 공급원"으로 사용 가능
      - 장애가 일어난 지점부터 재처리 가능!
      - 많은 양의 실시간 스트림 데이터를 효과적으로 처리 가능
      - 이벤트 기반 MSA의 중요한 역할 수행 가능
        - 이벤트 브로커 클러스터 구축시 이벤트 기반 MSA로 발전한다.
        - 메시지 브로커로써도 사용 가능
- 메시지 브로커 예시
  - 레디스 큐, 레빗엠큐, ...
- 이벤트 브로커
  - 카프카, AWS 키네시스, ...
