# 가상화 기술

## 파트 소개
- 하이퍼바이저, 컨테이너 가상화 비교
- 컨테이너 가상화 도구 - 도커 학습

## 애플리케이션 서버
- 서버
  - 소프트웨어
  - 하드웨어
- 서버 역할
  - 파일 서버
  - DB 서버
  - 웹 서버 (www - html, css, js) 
  - 웹 앱 서버 (API)
- 강의는 주로 postgresql 사용
- 서버 운영 방식
  1. 베어메탈(Baremetal)
    - 서버 구입 -> OS 설치 -> 여러 개 SW 설치
      - 기업 운영에 비효율
  2. 하이퍼바이저
  3. 컨테이너

## 가상화기술과 하이퍼바이저 가상화
- 한 대의 컴퓨터로 여러 대 컴퓨터를 사용할 수 있다. -> 물리적 컴퓨팅 환경에서 논리적 컴퓨팅 환경을 구성한 것
  - 논리적 컴퓨팅의 리소스 제어 가능
  - 논리적 구분을 통해 한 논리적 단위가 에러가 발생하거나 리소스 초과가 되더라도 다른 논리적 컴퓨팅에 영향을 주지 않는다.
- 낮은 성능 여러대 컴퓨터 < 높은 성능 한 대 컴퓨터
  - 전기 사용량
  - 하나의 컴퓨팅을 효율적으로 사용! 
- 가상화 방식
  - 하이퍼바이저
    - 컴퓨터에 설치되는 프로그램
    - OS 프로그램 -> 가상 OS 생성 및 실행, 종료
    - cpu, 메모리 등을 격리된 공간에 할당 가능
    - 가상환경 각각 OS 설치 필요
    - 물리 서버 OS -> HOST OS -> 하이퍼바이저 설치하여 가상환경 생성
      - 호스트 OS 자원을 격리해 새로운 OS 실행 -> Guest OS (가상 머신 - 서버 프로그램 설치후 사용)
    - 기술의 종류로서 역할 수행 SW가 존재 (virtualBox, Red Hat, vmware)
  - 컨테이너

## 컨테이너 가상화
- 하이퍼바이저 < 컨테이너
  - 가볍다.
  - 빠르다.
- 컨테이너 가상화
  - 리눅스 커널이 제공하는 LXC(Linux Containers) 자체 격리 기술에서 출발
    - 커널 자체 기능 활용! -> 모든 컨테이너가 Host OS의 커널을 공유해서 사용!
      - 가장 핵심중 하나!
      - 하이퍼바이저보다 상대적으로 오버헤드가 적다 (하이퍼바이저 단계가 X)
        - HW 사용 요청이 효율적 사용 가능
        - 커널 실행 시간 단축 - Host OS 커널 공유 
      - Host OS와 다른 OS는 실행할 수 없다.
    - LXC를 통한 논리적 격리 단위 -> 컨테이너
    - 하이퍼바이저 사용하지 않고 커널 자체 기능을 사용해 격리 공간 생성 가능
    - namespace, Cgroups 활용!
      - namespace: 
        - 나눌 수 있는 단위 정의 (UTS, IPC, PID, NS, NET, USER)
        - 리소스 분리 기준
      - Cgroups: 
        - 사용량 배분 지정 (Memory, CPU, Disk, Network)
        - 프로세스가 사용하는 사용량 배분 기술
- 하이퍼바이저 가상화
  - 시스템콜이 Host OS와 Guest OS 사이에 하이퍼바이저를 통해 중간에서 커널 통신을 지원(통역을 거쳐야 해서 요청 단계가 늘어난다 - 오버헤드가 크다.)
  - Host OS와 Guest OS 커널이 각각 독립적으로 존재
  - 보안 면에서는 컨테이너보다 뛰어나다.
- 도커
  - 커널이 자체 제공하는 가상화 기술은 사용자가 직접 컨트롤하기 어렵다.
  - 커널의 컨테이너 가상화 기술을 편리하게 사용 -> 도커를 통해 컨테이너를 만들어 편리하게 사용!
  - 도커는 커널 가상화 기술을 보조해주는 역할일뿐

## 도커(Docker)
- 2013년!
- 커널의 컨테이너 가상화 기술을 사용자가 편리하게 사용
- 컨테이너 플랫폼 (도커와 같은 컨테이너 가상화 기술을 컨테이너 플랫폼)
  - 자체적으로 갖고 있는 컨테이너 엔진
    - 사용자 요청을 받아 컨테이너 관리
  - 컨테이너 런타임
    - 직접 커널과 통신, 격리된 공간 생성 수행
    - 도커는 RUNC 라는 컨테이너 런타임 사용!
- 도커 아키텍처
  - 클라이언트-서버 모델
  - 사용자 명령 전달 - 클라이언트
  - 실제 컨테이너 관리 - 도커 데몬이라는 서버
  - 클라이언트는 사용자 명령을 도커 데몬에 전달 -> 컨테이너 관리 기능 제공!(DockerD) -> Host OS 커널 기능을 통해 컨테이너 관리!
    - 도커 데몬은 API 제공 -> 클라이언트가 사용 할 수 있는 API! -> 사용자가 직접 사용하기 복잡
    - 도커 CLI를 통해 클라이언트는 명령어를 입력해 API 양식에 맞춰 만들어 데몬에 요청한다.

## 컨테이너 실행
- nginx 웹서버 실행, 웹 페이지 접속
- 명령어
  - docker version
    - 클라이언트, 서버의 버전 확인 가능
  - docker info
    - 더 상세한 내용, 버전 및 설치된 플러그인, 실행 컨테이너, 이미지 개수, OS type, CPU 등 상세 내용
  - docker --help
    - 아주 많이 사용!
    - 메뉴얼 확인 가능
    - docker 대분류(management command) 소분류(command) -> docker container run ..
      - 대분류는 일반적으로 생략 가능 docker run ..
    - docker container --help
    - docker container run --help 
  - docker run (실행옵션) 이미지명
    - 컨테이너 실행
    - docker run -p 80:80 --name hellonginx nginx
  - docker rm 컨테이너명/id
    - 컨테이너 삭제