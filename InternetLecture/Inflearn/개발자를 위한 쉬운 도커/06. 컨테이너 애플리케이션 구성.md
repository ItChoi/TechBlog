# 컨테이너 애플리케이션 구성

## 파트 소개

## 클라우드 네이티브(Cloud Native) 애플리케이션
- 클라우드
  - 사용 요청 즉시 서버 생성 -> Provisioning(프로비저닝)
  - 사용한 만큼 지불
    - 트래픽 증가 -> 빠르게 대처 (확장성, Scalability)
    - 장애 발생시 빠르게 복구 가능 (복원력, Resilience)
  - 운영 비용 효율적 운영 가능한가?
    - 전문가 적절하게 개선 및 비용 최적화 필요
- 클라우드와 클라우드 네이티브 애플리케이션
  - 클라우드: 복잡하고 현대 앱이 겪는 다양한 문제를 클라우드 환경 구성을 통해 해결 가능
  - 클라우드 네이티브 애플리케이션: 클라우드 환경을 잘 활용할 수 있는 애플리케이션 구조
    - MSA
    - 컨테이너 
    - 상태비저장 (Stateless)
    - DevOps, CI/CD
- MSA
  - 전통적인 모놀리식 방식 
    - 하나의 앱이 켜지고, 실행에 오래 걸리고, 트래픽 서버 증가시 실행 시간이 오래 걸려 오버헤드 발생
    - 배포 시간도 당연히 오래 걸리게 된다.
    - 오류 발생시 -> 전체 오류로 번지 수 있다.
    - 스케일 업을 주로 사용
  - MSA
    - 모듈별로 분리해, 서버별로 트래픽을 수용, 특정 모듈 트래픽 증가시 해당 모듈만 제어 가능하다.
      - 스케일 아웃 -> 서버 수를 증가시켜 트래픽 대처
      - 스케일 인 -> 서버 개수를 줄이는 것
    - 모듈 별로 서로 다른 언어로 구성 가능
    - 스케일 아웃을 주로 사용

## Leafy 애플리케이션 구성
- 식물 관리 웹 앱
  - 식물 정보 제공
  - 나의 식물 리스트
  - 식물 다이어리
  - 물 주기 계산
- 세 개 서버로 구성 -> 컨테이너로 구성
  - front
    - vue.js 3, nginx 웹 서버 배포
  - backend
    - spring boot, 내장 톰캣
  - sql
    - postgresql
- 명령어
  - docker network create leafy-network
    - 앱이 사용할 네트워크 생성
  - docker run -d --name leafy-postgres --network leafy-network devwikirepo/leafy-postgres:1.0.0
    - db 컨테이너 생성 및 실행
  - docker logs -f leafy-postgres
    - 컨테이너 로그 조회 + 실시간 조회
  - docker run -d -p 8080:8080 -e DB_URL=leafy-postgres --network leafy-network --name leafy devwikirepo/leafy-backend:1.0.0
    - 백엔드 컨테이너 생성 및 실행
  - docker logs -f leafy
  - docker run -d -p 80:80 --network leafy-network --name leafy-front devwikirepo/leafy-frontend:1.0.0
    - 프론트엔드 컨테이너 생성 및 실행

## PostgreSQL 컨테이너 구성
- 레이어 구성
  - OS
  - PostgreSQL
    - OS 구성 및 PostgreSQL:13 설치
  - 서버 설정 파일 변경
    - COPY ./config/postgresql.conf /etc/postgresql/custom.conf
  - SQL문 작성 
    - build context에 작성 -> 이미지 안에 넣어두고 컨테이너 실행시 자동 실행 하도록 구성
    - COPY ./init/init.sql /docker-entrypoint-initdb.d/
  - 데이터베이스 실행
    - CMD ["postgres", "-c", "config_file=/etc/postgresql/custom.conf"]
- 명령어
  - git clone https://github.com/daintree-henry/leafy.git
  - docker cp 원본위치 복사위치
    - 컨테이너와 호스트 머신 간 파일 복사
  - docker cp 컨테이너명:원본위치 복사위치
    - 컨테이너 -> 호스트 머신으로 파일 복사
  - docker cp 원본위치 컨테이너명:복사위치
    - 호스트 머신 -> 컨테이너로 파일 복사
  - docker run -d --name postgres -e POSTGRES_PASSWORD=password postgres:13
  - docker exec -it postgres bin/bash
    - 아래 명령들은 직접 명령어 작성을 해도 되고, Dockerfile을 통해 지시어로 입력하면 자동으로 다 된다.
    - cat /var/lib/postgresql/data/postgresql.conf
      - 기본 설정 파일 확인
      - 덮어쓸 파일을 만들더라도, 이 파일을 복사해서 커스텀하는 것도 좋은 방법이다.
    - ls -al /docker-entrypoint-initdb.d/
    - docker cp ./config/postgresql.conf postgres:etc/postgresql/custom.conf
      - 호스트 머신의 파일 -> postgres 컨테이너 파일로 복사
    - cat /etc/postgresql/custom.conf
    - docker cp ./init/init.sql postgres:docker-entrypoint-initdb.d
    - psql -U postgres -c "\d"
      - 아무 것도 없다.
    - psql -U postgres -f /docker-entrypoint-initdb.d/init.sql
      - sql 파일을 통해 sql 실행
  - docker rm -f postgres
  - docker network ls
  - docker build -t 레지스트리계정명/leafy-postgres:1.0.0 .
    - 도커 파일 빌드
  - docker push 레지스트리계정명/leafy-postgres:1.0.0
  - docker run -d --name leafy-postgres --network leafy-network 레지스트리명/leafy-postgres:1.0.0
    - 빌드된 이미지로 컨테이너 실행
  - docker logs leafy-postgres
    - init.sql 실행 및 서버 실행 정상 확인
  - docker exec -it leafy-postgres su postgres bash -c "psql --username=myuser --dbname=mydb"
    - leafy-postgres 컨테이너 내에서 명령어 실행 후 결과 출력
    - postgresql 바로 접근
  - docker image history 레지스트리계정명/leafy-postgres:1.0.0

## SpringBoot 백엔드 컨테이너 구성
- java -> jar, war로 프로그램 빌드 가능 -> OS에 java runtime 설치 필요 -> 빌드시 빌드 툴 필요 (gradle)
- 레이어
  - OS
  - Java Runtime
  - gradle
  - git clone
  - gradle clean build
  - java -jar leafy.jar
- 멀티 스테이지 빌드 활용 -> 빌드 및 실행 이미지 분리
- 명령어
  - docker run -it --name gradle gradle:7.6.1-jdk17 bash
    - gradle 컨테이너 실행 및 shell 접속
    - mkdir /app && cd /app
      - app 폴더 생숭 후 이동 -> "WORKDIR /app"과 같은 효과
    - gradle clean build --no-daemon
      - gradle build 실행
      - build 디렉터리가 생성된다.
        - build/libs 폴더 안에 jar 파일 생성
    - java -jar /app/build/libs/Leafy-0.0.1-SNAPSHOT.jar
      - gradle 컨테이너 내부에서 빌드로 만들어진 jar 실행
  - docker cp . gradle:app
    - 현재 경로 모든 디렉토리 파일을 gradle 컨테이너 app 경로에 복사
  - Dockerfile 멀티 스테이지 작성 -> gradle, jdk
    - docker build -t 레지스트리계정명/leafy-backend:1.0.0 .
    - docker push 레지스트리계정명/leafy-backend:1.0.0
    - docker run -d -p 8080:8080 -e DB_URL=leafy-postgres --name leafy --network leafy-network 레지스트리계정명/leafy-backend:1.0.0
    - docker logs leafy
    - curl http://localhost:8080/api/v1/users
      - leafy 컨테이너 로그 확인

## Vue.js 프론트엔드 컨테이너 구성
- 프론트엔드 소스 코드 빌드 과정
  - 소스 코드 개발
  - 빌드 -> html, js, css 파일을 dist 경로에 생성
  - 웹 서버 업로드 -> dist 경로를 nginx 웹 서버의 /usr/share/nginx/html 경로로 복사
  - 브라우저 통해 접속
- 레이어
  - OS
  - Nginx
  - node.js, npm
  - git clone
  - npm ci & npm run build - ./dist 폴더에 결과 파일이 만들어진다.
  - cp ./dist /usr/share/nginx/html
  - 웹 서버 실행 - nginx -g daemon off;
- 멀티 스테이지 빌드 - 빌드, 실행 이미지 분리
- 빌드 과정 관찰
  - docker run -it --name node node:14 bin/bash
  - mkdir /app && cd /app 
    - WORKDIR app 같은 효과
  - docker cp . node:app
    - 호스트 머신에서 실행
  - npm ci
  - npm run build
    - dist 폴더가 만들어지고, 결과 파일을 dist 폴더에서 체크 가능
    - nginx로 옮겨야 한다.
  - docker cp node:app/dist .
    - 호스트 머신에서 실행
  - docker rm -f node
  - docker run -d -p 80:80 --name nginx nginx
  - docker cp ./dist/. nginx:usr/share/nginx/html
    - 호스트 머신에서 실행
    - dist 결과물을 nginx 컨테이너로 복사
  - docker logs -f nginx
  - docker rm -f nginx
- 명령어 빌드 -> Dockerfile 빌드
  - Dockerfile 작성
  - docker build -t 레지스트리계정명/leafy-frontend:1.0.0 .
  - docker push 레지스트리계정명/leafy-frontend:1.0.0
  - docker run -d -p 80:80 --name leafy-frontend --network leafy-network 레지스트리계정명/leafy-frontend:1.0.0
  - docker rm -f leafy-frontend leafy leafy-postgres
- 식물 앱 아키텍처
  - 유저 요청 -> router.js 파일 내용에 따라 페이지 응답 -> 백엔드 API -> DB 수행 -> 화면 표시