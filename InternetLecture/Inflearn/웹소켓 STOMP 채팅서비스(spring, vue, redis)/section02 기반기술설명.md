# 3. http,websocket 비교

## 기반 기술
- websocket
- stomp
- redis pub/sub을 통해 멀티 서버 환경 고려


## websocket
- 채팅 서비스 근간이 되는 기술이자 프로토콜
- 웹 소켓과 http 비교
    - 프로토콜
        - 통신 규약 -> 메시지를 주고받는 약속이자 형식!
            - http: 헤더와 바디로 이루어짐
            - 웹소켓: 고유한 문서 양식을 갖고 있다.
    - http
        - 반드시 request를 보내고, response를 받는다.
        - 메시지가 들어올 때, 실시간으로 볼 수 없고, -> DB에 요청과 응답을 보내고 새로고침을 해야 한다.
        - http 프로토콜 구조
            - 클라이언트 요청, 서버는 응답 (단방향 구조)
    - 웹 소켓
        - 클라이언트(웹 브라우저) <-> 서버
            - 실시간으로 통신이 맺어진다.
            - 실시간 양방향 통신 가능하게 하는 통신 프로토콜
        - 서드파티 -> 서버 -> 클라이언트(웹 브라우저)
        - 웹 소켓 프로토콜 구조
            - 클라이언트 서버 서로 요청과 응답 가능 (양방향 구조)
            - 클라이언트 & 서버 최초 연결시 서버 메모리에 클라이언트에 대한 위치 정보를 갖고 있다.
                - 서버 -> 클라이언트A 메시지 발송 가능 (요청이 없어도 연결을 맺은 각 클라이언트에게 메시지 발송 가능)
        - ws://의 url을 가진 웹 소켓 프로토콜 사용
            - STOMP -> 명시적으로 ws를 사용하지 않고 http를 사용한다 (내부적으로 ws:// 사용)
    - HTTP 요청, 웹소켓 서버 연결 방식 비교
        - 두 기술 공통 근간 프로토콜 -> TCP 프로토콜 (양방향 프로토콜)
            - HTTP
                - 연결 방식 -> 양방향이긴 하지만, 빠르게 끊어버린다.
                    - 클라이언트 요청과 서버 응답을 할 때 순간적으로 양방향 연결
                    - 메시지를 주고 받은 다음 연결을 빠르게 끊는다 -> 비연결성
                - 요청마다 연결을 맺고 끊음을 반복 -> 기본적으로 서버에 부하가 있을 수 밖에 없는 아키텍처
                    - 요청마다 http 통신 규약에 맞게 메시지를 보낸다.
            - 웹 소켓
                - 연결 방식 -> 양방향 -> 쭉 유지
                - 연결 맺자 요청 (핸드쉐이크), 서버 연결 -> 연결 유지 -> 파이프라인을 통해 메시지를 주고 받는다
                - 최초 한 번 연결 -> 별도 http 형식의 메시지 없이 통신 가능 -> 빠른 성능 보장 -> 파이프라인을 통해 메시지를 주고 받는다.
                    - 별도 통신 규약을 지키며 메시지를 보낼 필요 없이 간결하게 보내기 가능! (중요)
                - 최초 연결시 -> http 헤더를 통해 http 메시지를 보낸다.
                    - 토큰같은 인증 정보를 보내 인증 처리 가능! (최초 연결시에만 가능)
                        - 우리 사용자인지 아닌지, 로그인 여부 등 토큰을 보내 검증!

## stomp
- websocket이 발전된 형태


## redis pub/sub을 통해 멀티 서버 환경 고려
- 채팅 서버가 원활하게 동작할 수 있는 아키텍처 설계

---

# 4. polling, sse와의 비교
- polling
  - 통신 방식이라기보단, 코딩 기법
  - 새로고침 없이 http통신 만으로 채팅 구현 가능 
  - 주기적인 시간을 정하고 서버에 request 요청!
    - JS에서 폴링 코드 추가
  - 서버 부담이 많이 간다. -> 빈번한 http 요청
  - 완전한 실시간을 할 순 없다.
  - 채팅에서 폴링 방식은 부적절하다.
- sse (Server-Sent Events)
  - 실시간 통신
  - 단순 구현 가능, http 기반의 실시간 프로토콜
    - server -> 클라이언트에 메시지를 쏴줄 때 http 형식(헤더, 바디)에 맞는 메시지! -> 다소 부하 및 성능 저하
  - 서버에서 클라이언트 관련 정보, ip, mac addr, 브라우저 정보들을 서버 메모리에 가지고 있어야 한다.
  - 웹 소켓은 최초 연결 후 클라이언트 <-> 서버 간 간결한 메시지! 
    - SSE는 클라이언트 -> 서버는 일반적은 http 요청
      - 즉 SSE는 단방향 통신 기술
  - 유저에게 알림 목적으로 많이 활용
    - 빈번함의 정도로, 적다면 SSE를 활용도 좋다.
  - 웹 소켓보다 훨씬 더 간결하게 SSE 구현 가능 
  - 일반적인 HTTP 통신이기에 고려 사항이 더 적다.

---

# 5. websocket, stomp 비교
- stomp를 이해 하지 못하고 채팅 서비스 개발하는 사람이 많다.
  - 어렵진 않다!
- websocket, stomp 차이
- stomp (Simple Text Oriented Messaging Protocal)
  - websocket에서 더 발전된 형태
  - 웹 소켓 위에서 동작하는 메시징 프로토콜
- 일반적인 웹 소켓
  - 클라이언트 <-> 서버
    - 구성
      - A client <-> Server
      - B client <-> Server
    - A client -> Server 메시지 요청
    - 서버는 통신이 맺어져있는 A, B 클라이언트 모두에게 메시지 응답!
      - A가 요청을 했지만, 서버는 모든 클라이언트(A, B)에게 전파
      - 커넥트된 대상에게 모두에게 전파 (대상은 서버 메모리 정보에 저장 돼 있다.)
  - 채팅이 그룹핑 돼 있는 경우 -> 순수 웹 소켓을 통해 직접 코드 구현 -> 상당히 복잡
    - STOMP 기술이 나오게 됐다!
- stomp
  - 웹 소켓 기반 동작
  - 중간에 브로커를 둔다. (일반적인 웹 소켓과 다르다.)
    - 클라이언트 그루핑을 브로커가 대신 해준다.
    - 활용도가 상당히 높다. -> 참여한 클라이언트만 전파! 
  - 클라이언트 <-> 서버
    - 구성
      - A client <-> Server
      - B client <-> Server
    - 채팅방
      - room1
      - room2
    - A client -> room1 입장
      - 1번방 구독을 서버에게 알린다.
      - room1에 들어오는 메시지 -> room1에 입장한 클라이언트에게 전파 (A)
  - 목적지 기반 메시지 라우팅 지원 (웹 소켓과 다르다)
    - client/server -> 특정 topic 기준으로 메시지 통신
      - topic -> 특정 room 지칭(stopm에서 일반적으로 하는 지칭)

## redis pub/sub을 통해 멀티서버 환경 고려
- Client A -> LB -> (WebSocket Server1, WebSocket Server2, WebSocket Server3) -> Redis Pub/Sub
- Client B -> LB -> (WebSocket Server1, WebSocket Server2, WebSocket Server3) -> Redis Pub/Sub
- 별개
  - LB -> 여러 알고리즘이 있는데, 일반적으로 Round Robin 사용 (무작위 매칭)
- 클라이언트는 어떤 WebSocket Server에 매칭될 지 알 수 없다.
  - 레디스 Pub/Sub 미사용
    - Client A -> WebSocket Server2 -> 클라이언트 정보 저장
    - Client B -> WebSocket Server3 -> 클라이언트 정보 저장
    - WebSocket Server2 -> A만 있고, B가 없다.
      - A -> B 채팅 전송을 할 수가 없다. -> 레디스 Pub/Sub 활용해 전파
  - 레디스 Pub/Sub 사용
    - 카프카를 쓰기도 한다.
    - 레디스 구독 서버를 대상으로 모두 퍼블리싱
    - WebSocket Server(1, 2, 3) -> 레디스 구독 (subscribe)
      - 레디스 메시지 발행시 -> A, B, C 모두 메시지를 받는다.
      - WebSocket Server에 클라이언트 정보가 있으면 바로 메시니 전파, 없다면 레디스에게 publish -> 구독한 웹소켓 서버(A,B,C)에게 모두 메시지 전달! -> 전달 받은 웹 소켓 서버들은 메시지 전달받아 클라이언트에게 전달! 
    한 대 서버로 구성된 경우는 없다 -> 중간에서 메시지 전파하는 카프나나 redis를 두는 아키텍처로 구성!