# 파일과 디렉터리의 구조
- 파일 속성
  - 이름: 경로와 파일 명이 같이 있다고 보면 된다.
    - C:/workspace/abc.md (동일 디렉토리 내에 동일 파일명이 있을 수 없다.)
    - path + name을 통해 위치를 구분한다.

하나의 파일에는 데이터를 담고 있다.
파일은 데이터를 담는 그릇이다.

변수도 마찬가지로 데이터를 담는 그릇이지만, 메모리에 잠시 저장되어 사용되고,
파일은 기본적으로 디스크에 저장되어 사용된다. (HDD, SDD, USB 등 여러 형태의 디스크 (블록 스토리지))

메모리보다 디스크 용량이 훨씬 크다.
대용량 데이터를 변수에 담진 않는다.
변수는 당연히 디스크에 있는 파일보다 클 수 없다.

프로그래밍용 데이터는 변수에 담아서 사용하고,
영구적 저장은 디스크에 파일이라는 형태로 저장한다.
(여기서 영구는 전원이 없어도 지워지지 않는다.)

하나의 시스템에는 엄청나게 많은 파일이 있다.
파일이 많으면 디스크 용량이 파일 공간보다 커야 한다.
운영체제 관점에서 HW 위에 OS를 두는데, 운영체제는 하드웨어 자원 관리, 감독한다.
당연히 디스크도 포함되는데, 수 많은 파일들에 대해 OS가 작업을 해줘야 애플리케이션이 OS를 통해 파일들에 접근, 쓰기, 삭제 등의 동작을 할 수 있다.
시스템 상에 디스크가 여러 개인 경우도 있다.
HDD를 논리적 단위로 공간을 나누어 사용하기도 한다.

이를 다 OS에서 관리 해줘야 하는데, 파일을 관리, 감독 해주는 OS 상에 하나의 계층이 있다.
이를 바로 "파일 시스템"이라고 한다. 운영체제의 일부이면서, 디스크 상에 특정 파일 시스템을 위해 디스크 어떤 영역에 데이터를 저장하기도 한다.
OS와 디스크 사이에 있다고 인식하면 된다.

파일 시스템도 하나의 시스템이다.
실제 디렉토리, 파일들을 하나의 파일 시스템이 다 관리를 해주고 있다.

리눅스는 트리 형태의 계층 구조를 갖는다.
운영체제가 설치되면 수 만개의 파일이 설치 된다.
이런 파일들은 트리 구조로 되어 찾기 쉽고, 네이밍 관리가 되게 해준다.
의미있는 계층 구조를 트리 형태가 됐다.

계층 구조 구성 방법은 윈도우, 리눅스가 다르다.
리눅스 시스템은 root 최상위 디렉토리가 있다.
윈도우는 C: 또는 D: 드라이브가 존재한다.

리눅스에선 여러 개 디스크가 존재하더라도, root 밑에 존재한다.

윈도우는 운영체제는 C드라이브에 들어간다.
D 드라이브 부터는 HDD, CD, DVD, USB 드라이버 등등
하드 디스크 하나당 하나의 드라이버가 존재하게 된다.

리눅스는 모든 디스크들이 root 밑에 디렉토리에 mount 되어 있다.
리눅스 OS 설치후 디스크 추가시 자동으로 마운트 되지 않는다.
root 디렉토리 밑에 마운트 할 디렉토리를 만들고, 추가된 디스크와 마운트 해줘야 한다.

파일 시스템은 운영체제 내에서도 동작을 해야 한다. 
운영체제와 같이 동작되는 파일 시스템도 분명히 있을 것이다.
OS -> 파일 시스템을 통해 유저에게 파일을 보여준다던가..

# 파일의 종류
- 일반 파일 (regular file)
  - 일반 파일 (텍스트, 동영상 등)
- 디렉터리 (directory)
  - 파일의 한 종류 (윈도우 폴더와 동일)
- 심볼릭 링크 파일 (symbolic link file)
  - 다른 파일을 가리키는 파일 (윈도우 바로가기 같은 개념)
    - 실제 파일을 가리키는 바로가기 같은 ..
  - 뒷 부분에서 배우게 됌.
- 블록 디바이스 파일 (block device file)
  - 블록 디바이스 제어하기 위한 파일
- 문자 디바이스 파일 (character device file)
  - 문자 디바이스 제어하기 위한 파일
- 파이프 파일 (pipe file)
  - 파이프를 나타내는 파일
  - 프로세스간 통신에 사용
  - ifconfig | grep inet 할 때 '|'와는 비슷하지만 다른 파이프를 말한다.
    - 프로세스와 다른 프로세스간 통신하는 방식을 파이프를 이용한다. (IPC)
- 소켓 (socket)
  - 소켓을 나타내는 파일
  - 프로세스간 통신에 사용
  - 소켓도 여러 종류가 있다.
    - 유닉스 도메인 소켓 -> 파일 형태로 존재한다.

디바이스 파일의 동작 원리
- 운영체제나 운영체제가 하드웨어를 관리하는 방법을 조금 더 깊이 알아야 한다.
- App
  - OS (하드웨어를 관리하기 위한 소프트웨어 존재 -> 디바이스 드라이버)
    - HW

운영체제가 하드웨어 자원을 관리하고 사용한다.
하드웨어도 리눅스 시스템의 일부로 동작하기 위해서 운영체제와 연결이 되어 있다.
OS에 HW 드라이버가 실제 드라이버를 구동시켜준다.

디바이스 드라이버는 운영체제와 상호작용 뿐만 아니라 실제 애플리케이션과도 상호작용 가능하다.
앱과 상호작용을 위해 필요한게 디바이스 파일이다.

디바이스 파일은 디바이스 드라이버가 동작할 때, 디바이스 드라이버에 연결된 디바이스를 제어해야 하는데, 
디바이스 드라이버 뿐만 아니라, 애플리케이션이 디바이스에게 명령을 내릴 수도 있다.
애플리케이션이 디바이스 파일을 통해 디바이스 드라이버를 통해서 디바이스 까지 명령을 전달할 수 있는 하나의 채널을 구성 가능하다.
그러기 위해서 통로 역할을 해주는 OS 안에 있는 디바이스 드라이버와 앱을 연결해주는 채널을 만들어주는 것이 디바이스 파일이다.

# 대표적인 디렉터리
루트 디렉터리 바로 하위 디렉터리들은 각각의 이름에 걸맞는 역할이 있다.
필수 조건은 아니지만, 오랜 시간 대부분 지켜오는 것들이다.

- /
  - 루트 디렉터리, 모든 티렉터리의 최상위 부모
- /bin (binary) -> 운영체제로서 기본적으로 설치되는 것들 포함
  - 모든 사용자가 사용 할 수 있는 여러 가지 실행 파일 위치
- /sbin
  - 시스템 관리자 권한으로 실행해야 하는 실행 파일 위치
- /etc
  - 여러 가지 설정 파일 (주의!!!)
    - 시스템 설정
  - 잘못 건드리면 시스템 오동작 가능성이 있다. 
- /lib
  - 공유 라이브러리 디렉터리
- /home
  - 사용자들의 홈 디렉터리
- /mnt
  - 일시적으로 파일 시스템에 마운트하는 경우 사용하는 디렉터리
- /proc, /sys
  - 시스템 정보를 설정, 조회 할 수 있는 디렉터리
  - 특수한 디렉터리
    - OS가 OS 정보를 보여줄 수 있는 통로 디렉터리로 보면 된다.
      - OS가 만들어낸 가상의 파일 -> 애플리케이션이 읽을 수 있다. 
- /tmp
  - 임시 디렉터리
- /usr
  - 사용자가 추가한 실행 파일, 라이브러리 등의 소프트웨어 저장
  - /usr/bin, /usr/sbin -> 유저가 설치한 것들의 실행 파일 (사용자, 관리자)
- /dev
  - 디바이스 드라이버가 사용하는 디바이스 파일 디렉터리

# 디렉터리 개념
- 현재 작업 디렉터리 (CWD: Current Working Directory)
- 홈 디렉터리 (home directory)
  - 홈 안에 사용자 계정 폴더명이 있다. 
  - 리눅스는 멀티 유저 시스템 지원, 사용자가 여럿이다를 가정 
- 상대 경로 (relative path) vs 절대 경로 (absolute path)

# 아이노드 그리고 하드링크와 소프트링크
하드링크, 소프트링크를 알기 위해 아이노드가 무엇인지 알아야 한다.
아이노드는 어렵다. 리눅스 커널과 파일시스템의 깊숙한 내용에 속한다.

여러가지 정보를 포함하고 있는 덩어리라 보면 된다.
하나의 파일을 구성하는 구성 요소이다.

파일 하나가 파일시스템 상에서는 데이터, 아이노드, 디렉터리 엔트리 등등의 구조체들이 복잡하게 얽혀 하나의 파일 시스템을 이루고 각각의 파일을 구성한다.
파일마다 유일한 데이터가 여러 곳에 분산 돼 있는데, 그 중 하나가 아이노드 이다.
파일의 실제 데이터 (메타 데이터) 들이 저장 돼 있는 공간이라 생각하면 된다.

파일 이름, 아이 노드, 데이터를 가지면 하나의 파일을 구성한다. (기본적인 파일 구조)
파일 이름은 아이노드에 포함되지 않는다.
파일 이름은 디렉터리 엔트리에 포함된다.
디렉터리 엔트리에 아이노드에 대한 포인터를 갖고 있다. (연결 고리)


하드링크(hard-link)와 소프트링크(soft-link == symbolic linck == symlink)
- 링크라 함은 연결돼 있다는 것을 뜻한다. (linking)
- 하드링크
  - 파일 이름은 공유하지 않고, 아이노드와 파일 데이터를 공유한다.
- 소프트링크
  - 원본 파일이 있고, 소프트 링크 파일을 만들고 대상을 지정(원본 파일)한다. 
    - 윈도우의 바로가기 방식이랑 거의 유사하다.
  - 원본 파일의 아이노드와 소프트 링크 파일의 아이노드는 별개다.
  - 소프트링크 파일 이름, 아이노드는 따로 갖고 있고 파일 데이터에 대상 파일의 경로를 링킹한다.

하드링크보다 소프트 링크가 더 많이 사용되긴 하지만, 하드링크는 특수한 목적을 갖고 사용한다.
일반적으론 소프트 링크는 사용하는 곳도 많고, 자주 사용된다. 

# [실습] 파일 다루기
- ls
  - -a: 숨겨지기 원하는 파일들이 보여진다 (.으로 시작하는)
- touch
  - 비어 있는 파일을 만드는 명령어
- mv
  - 파일의 경로를 바꾼다 -> 이름 바꾸기

# [실습] 디렉터리 다루기
디렉터리도 파일의 한 형태라 cp, mv 등이 가능하지만, 생성 같은 경우에 따로 명령어가 있다.
- mkdir
- rmdir
  - 디렉터리 삭제
  - 디렉터리 내에 파일, 디렉터리가 존재한다면 삭제 실패
    - rm -r 명령어와 옵션을 사용해서 지워야 한다. -> 재귀적으로 다 지운다.
      - -f 로 강제 지운다 -> -rf -> 조심히 써야 한다.

ls -al 입력시 폴더 부분의 권한을 보면 가장 앞에 d라고 되어 있다. 
디렉터리라는 뜻이다. d가 없다면 일반 파일이다.

# [실습] 아이노드와 하드링크
파일의 아이노드를 확인하는 방법이 있다.
- -i 또는 --inode
  - inode number를 출력해준다.

- 하드링크 생성하기
  - ln 명령어  

파일 커맨드 확인 명령어
- stat filename

# [실습] 소프트링크
소프트 링크 생성
- ln -s 또는 --symbolic
  - ln은 링크를 만들어준다는 것 (하드링크, 소프트 링크 동일)

성능적으로는 하드링크가 좋다. 그러나 대부분 소프트 링크를 사용
정말 고성능 앱을 만들지 않는 이상 소프트 링크를 쓰면 된다.
하드링크는 특수한 목적을 갖고 사용한다.

소프트 링크는 symlink를 절대 경로로 지정해야 파일이 옮겨지고 해도 링크한 파일을 찾을 수 있다. (상대 경로 X)
하드 링크는 아이노드를 공유하기 때문에 원본 파일과 경로가 달라져도 상관없다.

소프트 링크의 심 링크를 절대 경로만 사용하는 것은 아니다. 상대 경로를 써도 되지만, 유의해서 사용해야 한다.

