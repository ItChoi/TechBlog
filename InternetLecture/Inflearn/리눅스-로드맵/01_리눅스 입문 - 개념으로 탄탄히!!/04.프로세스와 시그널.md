# 프로세스란?
- 컴퓨터 시스템에서 프로세스는 일을 하는 주체를 의미한다.
  - 실행 중인 프로그램

프로그램은 저장 장치에 저장되어 있는 실행 파일이다. 
단순히 디스크에 저장되어 있는 상태

프로그램을 사용자가 실행시키면, 프로세스가 된다.

OS의 중요한 역할 중 하나가 프로세스를 관리하는 것이다.

시그널이란 프로세스에게 알려주는 행위이다.

리눅스 사용 관점에서 시그널을 알아야 리눅스를 이해하는데 도움이 된다.

# 프로세스 스케줄링
- 여러 프로세스를 컨텍스트 스위칭하며 실행
  - 여러 프로세스를 끊김없이 동시에 하는 것 처럼 느낄 수 있다.
  - 어떤 프로세스가 실행 차례인지 CPU 관점에서 스케줄링해준다.

핸드폰만 보더라도 CPU가 하나만 있진 않다.
삼성 핸드폰에도 옥타 코어가 있는데,
CPU라 불리우는 코어가 8개 있다.

멀티 코어 시스템, 멀티 코어 CPU 등은 실행 중이지 않은 프로세스의 개수를 줄일 수 있다.
즉 cpu가 한개라면 하나의 프로세스만 실행 가능하지만, 멀티 코어는 cpu 개수만큼 프로세스를 실행시킬 수 있다.
시스템 측면에서 CPU 개수가 늘어나는 만큼 성능이 늘어나게 된다.
멀티 코어 전에 CPU는 코어 클락이 중요했다.
클락 헤르츠가 올라갈수록 성능도 올라갔는데, 하나의 코어에서 클락을 높이면 온도, 열이 올라가서 냉각 시스템이 좋아져야 하고,
여러 문제들이 발생하게 된다.
따라서 인텔에서는 코어 클락을 높이기도 하지만, 코어 개수를 늘리기 시작했다.

현실은 CPU 코어 개수만큼 성능이 완전 좋아지진 않는다.
한 작업을 여러 프로세스가 나눠서 하는 것이 어려운 작업이다.

개발을 아~~~주 잘하면 성능이 좋아질 수도 있지만,
어느 순간 코어가 많아져도 성능이 좋아지지 않을 수도 있고 오히려 성능이 떨어질 수도 있다.

# 프로세스 상태
CPU 관점에서 여러 프로세스를 번갈아가며 처리한다.
프로세스마다 상태, 정보들을 관리해야, CPU 관점에서 해당 프로세스를 실행할지 말아야할지 기준을 잡을 수 있다.
그 중 하나가 프로세스 상태다.

프로세스 생성
- 대기 
  - 대기 중인 프로세스 중 하나를 실행한다.
- 실행
- 블록
  - 프로세스가 동작 중 인터럽트 발생 - I/O 작업, 주변기기가 응답을 하기 까진 긴 시간이 걸린다.
    - 응답이 올 때 까지 기다려야 하는 상황이다. (HDD, SSD)
- 종료

실행할 프로세스가 없는 경우 CPU는 idle 상태가 된다. (아무 것도 안하는)

# 프로세스 계층 구조
- PID (Process ID)
  - 프로세스마다 유니크한 숫자 ID
  - 번호 자체가 갖는 의미는 없다 (0번 제외 - init 프로세스)
- 부모 프로세스와 자식 프로세스
  - 하나의 프로세스가 다른 프로세스를 만들 수 있다. (부모(1) - (N)자식)
  - init 프로세스를 제외하고 모든 프로세스는 부모 프로세스가 있다.
- init 프로세스
  - 항상 PID 1을 갖는다. 
  - 리눅스 월드에서 전원이 켜지면 바이오스(부트로더)가 뜨고 OS가 뜨는데, 커널이 로드되면서 부팅을 시작하고, 가장 먼저 HW 자원을 초기화 한다. 그 후 프로세스 관련 초기화를 시작하는데, init 프로세스를 최초로 생성한다
    - 커널이 init 프로세스를 생성한다. 부모 프로세스가 없다.
    - 커널이 초기화 후 프로세스들을 여러 개 만들어내는데, init 프로세스를 부모로 하여 생성된다.
- 프로세스 종료 처리
  - 프로세스를 계층 구조로 만든 큰 이유 중 하나가 종료 처리다.
    - 부모 - 자식 프로세스가 있을 때, 프로세스간 관계는 있지만 별개로 동작한다. 
      - 자식 프로세스 종료시 종료 처리를 해야 할 게 있다.
        - 종료 프로세스는 사용하던 메모리 영역을 일부 남기게 되는데, 부모 프로세스가 처리해야 한다.
- 고아 프로세스와 좀비 프로세스
  - 자식 프로세스 종료시 부모 프로세스가 자식을 잘 처리해 야하는데, 잘 되지 않았을 때 고아, 좀비 프로세스가 된다.
  - 부모 프로세스가 먼저 종료 됐는데, 자식 프로세스가 여전히 남아 있을 때...
    - 고아 프로세스 종료시 종료 처리를 해줄 프로세스가 없다. (메모리 잔여, ...)
      - 그래서 리눅스에서는 init 프로세스가 고아 프로세스를 입양해준다. 부모가 init으로 된다.
    - 좀비 프로세스
      - 자식 프로세스가 종료될 때 부모 프로세스가 종료처리를 잘 하지 못할 수도 있다.
      - 부모 프로세스는 자식 프로세스를 폴링하거나 OS로부터 시그널을 받아서 종료처리가 됐음을 인지하면 종료 처리한다. 
        - OS가 부모 프로세스에게 자식 프로세스가 종료시 시그널을 보내준다.
          - 시그널을 받은 부모 프로세스가 종료 처리를 시작한다.
      - 부모 프로세스가 자식 프로세스를 폴링, 시그널 두 가지 형태를 안 하는 것, 자식 프로세스가 종료돼도 부모 프로세스가 종료 처리를 못 해준다.
        - 자식 프로세스는 반쯤 종료된 상태로 종료되지 않고 기다리고 있는다.
          - 완벽히 종료된 프로세스가 아니라, 리눅스 시스템 상에 남아 있다. -> 메모리 차지, PID, ... 여러 자원을 갖고 있다.
            - 좀비 프로세스가 쌓이면 PID나 메모리가 고갈된다. 

# 프로세스 종료 상태
프로세스 종료시 부모 프로세스가 자식 프로세스의 종료 처리를 한다.
종료 처리를 제대로 하지 않으면, 좀비 프로세스가 된다.

프로세스 종료 상태
- 프로세스 종료시 넘겨주는 정보
- 부모 프로세스에게 정보를 넘긴다.
  - 정상 종료 여부
  - 시그널 받아 종료 했는지 여부
  - 코어 덤프 생성했는지 여부

쉘 스크립트 안에 프로그래밍 코드들이 있을 때, 실행 커맨드는 전부 프로세스로 동작하고,
성공, 실패 여부에 따라 구성 가능하다.

자식 프로세스의 종료 상태 여부에 따라 판단하고 행동하는 것은 중요하다.
종료 상태 값은 보통 integer 정수로 받는데, 0: 성공, 다른 값: 실패

# 표준 스트림과 파일 디스크립터
모든 프로세스가 갖고 있는 표준 스트림이다.
모든 프로세스 생성시 각각 표준 스트림 세 가지 타입을 갖고 생성한다.
- 표준 스트림 
  - 표준 입력 (standard input) 
    - 프로세스에게 데이터 전달
    - stdin
  - 표준 출력 (standard output) 
    - 프로세스의 정보를 밖으로 전달
    - stdout
  - 표준 에러 (standard error) 
    - 출력과 에러를 나뉘었다.
    - stderr

프로세스는 하나의 입출력 창구와 같다.
메모리 상에 존재하는 실행 중인 프로그램인데,
프로세스는 사용자 혹은 다른 프로세스와 상호 작용을 해야한다. (커뮤니케이션)

터미널을 통해 키보드 입력이 있는 경우 표준 입력을 통해 프로세스에 전달되고,
프로세스 내에 데이터 또는 에러를 표준 출력과 에러를 통해 디스플레이 상에 출력한다.

프로세스가 스트림을 열게 되면 스트림 별로 고유 식별이 생긴다.
리눅스에서는 int 타입 번호로 부여된다.

프로세스 생성시 무조건 생성되는 표준 입력, 표준 출력, 표준 에러는 고정 번호를 부여해놨다.
1. stdin -> 0번
2. stdout -> 1번
3. stderr -> 2번

파일 오픈시 안의 내용을 읽을 때, 고유 번호 0,1,2 외 나머지 번호를 갖는 **파일 디스크립터**가 생긴다.

**파일 디스크립터 (file descriptor)**
- 프로세스가 파일을 통해 무언가를 할 때 필요한 객체다.
- 각각의 파일에 대한 고유 식별이 있어야 한다.
  - 파일 디스크립터를 통해 각 파일에 대한 작업을 구분하여 처리 가능
- 파일을 대변하는 객체
- 파일에 I/O를 하기 위해 파일 디스크립터를 열어야 한다.
- 프로세스에서 열린 파일 디스크립터 목록 관리


프로세스간 파일 디스크립터, 표준 스트림을 연결하기 위해 파이프나 리다이렉션을 통해 하기도 한다. (뒤에서 배운다.)

# 포어그라운드 프로세스와 백그라운드 프로세스
- 포어그라운드 프로세스 (foreground)
  - 쉘의 표준 입력이 연결된 프로세스
  - 표준 출력과 표준 에러도 쉘과 연결되어 있음
- 백그라운드 프로세스 (background)
  - 쉘의 표준 입력이 연결되지 않은 프로세스
    표준 출력과 표준 에러는 쉘과 연결되어 있음

셸도 하나의 프로세스로 동작한다. (bash, ...)
- 배시 프로세스가 생긴다. 
  - ls 커맨드 실행 -> 배시가 실행 및 종료 처리를 해준다.
  - ls처럼 가볍지 않은 스크립트를 만들어서 배시에서 실행
    - 스크립트가 끝날 때 까지 배시는 기다린다(default).
      - 스크립트 출력 부분을 화면에 출력해준다.
    - 사용자로부터 입력을 기다리는 스크립트라면 스크립트도 하나의 프로세스기 때문에 표준 입력(0)으로부터 입력을 기다리고 있을 수 있다.
      - 스크립트 프로세스의 표준 입력(0)이 bash하고 연결되어 있다.
        - 사용자는 배시를 통해 연결된 스크립트 표준 입력(0) 환경을 포어그라운드라고 한다.
    - 사용자 입력과는 상관없이 반복 작업을 하는 스크립트라면 (감시, 모니터링, ...) 사용자의 입력이 필요하지 않다. 
      - 백그라운드로 실행시켜, 하나의 쉘을 통해 여러 개의 프로세스를 실행 시킬 수 있다. 

기본적으로 실행 커맨드들은 포어그라운드로 뜬다.
뜨는 도중에 백그라운드로 보낼 수 있고, 시작부터 백그라운드 실행토록 가능하다.

사용자 입력 필요 여부에 따라 포어그라운드, 백그라운드로 지정할 수 있다.
사용자 인터랙티브 -> 포어그라운드 (ls, mv, ...)

# 데몬 프로세스
- 악마 프로세스?
  - '보이지 않는 곳에서 어떤 일을 하는 유령'에서 영감을 받음
- 데몬 프로세스란
  - 백그라운드 프로세스로 동작하기 위해 만들어진 프로세스
    - 묵묵히 작업 수행
  - 표준 스트림을 당연히 갖고 있지만, 모두 닫아버린다.
    - 쉘과 I/O 교환 불가
  - 부모 프로세스를 init 프로세스로 변경

프로세스가 실행되면서 데몬 프로세스로 만든다.
포어그라운드로 시작하더라도, 백그라운드로 동작한다.

ex) 모니터링, 백그라운드로 서비스 제공 등 데몬으로 돌린다.

# 시그널
- 비동기(asynchronous) 이벤트 처리를 위한 프로세스간 통신(IPC)
  - 프로세스간 비동기로 요청한다. 
- 프로세스가 다른 프로세스에게 시그널을 보내기도 하고 OS가 프로세스에게 시그널을 보내기도 한다.
- 시그널의 종류는 정해져 있다.
  - 주요 시그널 (대표적 사용만 나열)
    - SIGABRT: 의도적 중단을 의미
    - SIGALRM: 정해진 시간이 됐다는 의미
    - SIGBUS: 하드웨어 버스 에러
    - SIGCHLD: 자식 프로세스 종료
    - SIGSTOP: 프로세스 중지
    - SIGCONT: 중지된 프로세스 재시작
    - SIGHUP: 프로세스의 제어 터미널 닫힘
    - SIGINT: 사용자가 인터럽트 생성
    - SIGQUIT: 사용자가 종료 문자 생성
    - SIGTSTP: 사용자가 일시 중지 문자 생성
    - SIGIO: 비동기 입출력
    - SIGPIPE: 프롯스가 잘못된 파이프 쓰기 작업 시도
    - SIGSEGV: 메모리 세그먼트 접근 위반 프로그램 오류
    - SIGFPE: 산순 연산 예외 발생 프로그램 오류
    - SIGKILL: 프로세스 종료 명령
    - SIGTERM: 프로세스 종료 명령 (조건 처리 가능)
    - SIGUSR1: 사용자 정의 시그널 1
    - SIGUSR2: 사용자 정의 시그널 2
  - 외울 필욘 없다. 시그널 번호가 시그널 이름과 매핑되어 있다.
  - 해당 명령을 받으면 코어 덤프, 종료, 무시, 정지, 시작 등으로 이어진다.
    - 코어 덤프: 프로세스 동작 중 정보를 파일에 저장을 해놓는데, 코어 파일을 만들어 놓는 행위 -> 디버깅 툴이 코어 파일을 통해 분석 가능 

# [실습] 프로세스 목록 조회 및 구조 파악

# [실습] 프로세스 종료 상태

# [실습] 시그널 전송

# [실습] 포어그라운드 프로세스와 백그라운드 프로세스