# 프로세스란?
- 컴퓨터 시스템에서 프로세스는 일을 하는 주체를 의미한다.
  - 실행 중인 프로그램

프로그램은 저장 장치에 저장되어 있는 실행 파일이다. 
단순히 디스크에 저장되어 있는 상태

프로그램을 사용자가 실행시키면, 프로세스가 된다.

OS의 중요한 역할 중 하나가 프로세스를 관리하는 것이다.

시그널이란 프로세스에게 알려주는 행위이다.

리눅스 사용 관점에서 시그널을 알아야 리눅스를 이해하는데 도움이 된다.

# 프로세스 스케줄링
- 여러 프로세스를 컨텍스트 스위칭하며 실행
  - 여러 프로세스를 끊김없이 동시에 하는 것 처럼 느낄 수 있다.
  - 어떤 프로세스가 실행 차례인지 CPU 관점에서 스케줄링해준다.

핸드폰만 보더라도 CPU가 하나만 있진 않다.
삼성 핸드폰에도 옥타 코어가 있는데,
CPU라 불리우는 코어가 8개 있다.

멀티 코어 시스템, 멀티 코어 CPU 등은 실행 중이지 않은 프로세스의 개수를 줄일 수 있다.
즉 cpu가 한개라면 하나의 프로세스만 실행 가능하지만, 멀티 코어는 cpu 개수만큼 프로세스를 실행시킬 수 있다.
시스템 측면에서 CPU 개수가 늘어나는 만큼 성능이 늘어나게 된다.
멀티 코어 전에 CPU는 코어 클락이 중요했다.
클락 헤르츠가 올라갈수록 성능도 올라갔는데, 하나의 코어에서 클락을 높이면 온도, 열이 올라가서 냉각 시스템이 좋아져야 하고,
여러 문제들이 발생하게 된다.
따라서 인텔에서는 코어 클락을 높이기도 하지만, 코어 개수를 늘리기 시작했다.

현실은 CPU 코어 개수만큼 성능이 완전 좋아지진 않는다.
한 작업을 여러 프로세스가 나눠서 하는 것이 어려운 작업이다.

개발을 아~~~주 잘하면 성능이 좋아질 수도 있지만,
어느 순간 코어가 많아져도 성능이 좋아지지 않을 수도 있고 오히려 성능이 떨어질 수도 있다.

# 프로세스 상태
CPU 관점에서 여러 프로세스를 번갈아가며 처리한다.
프로세스마다 상태, 정보들을 관리해야, CPU 관점에서 해당 프로세스를 실행할지 말아야할지 기준을 잡을 수 있다.
그 중 하나가 프로세스 상태다.

프로세스 생성
- 대기 
  - 대기 중인 프로세스 중 하나를 실행한다.
- 실행
- 블록
  - 프로세스가 동작 중 인터럽트 발생 - I/O 작업, 주변기기가 응답을 하기 까진 긴 시간이 걸린다.
    - 응답이 올 때 까지 기다려야 하는 상황이다. (HDD, SSD)
- 종료

실행할 프로세스가 없는 경우 CPU는 idle 상태가 된다. (아무 것도 안하는)

# 프로세스 계층 구조
- PID (Process ID)
  - 프로세스마다 유니크한 숫자 ID
  - 번호 자체가 갖는 의미는 없다 (0번 제외 - init 프로세스)
- 부모 프로세스와 자식 프로세스
  - 하나의 프로세스가 다른 프로세스를 만들 수 있다. (부모(1) - (N)자식)
  - init 프로세스를 제외하고 모든 프로세스는 부모 프로세스가 있다.
- init 프로세스
  - 항상 PID 1을 갖는다. 
  - 리눅스 월드에서 전원이 켜지면 바이오스(부트로더)가 뜨고 OS가 뜨는데, 커널이 로드되면서 부팅을 시작하고, 가장 먼저 HW 자원을 초기화 한다. 그 후 프로세스 관련 초기화를 시작하는데, init 프로세스를 최초로 생성한다
    - 커널이 init 프로세스를 생성한다. 부모 프로세스가 없다.
    - 커널이 초기화 후 프로세스들을 여러 개 만들어내는데, init 프로세스를 부모로 하여 생성된다.
- 프로세스 종료 처리
  - 프로세스를 계층 구조로 만든 큰 이유 중 하나가 종료 처리다.
    - 부모 - 자식 프로세스가 있을 때, 프로세스간 관계는 있지만 별개로 동작한다. 
      - 자식 프로세스 종료시 종료 처리를 해야 할 게 있다.
        - 종료 프로세스는 사용하던 메모리 영역을 일부 남기게 되는데, 부모 프로세스가 처리해야 한다.
- 고아 프로세스와 좀비 프로세스
  - 자식 프로세스 종료시 부모 프로세스가 자식을 잘 처리해 야하는데, 잘 되지 않았을 때 고아, 좀비 프로세스가 된다.
  - 부모 프로세스가 먼저 종료 됐는데, 자식 프로세스가 여전히 남아 있을 때...
    - 고아 프로세스 종료시 종료 처리를 해줄 프로세스가 없다. (메모리 잔여, ...)
      - 그래서 리눅스에서는 init 프로세스가 고아 프로세스를 입양해준다. 부모가 init으로 된다.
    - 좀비 프로세스
      - 자식 프로세스가 종료될 때 부모 프로세스가 종료처리를 잘 하지 못할 수도 있다.
      - 부모 프로세스는 자식 프로세스를 폴링하거나 OS로부터 시그널을 받아서 종료처리가 됐음을 인지하면 종료 처리한다. 
        - OS가 부모 프로세스에게 자식 프로세스가 종료시 시그널을 보내준다.
          - 시그널을 받은 부모 프로세스가 종료 처리를 시작한다.
      - 부모 프로세스가 자식 프로세스를 폴링, 시그널 두 가지 형태를 안 하는 것, 자식 프로세스가 종료돼도 부모 프로세스가 종료 처리를 못 해준다.
        - 자식 프로세스는 반쯤 종료된 상태로 종료되지 않고 기다리고 있는다.
          - 완벽히 종료된 프로세스가 아니라, 리눅스 시스템 상에 남아 있다. -> 메모리 차지, PID, ... 여러 자원을 갖고 있다.
            - 좀비 프로세스가 쌓이면 PID나 메모리가 고갈된다. 

# 프로세스 종료 상태
프로세스 종료시 부모 프로세스가 자식 프로세스의 종료 처리를 한다.
종료 처리를 제대로 하지 않으면, 좀비 프로세스가 된다.

프로세스 종료 상태
- 프로세스 종료시 넘겨주는 정보
- 부모 프로세스에게 정보를 넘긴다.
  - 정상 종료 여부
  - 시그널 받아 종료 했는지 여부
  - 코어 덤프 생성했는지 여부

쉘 스크립트 안에 프로그래밍 코드들이 있을 때, 실행 커맨드는 전부 프로세스로 동작하고,
성공, 실패 여부에 따라 구성 가능하다.

자식 프로세스의 종료 상태 여부에 따라 판단하고 행동하는 것은 중요하다.
종료 상태 값은 보통 integer 정수로 받는데, 0: 성공, 다른 값: 실패


# 표준 스트림과 파일 디스크립터

# 포어그라운드 프로세스와 백그라운드 프로세스

# 데몬 프로세스

# 시그널

# [실습] 프로세스 목록 조회 및 구조 파악

# [실습] 프로세스 종료 상태

# [실습] 시그널 전송

# [실습] 포어그라운드 프로세스와 백그라운드 프로세스